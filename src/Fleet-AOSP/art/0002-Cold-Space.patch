From d17ab3f4c9a9c426300783bf67f24735c948d376 Mon Sep 17 00:00:00 2001
From: jiachengh <jiacheng.huang@outlook.com>
Date: Mon, 23 Aug 2021 16:31:16 +0800
Subject: [PATCH 2/7] Cold Space

Change-Id: I79f0b7b09889c4f1619ecbbc788e138a086c4522
Signed-off-by: jiachengh <jiacheng.huang@outlook.com>
---
 dex2oat/dex2oat.cc                            |   5 +-
 runtime/Android.bp                            |   7 +
 runtime/gc/collector/concurrent_copying-inl.h |  65 +-
 runtime/gc/collector/concurrent_copying.cc    | 138 +++-
 runtime/gc/collector/garbage_collector.cc     |  13 +
 runtime/gc/heap.cc                            |  72 +++
 runtime/gc/heap.h                             |   7 +
 runtime/gc/space/region_space.cc              |   6 +
 runtime/jiacheng_activity_manager.cc          | 147 +++++
 runtime/jiacheng_activity_manager.h           |  88 +++
 runtime/jiacheng_cheatsheet.cc                |  26 +
 runtime/jiacheng_cheatsheet.h                 |  28 +
 runtime/jiacheng_cold_space.cc                | 171 +++++
 runtime/jiacheng_cold_space.h                 | 103 +++
 runtime/jiacheng_hack.cc                      | 594 ++++++++++++++++++
 runtime/jiacheng_hack.h                       | 104 +++
 runtime/jiacheng_region.cc                    |  41 ++
 runtime/jiacheng_region.h                     |  59 ++
 runtime/native/dalvik_system_VMRuntime.cc     |  27 +
 runtime/read_barrier-inl.h                    |  48 +-
 20 files changed, 1726 insertions(+), 23 deletions(-)
 create mode 100644 runtime/jiacheng_activity_manager.cc
 create mode 100644 runtime/jiacheng_activity_manager.h
 create mode 100644 runtime/jiacheng_cheatsheet.cc
 create mode 100644 runtime/jiacheng_cheatsheet.h
 create mode 100644 runtime/jiacheng_cold_space.cc
 create mode 100644 runtime/jiacheng_cold_space.h
 create mode 100644 runtime/jiacheng_hack.cc
 create mode 100644 runtime/jiacheng_hack.h
 create mode 100644 runtime/jiacheng_region.cc
 create mode 100644 runtime/jiacheng_region.h

diff --git a/dex2oat/dex2oat.cc b/dex2oat/dex2oat.cc
index 278523ec9a..bd9019a81c 100644
--- a/dex2oat/dex2oat.cc
+++ b/dex2oat/dex2oat.cc
@@ -2241,7 +2241,10 @@ class Dex2Oat final {
   }
 
   bool UseProfile() const {
-    return profile_file_fd_ != -1 || !profile_file_.empty();
+    // jiacheng start
+    // return profile_file_fd_ != -1 || !profile_file_.empty();
+    return false;
+    // jiacheng end
   }
 
   bool DoProfileGuidedOptimizations() const {
diff --git a/runtime/Android.bp b/runtime/Android.bp
index 7bf662c652..c494be159c 100644
--- a/runtime/Android.bp
+++ b/runtime/Android.bp
@@ -105,6 +105,13 @@ libart_cc_defaults {
         "interpreter/shadow_frame.cc",
         "interpreter/unstarted_runtime.cc",
         "java_frame_root_info.cc",
+// jiacheng start ------------------------------------
+        "jiacheng_cheatsheet.cc",
+        "jiacheng_cold_space.cc",
+        "jiacheng_hack.cc",
+        "jiacheng_region.cc",
+        "jiacheng_activity_manager.cc",
+// jiacheng end --------------------------------------
         "jdwp/jdwp_event.cc",
         "jdwp/jdwp_expand_buf.cc",
         "jdwp/jdwp_handler.cc",
diff --git a/runtime/gc/collector/concurrent_copying-inl.h b/runtime/gc/collector/concurrent_copying-inl.h
index 2de79107f4..ecf7caed2f 100644
--- a/runtime/gc/collector/concurrent_copying-inl.h
+++ b/runtime/gc/collector/concurrent_copying-inl.h
@@ -28,6 +28,11 @@
 #include "mirror/class.h"
 #include "mirror/object-readbarrier-inl.h"
 
+// jiacheng start  
+#include "jiacheng_cold_space.h"
+#include "jiacheng_hack.h"
+// jiacheng end
+
 namespace art {
 namespace gc {
 namespace collector {
@@ -149,14 +154,33 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
     // are consulted. If they look like gray but aren't really, the
     // read barriers slow path can trigger when it shouldn't. To guard
     // against this, return here if the CC collector isn't running.
+
+    // jiacheng start
+    jiacheng::GCMarkTrigger(from_ref);
+    // jiacheng end
     return from_ref;
   }
   DCHECK(region_space_ != nullptr) << "Read barrier slow path taken when CC isn't running?";
-  if (region_space_->HasAddress(from_ref)) {
+  // jiahceng start -------------------------------------_
+    if (jiacheng::ColdSpace::Current()->HasAddress(from_ref)) {
+      // Mark在ColdSpace中的对象，把该对象标灰
+      // bool success = from_ref->AtomicSetReadBarrierState(ReadBarrier::WhiteState(), ReadBarrier::GrayState());
+      bool success = from_ref->AtomicSetReadBarrierState(ReadBarrier::NonGrayState(), ReadBarrier::GrayState());
+      if (success) {
+        PushOntoMarkStack(self, from_ref);
+      }
+      jiacheng::GCMarkTrigger(from_ref);
+      return from_ref;
+    }  else if (region_space_->HasAddress(from_ref)) {
+  // if (region_space_->HasAddress(from_ref)) {
+  // jiacheng end -------------------------------------
     space::RegionSpace::RegionType rtype = region_space_->GetRegionTypeUnsafe(from_ref);
     switch (rtype) {
       case space::RegionSpace::RegionType::kRegionTypeToSpace:
         // It's already marked.
+        // jiacheng start
+        jiacheng::GCMarkTrigger(from_ref);
+        // jiacheng end
         return from_ref;
       case space::RegionSpace::RegionType::kRegionTypeFromSpace: {
         mirror::Object* to_ref = GetFwdPtr(from_ref);
@@ -166,18 +190,33 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
         }
         // The copy should either be in a to-space region, or in the
         // non-moving space, if it could not fit in a to-space region.
-        DCHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
+        // jiacheng start
+        // DCHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
+        //     << "from_ref=" << from_ref << " to_ref=" << to_ref;
+        DCHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref) 
+               || jiacheng::ColdSpace::Current()->HasAddress(to_ref))
             << "from_ref=" << from_ref << " to_ref=" << to_ref;
+        jiacheng::GCMarkTrigger(to_ref);
+        // jiacheng end
         return to_ref;
       }
-      case space::RegionSpace::RegionType::kRegionTypeUnevacFromSpace:
+      case space::RegionSpace::RegionType::kRegionTypeUnevacFromSpace: {
         if (kNoUnEvac && use_generational_cc_ && !region_space_->IsLargeObject(from_ref)) {
           if (!kFromGCThread) {
             DCHECK(IsMarkedInUnevacFromSpace(from_ref)) << "Returning unmarked object to mutator";
           }
+          // jiacheng start
+          jiacheng::GCMarkTrigger(from_ref);
+          // jiacheng end
           return from_ref;
         }
-        return MarkUnevacFromSpaceRegion(self, from_ref, region_space_bitmap_);
+        // jiacheng start
+        // return MarkUnevacFromSpaceRegion(self, from_ref, region_space_bitmap_);
+        mirror::Object* temp_ref = MarkUnevacFromSpaceRegion(self, from_ref, region_space_bitmap_);
+        jiacheng::GCMarkTrigger(temp_ref);
+        // jiacheng end
+        return temp_ref;
+      }
       default:
         // The reference is in an unused region. Remove memory protection from
         // the region space and log debugging information.
@@ -189,9 +228,19 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
     }
   } else {
     if (immune_spaces_.ContainsObject(from_ref)) {
-      return MarkImmuneSpace<kGrayImmuneObject>(self, from_ref);
+      // jiacheng start
+      // return MarkImmuneSpace<kGrayImmuneObject>(self, from_ref);
+      mirror::Object* temp_ref = MarkImmuneSpace<kGrayImmuneObject>(self, from_ref);
+      jiacheng::GCMarkTrigger(temp_ref);
+      return temp_ref;
+      // jiacheng end
     } else {
-      return MarkNonMoving(self, from_ref, holder, offset);
+      // jiacheng start
+      // return MarkNonMoving(self, from_ref, holder, offset);
+      mirror::Object* temp_ref = MarkNonMoving(self, from_ref, holder, offset);
+      jiacheng::GCMarkTrigger(temp_ref);
+      return temp_ref;
+      // jiacheng end
     }
   }
 }
@@ -225,7 +274,9 @@ inline mirror::Object* ConcurrentCopying::MarkFromReadBarrier(mirror::Object* fr
 }
 
 inline mirror::Object* ConcurrentCopying::GetFwdPtr(mirror::Object* from_ref) {
-  DCHECK(region_space_->IsInFromSpace(from_ref));
+  // jiacheng start
+  // DCHECK(region_space_->IsInFromSpace(from_ref));
+  // jiacheng end
   LockWord lw = from_ref->GetLockWord(false);
   if (lw.GetState() == LockWord::kForwardingAddress) {
     mirror::Object* fwd_ptr = reinterpret_cast<mirror::Object*>(lw.ForwardingAddress());
diff --git a/runtime/gc/collector/concurrent_copying.cc b/runtime/gc/collector/concurrent_copying.cc
index 9428a0b8cd..70c0d58882 100644
--- a/runtime/gc/collector/concurrent_copying.cc
+++ b/runtime/gc/collector/concurrent_copying.cc
@@ -47,6 +47,12 @@
 #include "thread_list.h"
 #include "well_known_classes.h"
 
+// jiacheng start
+#include "jiacheng_cold_space.h"
+#include "jiacheng_activity_manager.h"
+#include <iostream>
+// jiacheng end
+
 namespace art {
 namespace gc {
 namespace collector {
@@ -195,10 +201,16 @@ void ConcurrentCopying::RunPhases() {
   {
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
     InitializePhase();
+    // jiacheng start  -------------------
+    LOG(INFO) << "jiacheng concurrent_copying.cc 175 InitializePhase Pass" << std::flush;
+    // jiacheng end ----------------------
     // In case of forced evacuation, all regions are evacuated and hence no
     // need to compute live_bytes.
     if (use_generational_cc_ && !young_gen_ && !force_evacuate_all_) {
       MarkingPhase();
+    // jiacheng start  -------------------
+    LOG(INFO) << "jiacheng concurrent_copying.cc 195 MarkingPhase Pass" << std::flush;
+    // jiacheng end ----------------------
     }
   }
   if (kUseBakerReadBarrier && kGrayDirtyImmuneObjects) {
@@ -209,6 +221,9 @@ void ConcurrentCopying::RunPhases() {
     // the pause.
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
     GrayAllDirtyImmuneObjects();
+    // jiacheng start  -------------------
+    LOG(INFO) << "jiacheng concurrent_copying.cc 187 GrayAllDirtyImmuneObjects Pass" << std::flush;
+    // jiacheng end ----------------------
   }
   FlipThreadRoots();
   {
@@ -233,7 +248,13 @@ void ConcurrentCopying::RunPhases() {
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
     ReclaimPhase();
   }
+  // jiacheng start  -------------------
+  LOG(INFO) << "jiacheng concurrent_copying.cc 219 ReclaimPhase Pass" << std::flush;
+  // jiacheng end ----------------------
   FinishPhase();
+  // jiacheng start  -------------------
+  LOG(INFO) << "jiacheng concurrent_copying.cc 223 FinishPhase Pass" << std::flush;
+  // jiacheng end ----------------------
   CHECK(is_active_);
   is_active_ = false;
   thread_running_gc_ = nullptr;
@@ -1799,9 +1820,13 @@ void ConcurrentCopying::PushOntoMarkStack(Thread* const self, mirror::Object* to
         << "ref=" << to_ref
         << " self->gc_marking=" << self->GetIsGcMarking()
         << " cc->is_marking=" << is_marking_;
-    CHECK(self == thread_running_gc_)
-        << "Only GC-running thread should access the mark stack "
-        << "in the GC exclusive mark stack mode";
+
+    // jiacheng start ----------------------------
+    // CHECK(self == thread_running_gc_)
+    //     << "Only GC-running thread should access the mark stack "
+    //     << "in the GC exclusive mark stack mode";
+    // jiacheng end ------------------------------
+
     // Access the GC mark stack without a lock.
     if (UNLIKELY(gc_mark_stack_->IsFull())) {
       ExpandGcMarkStack();
@@ -2182,6 +2207,17 @@ inline void ConcurrentCopying::ProcessMarkStackRef(mirror::Object* to_ref) {
       perform_scan = true;
       break;
     default:
+  // // jiacheng start ---------------------------------
+  // code in android 9 这里不能直接用
+  // else if (jiacheng::ColdSpace::Current()->HasAddress(to_ref)) {
+  //   jiacheng::ColdSpace* cold_space = jiacheng::ColdSpace::Current();
+  //   if (!cold_space->GetMarkBitmap(to_ref)) {
+  //     cold_space->SetMarkBitmap(to_ref);
+  //     Scan(to_ref);
+  //   }
+  // }
+  // // jiacheng end -----------------------------------
+
       DCHECK(!region_space_->HasAddress(to_ref)) << to_ref;
       DCHECK(!immune_spaces_.ContainsObject(to_ref));
       // Non-moving or large-object space.
@@ -2244,9 +2280,24 @@ inline void ConcurrentCopying::ProcessMarkStackRef(mirror::Object* to_ref) {
                 (referent = to_ref->AsReference()->GetReferent<kWithoutReadBarrier>()) != nullptr &&
                 !IsInToSpace(referent)))) {
     // Leave this reference gray in the queue so that GetReferent() will trigger a read barrier. We
+    
     // will change it to non-gray later in ReferenceQueue::DisableReadBarrierForReference.
-    DCHECK(to_ref->AsReference()->GetPendingNext() != nullptr)
-        << "Left unenqueued ref gray " << to_ref;
+    // jiacheng start --------------------------
+    if (jiacheng::ColdSpace::Current()->HasAddress(referent)) {
+      if (kUseBakerReadBarrier) {
+        bool success = to_ref->AtomicSetReadBarrierState<std::memory_order_release>(
+            ReadBarrier::GrayState(),
+            ReadBarrier::NonGrayState());
+        DCHECK(success) << "Must succeed as we won the race.";
+      }
+    } else {
+      DCHECK(to_ref->AsReference()->GetPendingNext() != nullptr)
+          << "Left unenqueued ref gray " << to_ref;
+    }
+    // DCHECK(to_ref->AsReference()->GetPendingNext() != nullptr)
+    //     << "Left unenqueued ref gray " << to_ref;
+  // jiacheng end ----------------------------
+
   } else {
     // We may occasionally leave a reference non-gray in the queue if its referent happens to be
     // concurrently marked after the Scan() call above has enqueued the Reference, in which case the
@@ -2367,7 +2418,9 @@ void ConcurrentCopying::CheckEmptyMarkStack() {
   } else {
     // Shared, GC-exclusive, or off.
     MutexLock mu(thread_running_gc_, mark_stack_lock_);
-    CHECK(gc_mark_stack_->IsEmpty());
+    // jiacheng start -------------------------------
+    // CHECK(gc_mark_stack_->IsEmpty());
+    // jiacheng end ---------------------------------
     CHECK(revoked_mark_stacks_.empty());
   }
 }
@@ -2814,7 +2867,13 @@ void ConcurrentCopying::AssertToSpaceInvariant(mirror::Object* obj,
         LOG(FATAL) << "Invalid reference " << ref
                    << " referenced from object " << obj << " at offset " << offset;
       }
-    } else {
+    } 
+    // jiacheng start -------------------------
+    else if (jiacheng::ColdSpace::Current()->HasAddress(ref)) {
+      // pass
+    }
+    // jiacheng end ---------------------------
+    else {
       // Check to-space invariant in non-moving space.
       AssertToSpaceInvariantInNonMovingSpace(obj, ref);
     }
@@ -3070,6 +3129,11 @@ class ConcurrentCopying::RefFieldsVisitor {
 
 template <bool kNoUnEvac>
 inline void ConcurrentCopying::Scan(mirror::Object* to_ref) {
+  // jiacheng start  -------------------------------------
+  // LOG(INFO) << "jiacheng concurrent_copying.cc 2147 Scan() to_ref= " << to_ref 
+  //           << " ColdSpace::HasAddress()= " << jiacheng::ColdSpace::Current()->HasAddress(to_ref);
+
+  // jiacheng end ----------------------------------------
   // Cannot have `kNoUnEvac` when Generational CC collection is disabled.
   DCHECK(!kNoUnEvac || use_generational_cc_);
   if (kDisallowReadBarrierDuringScan && !Runtime::Current()->IsActiveTransaction()) {
@@ -3101,6 +3165,10 @@ inline void ConcurrentCopying::Process(mirror::Object* obj, MemberOffset offset)
       ref,
       /*holder=*/ obj,
       offset);
+  // jiacheng start
+  // LOG(INFO) << "Father= " << reinterpret_cast<size_t>(obj) << ' ' << (obj?obj->PrettyTypeOf():"null") 
+  //           << " Child= " << reinterpret_cast<size_t>(to_ref) << ' ' << (to_ref?to_ref->PrettyTypeOf():"null");
+  // jiacheng end
   if (to_ref == ref) {
     return;
   }
@@ -3336,8 +3404,25 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
   size_t bytes_allocated = 0U;
   size_t dummy;
   bool fall_back_to_non_moving = false;
-  mirror::Object* to_ref = region_space_->AllocNonvirtual</*kForEvac=*/ true>(
-      region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
+  // jiacheng start --------------------------------
+  // mirror::Object* to_ref = region_space_->AllocNonvirtual</*kForEvac=*/ true>(
+  //     region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
+  mirror::Object* to_ref = nullptr;
+  if (region_space_alloc_size <= jiacheng::ColdSpace::kRegionSize &&
+      jiacheng::ActivityManager::Current()->ShouldSwapOut(from_ref)) {
+    to_ref = jiacheng::ColdSpace::Current()->Alloc(region_space_alloc_size);
+    region_space_bytes_allocated = region_space_alloc_size;
+    LOG(INFO) << "jiacheng concurrent_copying.cc 2412 ColdSpace::Current()->Alloc()" 
+              << " region_space_alloc_size= " << region_space_alloc_size 
+              << " to_ref= " << to_ref
+              << " GetAllocatedObjNum()= " << jiacheng::ColdSpace::Current()->GetAllocatedObjNum();
+  }
+  if (!to_ref) {
+    to_ref = region_space_->AllocNonvirtual</*kForEvac*/ true>(
+            region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
+  }
+  // jiacheng end --------------------------------
+
   bytes_allocated = region_space_bytes_allocated;
   if (LIKELY(to_ref != nullptr)) {
     DCHECK_EQ(region_space_alloc_size, region_space_bytes_allocated);
@@ -3400,7 +3485,13 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
       // look like a valid but dead (dummy) object and keep it for
       // future reuse.
       FillWithDummyObject(self, to_ref, bytes_allocated);
-      if (!fall_back_to_non_moving) {
+      // jiacheng start  -----------------------------------
+      if (jiacheng::ColdSpace::Current()->HasAddress(to_ref)) {
+        /* Don't do any thing */
+      }
+      else if (!fall_back_to_non_moving) {
+      // if (!fall_back_to_non_moving) {
+      // jiacheng end -----------------------------------
         DCHECK(region_space_->IsInToSpace(to_ref));
         if (bytes_allocated > space::RegionSpace::kRegionSize) {
           // Free the large alloc.
@@ -3426,8 +3517,14 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
       to_ref = reinterpret_cast<mirror::Object*>(old_lock_word.ForwardingAddress());
       CHECK(to_ref != nullptr);
       CHECK_NE(to_ref, lost_fwd_ptr);
-      CHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
+
+      // jiacheng start ----------------------------------- 增加对ColdSpace的判断
+      // CHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
+      //     << "to_ref=" << to_ref << " " << heap_->DumpSpaces();
+      CHECK(region_space_->IsInToSpace(to_ref) || jiacheng::ColdSpace::Current()->HasAddress(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
           << "to_ref=" << to_ref << " " << heap_->DumpSpaces();
+      // jiacheng end -----------------------------------
+      
       CHECK_NE(to_ref->GetLockWord(false).GetState(), LockWord::kForwardingAddress);
       return to_ref;
     }
@@ -3461,7 +3558,14 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
         bytes_moved_.fetch_add(bytes_allocated, std::memory_order_relaxed);
       }
 
-      if (LIKELY(!fall_back_to_non_moving)) {
+      // jiacheng start  --------------------------------
+      if (jiacheng::ColdSpace::Current()->HasAddress(to_ref)) {
+        // pass
+        // LOG(INFO) << "jiacheng concurrent_copying.cc 2516";
+      } else if (LIKELY(!fall_back_to_non_moving)) {
+      // if (LIKELY(!fall_back_to_non_moving)) {
+      // jiacheng end  --------------------------------
+
         DCHECK(region_space_->IsInToSpace(to_ref));
       } else {
         DCHECK(heap_->non_moving_space_->HasAddress(to_ref));
@@ -3499,9 +3603,17 @@ mirror::Object* ConcurrentCopying::IsMarked(mirror::Object* from_ref) {
   mirror::Object* to_ref;
   if (rtype == space::RegionSpace::RegionType::kRegionTypeFromSpace) {
     to_ref = GetFwdPtr(from_ref);
+
+    // jiacheng start ------------------------------------
+    // DCHECK(to_ref == nullptr || region_space_->IsInToSpace(to_ref) ||
+    //        heap_->non_moving_space_->HasAddress(to_ref))
+    //     << "from_ref=" << from_ref << " to_ref=" << to_ref;
     DCHECK(to_ref == nullptr || region_space_->IsInToSpace(to_ref) ||
-           heap_->non_moving_space_->HasAddress(to_ref))
+           heap_->non_moving_space_->HasAddress(to_ref) || 
+           jiacheng::ColdSpace::Current()->HasAddress(to_ref))
         << "from_ref=" << from_ref << " to_ref=" << to_ref;
+    // jiacheng end  -------------------------------------
+    
   } else if (rtype == space::RegionSpace::RegionType::kRegionTypeUnevacFromSpace) {
     if (IsMarkedInUnevacFromSpace(from_ref)) {
       to_ref = from_ref;
diff --git a/runtime/gc/collector/garbage_collector.cc b/runtime/gc/collector/garbage_collector.cc
index 1785a7789b..565d38e6ec 100644
--- a/runtime/gc/collector/garbage_collector.cc
+++ b/runtime/gc/collector/garbage_collector.cc
@@ -38,6 +38,10 @@
 #include "thread-current-inl.h"
 #include "thread_list.h"
 
+// jiacheng start
+#include "jiacheng_hack.h"
+// jiacheng end
+
 namespace art {
 namespace gc {
 namespace collector {
@@ -144,6 +148,11 @@ uint64_t GarbageCollector::ExtractRssFromMincore(
 }
 
 void GarbageCollector::Run(GcCause gc_cause, bool clear_soft_references) {
+
+  // jiacheng start
+  jiacheng::BeforeGarbageCollectorRun(this);
+  // jiacheng end
+
   ScopedTrace trace(android::base::StringPrintf("%s %s GC", PrettyCause(gc_cause), GetName()));
   Thread* self = Thread::Current();
   uint64_t start_time = NanoTime();
@@ -182,6 +191,10 @@ void GarbageCollector::Run(GcCause gc_cause, bool clear_soft_references) {
     pause_histogram_.AdjustAndAddValue(pause_time);
   }
   is_transaction_active_ = false;
+
+  // jiacheng start
+  jiacheng::AfterGarbageCollectorRun(this);
+  // jiacheng end  
 }
 
 void GarbageCollector::SwapBitmaps() {
diff --git a/runtime/gc/heap.cc b/runtime/gc/heap.cc
index ff53f7896e..2720f4dab9 100644
--- a/runtime/gc/heap.cc
+++ b/runtime/gc/heap.cc
@@ -720,6 +720,78 @@ Heap::Heap(size_t initial_size,
   }
 }
 
+// jiacheng start
+void Heap::JiachengDebug() {
+  // 用于显示Heap当前的信息
+  Thread* self = Thread::Current();
+
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "alloc_spaces_.size= " << alloc_spaces_.size();
+  for (auto& it : alloc_spaces_) {
+      LOG(INFO) << "jiacheng heap.cc 641: "
+                << "space_addr= " << size_t(it);
+  } 
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "non_moving_space= " << size_t(non_moving_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "rosalloc_space_= " << size_t(rosalloc_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "dlmalloc_space_= " << size_t(dlmalloc_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "main_space_= " << size_t(main_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "large_object_space_= " << size_t(large_object_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "zygote_space_= " << size_t(zygote_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "bump_pointer_space_= " << size_t(bump_pointer_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "temp_space_= " << size_t(temp_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "region_space_= " << size_t(region_space_); 
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "main_space_backup_= " << size_t(main_space_backup_.get());
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "current_allocator_= " << current_allocator_;   
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "current_non_moving_allocator_= " << current_non_moving_allocator_;   
+
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "collector_type_= " << collector_type_;
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "foreground_collector_type_= " << foreground_collector_type_;
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "background_collector_type_= " << background_collector_type_;
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "desired_collector_type_= " << desired_collector_type_;
+
+  gc_complete_lock_->ExclusiveLock(self);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "collector_type_running_= " << collector_type_running_;
+  gc_complete_lock_->ExclusiveUnlock(self);
+
+
+  for (auto& it : gc_plan_) {
+    LOG(INFO) << "jiacheng heap.cc 641: "
+              << "gc_plan_= " << it;
+  }
+
+  for (auto& it : garbage_collectors_) {
+    LOG(INFO) << "jiacheng heap.cc 641: "
+              << "garbage_collector_= " << size_t(it);
+  }
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "semi_space_collector_= " << semi_space_collector_;
+  // LOG(INFO) << "jiacheng heap.cc 641: "
+  //           << "mark_compact_collector_= " << mark_compact_collector_;
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "concurrent_copying_collector_= " << concurrent_copying_collector_;
+
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "use_tlab_= " << use_tlab_;
+}
+// jiacheng end
+
 MemMap Heap::MapAnonymousPreferredAddress(const char* name,
                                           uint8_t* request_begin,
                                           size_t capacity,
diff --git a/runtime/gc/heap.h b/runtime/gc/heap.h
index 5cf197869d..4f266fcd5e 100644
--- a/runtime/gc/heap.h
+++ b/runtime/gc/heap.h
@@ -128,7 +128,10 @@ static constexpr bool kUseThreadLocalAllocationStack = true;
 class Heap {
  public:
   static constexpr size_t kDefaultStartingSize = kPageSize;
+  // jiacheng start
   static constexpr size_t kDefaultInitialSize = 2 * MB;
+  // static constexpr size_t kDefaultInitialSize = 256 * MB;
+  // jiacheng end
   static constexpr size_t kDefaultMaximumSize = 256 * MB;
   static constexpr size_t kDefaultNonMovingSpaceCapacity = 64 * MB;
   static constexpr size_t kDefaultMaxFree = 2 * MB;
@@ -221,6 +224,10 @@ class Heap {
 
   ~Heap();
 
+  // jiacheng start
+  void JiachengDebug();
+  // jiacheng end
+
   // Allocates and initializes storage for an object instance.
   template <bool kInstrumented, typename PreFenceVisitor>
   mirror::Object* AllocObject(Thread* self,
diff --git a/runtime/gc/space/region_space.cc b/runtime/gc/space/region_space.cc
index 823043ec75..d0555b0896 100644
--- a/runtime/gc/space/region_space.cc
+++ b/runtime/gc/space/region_space.cc
@@ -47,6 +47,12 @@ static constexpr uint32_t kPoisonDeadObject = 0xBADDB01D;  // "BADDROID"
 // Whether we check a region's live bytes count against the region bitmap.
 static constexpr bool kCheckLiveBytesAgainstRegionBitmap = kIsDebugBuild;
 
+// jiacheng start
+// void RegionSpace::JiachengDebug() {
+  
+// }
+// jiacheng end
+
 MemMap RegionSpace::CreateMemMap(const std::string& name,
                                  size_t capacity,
                                  uint8_t* requested_begin) {
diff --git a/runtime/jiacheng_activity_manager.cc b/runtime/jiacheng_activity_manager.cc
new file mode 100644
index 0000000000..9f359b1a74
--- /dev/null
+++ b/runtime/jiacheng_activity_manager.cc
@@ -0,0 +1,147 @@
+#include "thread-current-inl.h"
+#include "base/mutex.h"
+
+#include "jiacheng_activity_manager.h"
+
+namespace art {
+namespace jiacheng {
+
+Mutex ActivityManager::singleton_lock_("Activity Manager Singleton Lock", kLoggingLock);
+ActivityManager* ActivityManager::activity_manager_(nullptr); 
+
+ActivityManager::ActivityManager():
+    activity_manager_lock_("Activity Manager Lock", kLoggingLock),
+    // current_working_set_(new std::set<mirror::Object*>()),
+    current_working_set_(nullptr),
+    current_activity_name_(""),
+    activity_ws_map_(),
+    sampling_(false),
+    in_gc_(true),
+    gc_time_(0) {
+    
+    // default working set
+    // activity_ws_map_[""] = current_working_set_;
+}
+
+ActivityManager::~ActivityManager() {
+}
+
+ActivityManager* ActivityManager::Create() {
+    ActivityManager* it = new ActivityManager();
+    return it;
+}
+
+ActivityManager* ActivityManager::Current() {
+    if (activity_manager_ == nullptr) {
+        Thread* self = Thread::Current();
+        singleton_lock_.ExclusiveLock(self);
+        if (activity_manager_ == nullptr) {
+            activity_manager_ = Create();
+        }
+        singleton_lock_.ExclusiveUnlock(self);
+    }
+    return activity_manager_;
+}
+
+void ActivityManager::JiachengDebug() const {
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "current_working_set_=" << size_t(current_working_set_);
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "current_activity_name_=" << current_activity_name_;
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "activity_ws_map_= " << activity_ws_map_.size();
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "sampling_= " << sampling_.load();
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "in_gc_= " << in_gc_.load();
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "gc_time_= " << gc_time_.load();
+}
+
+bool ActivityManager::ShouldSwapOut(mirror::Object *obj) {
+    bool res = false;
+    // Thread* self = Thread::Current();
+    // activity_manager_lock_.ExclusiveLock(self);
+    if (current_working_set_ != nullptr && current_working_set_->find(obj) == current_working_set_->end()) {
+        res = true;
+    }
+    // activity_manager_lock_.ExclusiveUnlock(self);
+    return res;
+
+    // (void)obj;
+    // return true;
+}
+
+
+void ActivityManager::RecordWS(mirror::Object* obj) {
+    // 只要指定采样的时候才采样
+    if (!sampling_.load()) { 
+        return;
+    }
+
+    Thread *self = Thread::Current();
+
+    activity_manager_lock_.ExclusiveLock(self);
+    if (current_working_set_) {
+        current_working_set_->insert(obj);
+    }
+    activity_manager_lock_.ExclusiveUnlock(self);
+}
+
+ 
+void ActivityManager::UpdateActivityState(const std::string& activity_name, int state) {
+    if (state != 1) { // RESUMED
+        return;
+    }
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 83 UpdateActivityState()"
+              << " activity_name= " << activity_name
+              << " state= " << state
+              << std::flush;
+    // Debug Start 计算每个工作集之间的交集
+    for (const auto& it : activity_ws_map_) {
+        LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 68 activity_set_size= "
+                  << it.first << ' '
+                  << (it.second)->size();
+    }
+    Thread *self = Thread::Current();
+    // std::vector<mirror::Object*> intersection;
+
+    // activity_manager_lock_.ExclusiveLock(self);
+    // for (const auto& it : activity_ws_map_) {
+    //     const std::set<mirror::Object*>* s1 = it.second;
+    //     for (const auto& it2 : activity_ws_map_) {
+    //         const std::set<mirror::Object*>* s2 = it2.second;
+    //         std::set_intersection(
+    //             s1->begin(), s1->end(), 
+    //             s2->begin(), s2->end(), 
+    //             std::back_inserter(intersection)
+    //         );
+    //         LOG(INFO) << "intersection.size()# " <<it.first << " and " << it2.first << "= " << intersection.size();
+    //         intersection.clear();
+    //     }
+    // }
+    // activity_manager_lock_.ExclusiveUnlock(self);
+    // Debug End
+
+
+    // 更新当前的Activity Name
+    activity_manager_lock_.ExclusiveLock(self);
+    
+    current_activity_name_ = activity_name;
+
+    std::map<std::string, std::set<mirror::Object*>*>::iterator it = activity_ws_map_.find(current_activity_name_);
+    if (it == activity_ws_map_.end()) {
+        current_working_set_ = new std::set<mirror::Object*>();
+        activity_ws_map_[current_activity_name_] = current_working_set_;
+    } else {
+        current_working_set_ = it->second;
+    }
+    activity_manager_lock_.ExclusiveUnlock(self);
+}
+
+
+void ActivityManager::ForgetWorkingSet() {
+    Thread* self = Thread::Current();
+    activity_manager_lock_.ExclusiveLock(self);
+    if (current_working_set_) {
+        current_working_set_->clear();
+    }
+    activity_manager_lock_.ExclusiveUnlock(self);
+}
+
+} // namespace jiacheng
+} // namespace art
\ No newline at end of file
diff --git a/runtime/jiacheng_activity_manager.h b/runtime/jiacheng_activity_manager.h
new file mode 100644
index 0000000000..cba767f77d
--- /dev/null
+++ b/runtime/jiacheng_activity_manager.h
@@ -0,0 +1,88 @@
+#ifndef JIACHENG_ACTIVITY_MANAGER_H_
+#define JIACHENG_ACTIVITY_MANAGER_H_
+
+#include <set>
+#include <map>
+#include <atomic>
+
+#include "base/mutex.h"
+
+namespace art {
+
+namespace mirror {
+    class Object;
+}
+
+namespace jiacheng {
+
+class ActivityManager {
+public:
+    ActivityManager();
+    ~ActivityManager();
+
+    static Mutex singleton_lock_;
+    static ActivityManager* activity_manager_; 
+
+    static ActivityManager* Create();
+    static ActivityManager* Current();
+
+    void JiachengDebug() const;
+
+    bool ShouldSwapOut(mirror::Object *obj);
+
+    void RecordWS(mirror::Object* obj);
+
+    void UpdateActivityState(const std::string& activity_name, int state);
+
+    /* 每次GC完成之后重新估计当前Activity的工作集 */
+    void ForgetWorkingSet();
+
+    bool GetSampling() const {
+        return sampling_.load();
+    }
+
+    void SetSampling(bool sampling) {
+        sampling_.store(sampling);
+    }
+
+    bool GetInGC() const {
+        return in_gc_.load();
+    }
+
+    void SetInGC(bool in_gc) {
+        in_gc_.store(in_gc);
+    }
+
+    size_t GetGCTime() const {
+        return gc_time_.load();
+    }
+
+    void IncGCTime() {
+        gc_time_.fetch_add(1);
+    }
+
+    // 用于保护current_working_set, activity_set, current_activity_name
+    Mutex activity_manager_lock_; 
+
+    // 当前Activity使用工作集的缓存指针，从而不需要每次都从map中查找
+    std::set<mirror::Object*>* current_working_set_;
+
+    // 保存当前的用户看到的Activity名
+    std::string current_activity_name_;
+
+    // 保存了ActivityName : WorkingSet 的映射
+    std::map<std::string, std::set<mirror::Object*> *> activity_ws_map_; 
+
+    std::atomic<bool> sampling_;
+
+    // 每次GC开始的时候设置为true, GC结束的时候设置为false
+    std::atomic<bool> in_gc_;
+
+    // GC发生的次数
+    std::atomic<size_t> gc_time_;
+};
+
+}
+}
+
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_cheatsheet.cc b/runtime/jiacheng_cheatsheet.cc
new file mode 100644
index 0000000000..eb0d51034d
--- /dev/null
+++ b/runtime/jiacheng_cheatsheet.cc
@@ -0,0 +1,26 @@
+#include "jiacheng_cheatsheet.h"
+
+
+namespace art {
+namespace jiacheng {
+
+
+void CheatSheet::AddRememberedSet(uint8_t *obj) {
+    remembered_set_.insert(obj);
+}
+
+void CheatSheet::AddColdSet(uint8_t *obj) {
+    cold_set_.insert(obj);
+}
+
+bool CheatSheet::InRememberedSet(uint8_t *obj) {
+    return remembered_set_.find(obj) != remembered_set_.end();
+}
+
+bool CheatSheet::InColdSet(uint8_t *obj) {
+    return cold_set_.find(obj) != cold_set_.end();
+}
+
+
+}
+}
\ No newline at end of file
diff --git a/runtime/jiacheng_cheatsheet.h b/runtime/jiacheng_cheatsheet.h
new file mode 100644
index 0000000000..7ce875dbb9
--- /dev/null
+++ b/runtime/jiacheng_cheatsheet.h
@@ -0,0 +1,28 @@
+#ifndef JIACHENG_CHEATSHEET_H_
+#define JIACHENG_CHEATSHEET_H_
+
+#include <set>
+
+namespace art {
+namespace jiacheng {
+
+class CheatSheet {
+public:
+    CheatSheet();
+    ~CheatSheet();
+
+    void AddRememberedSet(uint8_t *obj);
+    void AddColdSet(uint8_t *obj);
+
+    bool InRememberedSet(uint8_t *obj);
+    bool InColdSet(uint8_t * obj);
+
+    std::set<uint8_t*> remembered_set_;
+    std::set<uint8_t*> cold_set_;
+    std::set<uint8_t*> hot_set_;
+};
+
+}
+}
+
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_cold_space.cc b/runtime/jiacheng_cold_space.cc
new file mode 100644
index 0000000000..e224d03925
--- /dev/null
+++ b/runtime/jiacheng_cold_space.cc
@@ -0,0 +1,171 @@
+#include <fstream>
+#include <thread>
+#include <chrono>
+#include <atomic>
+#include <sys/mman.h>
+
+#include "base/mem_map.h"
+#include "gc/space/region_space.h"
+#include "base/mutex.h"
+#include "thread_list.h"
+#include "thread-current-inl.h"
+
+#include "jiacheng_hack.h"
+#include "jiacheng_cold_space.h"
+#include "jiacheng_region.h"
+
+
+namespace art{
+namespace jiacheng {
+
+Mutex ColdSpace::singleton_lock_("Cold Space Singleton Lock", kLoggingLock);
+
+ColdSpace* ColdSpace::cold_space_ = nullptr;
+
+ColdSpace::ColdSpace(MemMap* mem_map):
+    region_lock_("Cold Space Lock", kLoggingLock),
+    mem_map_(mem_map),
+    begin_(mem_map->Begin()),
+    end_(mem_map->End()),
+    num_regions_(mem_map->Size() / kRegionSize),
+    top_region_idx_(0U),
+    current_region_(nullptr),
+    madvice_top_region_idx_(0),
+    allocated_obj_num_(0),
+    mark_bitmap_(),
+    remembered_set_(),
+    remembered_root_stack_() {
+    
+    regions_.reset(new Region[num_regions_]);
+    uint8_t* region_addr = mem_map->Begin();
+    for (size_t i = 0; i < num_regions_; ++i, region_addr += kRegionSize) {
+        regions_[i].Init(i, region_addr, region_addr + kRegionSize);
+    }
+    current_region_ = &regions_[top_region_idx_++];
+
+}
+
+ColdSpace::~ColdSpace() {}
+
+ColdSpace* ColdSpace::Current() {
+    if (cold_space_ == nullptr) {
+        Thread* self = Thread::Current();
+        singleton_lock_.ExclusiveLock(self);
+        if (cold_space_ == nullptr) {
+            cold_space_ = Create();
+        }
+        singleton_lock_.ExclusiveUnlock(self);
+    }
+    return cold_space_;
+}
+
+
+ColdSpace* ColdSpace::Create() {
+    std::string error_msg;
+    MemMap mem_map = MemMap::MapAnonymous("Cold Space",
+                                            nullptr,
+                                            kCapacitySize + kRegionSize,
+                                            PROT_READ | PROT_WRITE,
+                                            true,
+                                            false,
+                                            nullptr,
+                                            &error_msg);
+
+    // if (!mem_map) {
+    //     LOG(INFO) << "jiacheng jiacheng_cold_space.cc 46 mem_map=nullptr error_msg= " << error_msg; 
+    // }
+    return new ColdSpace(&mem_map);
+}
+
+void ColdSpace::JiachengDebug() {
+    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "mem_map_= " << size_t(mem_map_); 
+    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "num_regions_= " << num_regions_; 
+    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "top_region_idx_= " << top_region_idx_; 
+    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "current_region_= " << current_region_; 
+    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "allocated_obj_num_= " << allocated_obj_num_.load(); 
+}
+
+
+mirror::Object* ColdSpace::Alloc(size_t num_bytes) {
+    num_bytes = RoundUp(num_bytes, kAlignment);
+    mirror::Object* obj;
+    obj = current_region_->Alloc(num_bytes);
+    if (obj != nullptr) {
+        allocated_obj_num_.fetch_add(1);
+        return obj;
+    }
+    Region* r = AllocateRegion();
+    if (r == nullptr) {
+        LOG(INFO) << "jiacheng jiacheng_cold_space.cc 83 AllocateRegion() ColdSpace已满!";
+        return nullptr;
+    }
+    current_region_ = r;
+    obj = current_region_->Alloc(num_bytes);
+    if (obj != nullptr) {
+        allocated_obj_num_.fetch_add(1);
+    }
+    return obj;
+}
+
+Region* ColdSpace::AllocateRegion() {
+    if (top_region_idx_ >= num_regions_) {
+        return nullptr;
+    }
+    return &regions_[top_region_idx_++];
+}
+
+void ColdSpace::SwapOut() {
+    // if (madvice_top_region_idx_ < top_region_idx_ - 1) { // 把Current之前的Region进行Swap
+    //     uint8_t* begin = regions_[madvice_top_region_idx_].Begin();
+    //     uint8_t* end = regions_[top_region_idx_ - 2].End();
+    //     LOG(INFO) << "jiacheng jiacheng_cold_space.cc 111 begin= " << size_t(begin) << " end= " << size_t(end) 
+    //               << " madvice_top_region_idx_= " << madvice_top_region_idx_
+    //               << " top_region_idx_= " << top_region_idx_;
+    //     madvise(begin, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(begin) - 1, 233);
+    //     madvice_top_region_idx_ = top_region_idx_ - 1;
+    // }
+    if (0 < top_region_idx_ - 1) { // 把Current之前的Region进行Swap
+        uint8_t* begin = regions_[0].Begin();
+        uint8_t* end = regions_[top_region_idx_ - 2].End();
+        LOG(INFO) << "jiacheng jiacheng_cold_space.cc 111 begin= " << size_t(begin) << " end= " << size_t(end) 
+                  << " madvice_top_region_idx_= " << madvice_top_region_idx_
+                  << " top_region_idx_= " << top_region_idx_;
+        madvise(begin, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(begin) - 1, 233);
+        // madvice_top_region_idx_ = top_region_idx_ - 1;
+    }
+}
+
+bool ColdSpace::HasAddress(mirror::Object* obj) const {
+    const uint8_t* byte_ptr = reinterpret_cast<const uint8_t*>(obj);
+    return byte_ptr >= Begin() && byte_ptr < End();
+}
+
+bool ColdSpace::GetMarkBitmap(mirror::Object* to_ref) {
+    return mark_bitmap_.find(to_ref) != remembered_set_.end();
+}
+
+void ColdSpace::SetMarkBitmap(mirror::Object* to_ref) {
+    mark_bitmap_.insert(to_ref);
+}
+
+void ColdSpace::ResetMarkBitmap() {
+    mark_bitmap_.clear();
+}
+
+void ColdSpace::AddRememberedSet(mirror::Object* obj) {
+    remembered_set_.insert(obj);
+}
+
+// 把Obj对象中包含的所有引用加入的根集
+void ColdSpace::AddRememberedRootSet(mirror::Object* obj) {
+    remembered_root_stack_.push_back(obj);
+}
+
+// 得到GC之前的根集合
+std::vector<mirror::Object*>* ColdSpace::GetRememberedRootStack() {
+    return &(remembered_root_stack_);
+}
+
+
+} // namespace jiacheng
+} // namespace art
diff --git a/runtime/jiacheng_cold_space.h b/runtime/jiacheng_cold_space.h
new file mode 100644
index 0000000000..46e8242bcb
--- /dev/null
+++ b/runtime/jiacheng_cold_space.h
@@ -0,0 +1,103 @@
+#ifndef JIACHENG_COLD_SPACE_H_
+#define JIACHENG_COLD_SPACE_H_
+
+#include <atomic>
+#include "base/mutex.h"
+
+namespace art{
+
+namespace mirror {
+class Object;
+}  // namespace mirror
+
+class MemMap;
+
+// ------------ START -------------
+namespace jiacheng {
+
+class Region;
+
+class ColdSpace {
+public: 
+  ColdSpace(MemMap* mem_map);
+  ~ColdSpace();
+
+  static Mutex singleton_lock_;
+  static ColdSpace* cold_space_; 
+
+  static ColdSpace* Create();
+  static ColdSpace* Current();
+
+  void JiachengDebug();
+
+  mirror::Object* Alloc(size_t num_bytes);
+
+  Region* AllocateRegion();
+
+  void SwapOut();
+
+  bool HasAddress(mirror::Object* obj) const;
+
+  bool GetMarkBitmap(mirror::Object* to_ref);
+
+  void SetMarkBitmap(mirror::Object* to_ref);
+
+  void ResetMarkBitmap();
+
+  void AddRememberedSet(mirror::Object* obj);
+
+  void AddRememberedRootSet(mirror::Object* obj);
+
+  std::vector<mirror::Object*>* GetRememberedRootStack();
+
+  uint8_t* Begin() const {
+    return begin_;
+  }
+
+  uint8_t* End() const {
+    return end_;
+  }
+
+  size_t GetAllocatedObjNum() const {
+    return allocated_obj_num_.load();
+  }
+
+
+  // ---------------- 变量开始 ----------------------
+  // Object alignment within the space.
+  static constexpr size_t kAlignment = kObjectAlignment;
+  // The region size.
+  static constexpr size_t kRegionSize = 4 * KB;
+  // The capacity size.
+  static constexpr size_t kCapacitySize = kRegionSize * 1024 * 100; // 400MB
+
+  Mutex region_lock_;
+
+  MemMap* mem_map_;
+
+  uint8_t* begin_;
+  uint8_t* end_;
+
+  std::unique_ptr<Region[]> regions_;
+
+  size_t num_regions_;             
+
+  size_t top_region_idx_;
+
+  Region* current_region_;         
+
+  size_t madvice_top_region_idx_;
+
+  std::atomic<size_t> allocated_obj_num_;
+
+  std::set<mirror::Object*> mark_bitmap_;
+
+  std::set<mirror::Object*> remembered_set_;
+
+  std::vector<mirror::Object*> remembered_root_stack_;
+};
+
+
+} // namespace jiacheng
+} // namespace art
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_hack.cc b/runtime/jiacheng_hack.cc
new file mode 100644
index 0000000000..f44515e7f0
--- /dev/null
+++ b/runtime/jiacheng_hack.cc
@@ -0,0 +1,594 @@
+#include <fstream>
+#include <thread>
+#include <chrono>
+#include <atomic>
+#include <sys/mman.h>
+#include <string>
+
+#include "jiacheng_hack.h"
+#include "jiacheng_cold_space.h"
+#include "jiacheng_activity_manager.h"
+
+#include "gc/accounting/card_table.h"
+#include "gc/space/space-inl.h"
+#include "gc/heap.h"
+#include "gc/space/zygote_space.h"
+#include "gc/space/bump_pointer_space-inl.h"
+#include "gc/space/bump_pointer_space-walk-inl.h"
+#include "gc/space/dlmalloc_space-inl.h"
+#include "gc/space/image_space.h"
+#include "gc/space/large_object_space.h"
+#include "gc/space/malloc_space.h"
+#include "gc/space/region_space-inl.h"
+#include "gc/space/rosalloc_space-inl.h"
+#include "mirror/class-inl.h"
+#include "obj_ptr-inl.h"
+#include "scoped_thread_state_change-inl.h"
+#include "thread_list.h"
+#include "gc/accounting/mod_union_table-inl.h"
+#include "gc/accounting/remembered_set.h"
+#include "base/mutex.h"
+
+#include "read_barrier_config.h"
+
+namespace art{
+namespace jiacheng {
+
+static std::set<mirror::Object*> read_set;
+static Mutex read_set_lock("read_set_lock", kLoggingLock);
+
+static std::set<mirror::Object*> gc_set;
+static Mutex gc_set_lock("gc_set_lock", kLoggingLock);
+
+void Debug() {
+    ColdSpace::Current()->JiachengDebug();
+    ActivityManager::Current()->JiachengDebug();
+
+    Runtime* runtime = Runtime::Current();
+    gc::Heap* heap = runtime->GetHeap();
+
+    heap->JiachengDebug();
+}
+
+
+/*
+ * 每次GC开始的时候，调用该方法
+ */
+void BeforeGarbageCollectorRun(const gc::collector::GarbageCollector* collector) {
+    LOG(INFO) << "jiacheng" << " BeforeGarbageCollectorRun" 
+              << " NanoTime: " << NanoTime()
+              << " GarbageCollector.name_ " << collector->GetName()
+              << " GetGcType()" << collector->GetGcType();
+
+    ActivityManager* activity_manager = ActivityManager::Current();
+    activity_manager->SetSampling(false);
+    activity_manager->SetInGC(true);
+
+    Thread* self = Thread::Current();
+    read_set_lock.ExclusiveLock(self);
+    LOG(INFO) << "jiacheng " << __FILE__ << __LINE__
+              << " read_set.size()= " << read_set.size();
+    read_set_lock.ExclusiveUnlock(self);
+    
+    read_set_lock.ExclusiveLock(self);
+    read_set.clear();
+    read_set_lock.ExclusiveUnlock(self);
+    gc_set_lock.ExclusiveLock(self);
+    gc_set.clear();
+    gc_set_lock.ExclusiveUnlock(self);
+}
+
+/*
+ * 每次GC结束的时候，调用该方法
+ */
+void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector) {
+    // ActivityManager* activity_manager = ActivityManager::Current();
+    // activity_manager->SetSampling(true);
+    // activity_manager->SetInGC(false);
+    // activity_manager->IncGCTime();
+
+    // Debug();
+    // SwapOut();
+    // activity_manager->ForgetWorkingSet();
+    // ColdSpace::Current()->ResetMarkBitmap();
+    const gc::collector::Iteration* iteration = collector->GetCurrentIteration();
+    
+    LOG(INFO) << "jiacheng" << " AfterGarbageCollectorRun" 
+              << " NanoTime: " << NanoTime()
+              << " GcCause: " << iteration->GetGcCause()
+              << " GetGcType()" << collector->GetGcType();  
+
+    Thread* self = Thread::Current();
+    gc_set_lock.ExclusiveLock(self);
+    LOG(INFO) << "jiacheng " << __FILE__ << __LINE__
+              << " gc_set.size()= " << gc_set.size();
+    gc_set_lock.ExclusiveUnlock(self);
+
+    read_set_lock.ExclusiveLock(self);
+    read_set.clear();
+    read_set_lock.ExclusiveUnlock(self);
+    gc_set_lock.ExclusiveLock(self);
+    gc_set.clear();
+    gc_set_lock.ExclusiveUnlock(self);
+}
+
+/*
+ * 每次发生读屏障的时候，调用该方法
+ */
+
+void ReaderBarrierTrigger(mirror::Object* obj) {
+    // (void)obj;
+    if (Runtime::Current()->IsZygote()) {
+        return;
+    }
+    // if (!Runtime::Current()->InJankPerceptibleProcessState()) {
+    //     return;
+    // }
+    Thread* self = Thread::Current();
+
+    read_set_lock.ExclusiveLock(self);
+    read_set.insert(obj);
+    read_set_lock.ExclusiveUnlock(self);
+
+//     // com.jiacheng.activitylifecycletest = 34
+//     // com.taobao.taobao = 17
+    // const std::string& package_name = Runtime::Current()->GetProcessPackageName();
+    // if (!(package_name.length() == 17 && package_name[4] == 't')) { 
+    //     return;
+    // }
+    // ActivityManager::Current()->RecordWS(obj);
+
+//     LOG(INFO) << "jiacheng ReaderBarrierTrigger "
+//               << "obj= " << reinterpret_cast<size_t>(obj) << ' '
+//               << "offset= " << reinterpret_cast<size_t>(offset) << ' '
+//               << "ref= " << reinterpret_cast<size_t>(ref_addr) << ' '
+//               << "GetProcessPackageName= " << Runtime::Current()->GetProcessPackageName() << ' ';
+
+}
+
+void GCMarkTrigger(mirror::Object* obj) {
+    if (Runtime::Current()->IsZygote()) {
+        return;
+    }
+    Thread* self = Thread::Current();
+
+    gc_set_lock.ExclusiveLock(self);
+    gc_set.insert(obj);
+    gc_set_lock.ExclusiveUnlock(self);
+}
+
+
+
+/* 
+ * AMS通过在系统启动的时候注册的service调用该函数
+ * enum ActivityState {
+ *     INITIALIZING, 0
+ *     RESUMED, 1
+ *     PAUSING, 2
+ *     PAUSED, 3 
+ *     STOPPING, 4
+ *     STOPPED, 5
+ *     FINISHING, 6
+ *     DESTROYING, 7
+ *     DESTROYED 8
+ *}
+ */
+void UpdateActivityState(const char* package_name, const char* activity_name, int state) { 
+    (void)package_name;
+    std::string name(activity_name);
+    ActivityManager::Current()->UpdateActivityState(name, state);
+}
+
+/*
+ * 在App启动的main函数中调用该函数
+ */
+void OnAppStart() {
+    LOG(INFO) << "jiacheng jiacheng_hack.cc 127 OnAppStart()";
+    // auto func = []()->void {
+    //     ActivityManager* activity_manager = ActivityManager::Current();
+    //     for (;;) {
+    //         if (!activity_manager->GetInGC()) {
+    //             SwapOut();
+    //             LOG(INFO) << "jiacheng jiacheng_hack.cc 144 执行换出!";
+    //         }
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //     }
+    // };
+    // std::thread on_app_start_thread(func);
+    // on_app_start_thread.detach();
+}
+
+// 对ColdSpace中的Region进行Swap
+void SwapOut() {
+    if (Runtime::Current()->IsZygote()) {
+        return;
+    }
+    // if (activity_set.size() < 2 || GC_time.load() < 10) {
+    //     return;
+    // }
+    if (Runtime::Current()->InJankPerceptibleProcessState()) {
+        return;
+    }
+    // com.jiacheng.activitylifecycletest = 34
+    // com.taobao.taobao = 17
+    // const std::string& package_name = Runtime::Current()->GetProcessPackageName();
+    // if (!(package_name.length() == 17 && package_name[4] == 't')) { 
+    //     return;
+    // }
+
+    // 对所有Space中的对象进行Swap
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    Thread* self = Thread::Current();
+    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
+    {
+        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
+        continues_spaces = &(heap->GetContinuousSpaces());
+    }
+    for (auto space : *continues_spaces) {
+        LOG(INFO) << "jiacheng_hack.cc 185 SwapOut() continues_spaces " << space->GetName();
+        madvise(space->Begin(), space->Size(), 233);
+        // SwapOutSpace(space);
+    }
+    const std::vector<gc::space::DiscontinuousSpace*>& discontinues_spaces = heap->GetDiscontinuousSpaces();
+    for (auto space : discontinues_spaces) {
+        SwapOutSpace(space);
+    }    
+
+    // 不直接使用SwapOutSpace()函数对所有Space中的对象进行Swap
+    // LOG(INFO) << "jiacheng jiacheng_hack.cc 180 SwapOut()";
+    // ColdSpace* cold_space = ColdSpace::Current();
+    // cold_space->SwapOut();
+}
+
+
+void CurrentThreadSleepNano(const unsigned long n) {
+    std::this_thread::sleep_for(std::chrono::nanoseconds(n));
+}
+
+// 防止某个操作过于频繁
+bool CheckHot() {
+    static std::atomic<uint64_t> last_time(0);
+    uint64_t get_last_time = last_time.load();
+    uint64_t this_time = art::NanoTime();
+    if (this_time - get_last_time < 5000000000) {
+        return true;
+    } else {
+        last_time.store(this_time);
+        return false;
+    }
+}
+
+void SwapOutSpace(gc::space::Space* space) {
+    Thread* self = Thread::Current();
+    gc::space::SpaceType space_type = space->GetType();
+    WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* ) {
+        // if (start != end && ActivityManager::Current()->ShouldSwapOut(reinterpret_cast<mirror::Object*>(start))) {
+        if (start != end) {
+            LOG(INFO) << "jiacheng_hack.cc 143 ShouldSwapOut() obj= " << size_t(start) << " size= " << size_t(end) - size_t(start);
+            madvise(start, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start), 233);
+        }
+    };    
+    auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_){
+        // if (obj && ActivityManager::Current()->ShouldSwapOut(obj)) {
+        if (obj) {
+            LOG(INFO) << "jiacheng_hack.cc 150 ShouldSwapOut() obj= " << size_t(obj) << " size= " << obj->SizeOf();
+            madvise(static_cast<void *>(obj), obj->SizeOf(), 233);
+        }
+    };
+    switch (space_type) {
+        case gc::space::kSpaceTypeImageSpace: {
+            // gc::space::ImageSpace* this_space = space->AsImageSpace();
+            break;
+        }
+        case gc::space::kSpaceTypeMallocSpace: {
+            gc::space::MallocSpace* this_space = space->AsMallocSpace();
+            this_space->Walk(walk_callback, nullptr);
+            break;
+        }
+        case gc::space::kSpaceTypeZygoteSpace: {
+            // gc::space::ZygoteSpace* this_space = space->AsZygoteSpace();
+            break;
+        }
+        case gc::space::kSpaceTypeBumpPointerSpace: {
+            gc::space::BumpPointerSpace* this_space = space->AsBumpPointerSpace();
+            { 
+                WriterMutexLock mu(self, *Locks::mutator_lock_);  
+                this_space -> Walk(visitor);
+            }
+            break;
+        }
+        case gc::space::kSpaceTypeLargeObjectSpace: {
+            gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
+            this_space->Walk(walk_callback, nullptr);
+            break;
+        }
+        case gc::space::kSpaceTypeRegionSpace: {
+            gc::space::RegionSpace* this_space = space->AsRegionSpace();   
+            {
+                WriterMutexLock mu(self, *Locks::mutator_lock_);  
+                this_space -> Walk(visitor);
+            }
+            break;
+        }
+        default:
+            LOG(INFO) << "jiacheng " << "jiacheng_hack.cc 100. Can not find space.";
+    }
+}
+
+// ------------------- static ---------------------
+
+void PrintProcStat() {
+    static std::ifstream stat;
+    static std::string line;
+    stat.open("/proc/stat");
+    if (!stat.is_open()) {
+        LOG(INFO) << "jiacheng" << " /proc/stat can not open!";
+    } else {
+        while(getline(stat, line)) {
+            LOG(INFO) << "jiacheng " << line;
+        }
+        stat.close();
+    }
+
+}
+
+void PrintProcStat(const char* info) {
+    static std::ifstream stat;
+    static std::string line;
+    stat.open("/proc/stat");
+    if (!stat.is_open()) {
+        LOG(INFO) << "jiacheng" << " /proc/stat can not open!";
+    } else {
+        while(getline(stat, line)) {
+            LOG(INFO) << "jiacheng " << info << ' ' << line;
+        }
+        stat.close();
+    }
+}
+
+bool ExistSwap() {
+    static bool exist;
+    static std::ifstream stat;
+    static std::string line;
+    int line_number = 0;
+    if (exist) {
+        return true;
+    }
+    stat.open("/proc/swaps");
+    if (!stat.is_open()) {
+        LOG(INFO) << "jiacheng" << " /proc/swaps can not open!";
+    } else {
+        while(getline(stat, line)) {
+            line_number++;
+            if (line_number > 1) {
+                exist = true;
+                break;
+            }
+        }
+        stat.close();
+    }
+    return exist;
+}
+
+void VisitSpace(gc::space::Space* space) {
+    gc::space::SpaceType space_type = space->GetType();
+    Thread* self = Thread::Current();
+    WalkCallback walk_callback = [](void *start, void *end, size_t num_bytes, void* ) {
+        LOG(INFO) << "jiacheng " << "start= " << start << ' ' << "end= " << end << ' ' << "num_bytes= " << num_bytes;
+    };    
+    auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_){
+        if (!obj) {
+            LOG(INFO) << "jiacheng Object=Null";
+            return; 
+        }
+        LOG(INFO) << "jiacheng Object= " << obj << " Size= " << obj->SizeOf() << " Type= " << obj->PrettyTypeOf();
+    };
+    switch (space_type) {
+        case gc::space::kSpaceTypeImageSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "ImageSpace: ";
+            gc::space::ImageSpace* this_space = space->AsImageSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            break;
+        }
+        case gc::space::kSpaceTypeMallocSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "MallocSpace: ";
+            gc::space::MallocSpace* this_space = space->AsMallocSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            this_space->Walk(walk_callback, nullptr);
+            break;
+        }
+        case gc::space::kSpaceTypeZygoteSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "ZygoteSpace: ";
+            gc::space::ZygoteSpace* this_space = space->AsZygoteSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            break;
+        }
+        case gc::space::kSpaceTypeBumpPointerSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "BumpPointerSpace: ";
+            gc::space::BumpPointerSpace* this_space = space->AsBumpPointerSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            {
+                ReaderMutexLock mu(self, *Locks::mutator_lock_);   
+                this_space->Walk(visitor);
+            }
+            break;
+        }
+        case gc::space::kSpaceTypeLargeObjectSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "LargeObjectSpace: ";
+            gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            this_space->Walk(walk_callback, nullptr);
+            break;
+        }
+        case gc::space::kSpaceTypeRegionSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "RegionSpace: ";
+            gc::space::RegionSpace* this_space = space->AsRegionSpace();   
+            this_space->Dump(LOG_STREAM(INFO));
+            {
+                WriterMutexLock mu(self, *Locks::mutator_lock_);           
+                this_space->Walk(visitor);
+            }
+            break;
+        }
+        default:
+            LOG(INFO) << "jiacheng " << "jiacheng_hack.cc 100. Can not find space.";
+    }
+}
+
+void VisitHeap(const gc::Heap* heap) {
+    Thread* self = Thread::Current();
+    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
+    {
+        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
+        continues_spaces = &(heap->GetContinuousSpaces());
+    }
+    for (auto space : *continues_spaces) {
+        VisitSpace(space);
+    }
+    const std::vector<gc::space::DiscontinuousSpace*>& discontinues_spaces = heap->GetDiscontinuousSpaces();
+    for (auto space : discontinues_spaces) {
+        VisitSpace(space);
+    }    
+}
+
+
+void VisitMemMap(const MemMap* mem_map) {
+    LOG(INFO) << "jiacheng VisitMemMap ";
+    LOG(INFO) << (*mem_map);
+    uint8_t* begin = mem_map->Begin();
+    uint8_t* end = mem_map->End();
+    void* base_begin = mem_map->BaseBegin();
+    void* base_end = mem_map->BaseEnd();
+    LOG(INFO) << "begin= " << reinterpret_cast<size_t>(begin) << ' '
+              << "end= " << reinterpret_cast<size_t>(end) << ' '
+              << "base_begin= " << reinterpret_cast<size_t>(base_begin) << ' '
+              << "base_end= " << reinterpret_cast<size_t>(base_end);
+    // print every byte
+    // for(uint8_t* p = begin; p != end; ++p) {
+    //     LOG(INFO) << static_cast<int>(*p);
+    // }
+
+}
+
+template<size_t kAlignment>
+void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* ) {
+}
+
+void VisitHeapBitmap(const gc::accounting::HeapBitmap* ) {
+}
+
+void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set) {
+    LOG(INFO) << "jiacheng VisitRememberedSet ";
+    auto table = const_cast<gc::accounting::RememberedSet*>(remembered_set);
+    {
+        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
+        table->Dump(LOG_STREAM(INFO));
+    }
+
+}
+
+void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table) {
+    LOG(INFO) << "jiacheng VisitModUnionTableToZygoteAllocspace ";
+    auto table = const_cast<gc::accounting::ModUnionTableToZygoteAllocspace*>(static_cast<const gc::accounting::ModUnionTableToZygoteAllocspace*>(mod_union_table));
+    {
+        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
+        table->Dump(LOG_STREAM(INFO));
+    }
+}
+
+void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table) {
+    LOG(INFO) << "jiacheng VisitModUnionTableCardCache ";
+    auto table = const_cast<gc::accounting::ModUnionTableCardCache*>(static_cast<const gc::accounting::ModUnionTableCardCache*>(mod_union_table));
+    {
+        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
+        table->Dump(LOG_STREAM(INFO));
+    }
+}
+
+void VisitCardTable(const gc::accounting::CardTable* card_table) {
+    (void)card_table;
+    LOG(INFO) << "jiacheng VisitCardTable ";
+    // MemMap* mem_map = &(card_table->mem_map_);
+    // uint8_t* const biased_begin = card_table->biased_begin_;
+    // const size_t offset = card_table->offset_;
+
+    // VisitMemMap(mem_map);
+    // LOG(INFO) << "biased_begin= " << reinterpret_cast<size_t>(biased_begin);
+    // LOG(INFO) << "offset= " << offset;
+}
+
+void DebugPrintModUnionAndRememberSet() {
+    if (Runtime::Current()->IsZygote()) {
+        return;
+    }
+    if (!Runtime::Current()->InJankPerceptibleProcessState()) {
+      LOG(INFO) << "jiacheng " << "InJankPerceptibleProcessState" ;
+      return;
+    }
+    // if (jiacheng::CheckHot()) {
+    //   LOG(INFO) << "jiacheng " << "CheckHot";
+    //   return;
+    // }  
+    if (!jiacheng::ExistSwap()) {
+      return;
+    }
+
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    VisitHeap(heap);
+
+    Thread* self = Thread::Current();
+    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
+    {
+        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
+        continues_spaces = &(heap->GetContinuousSpaces());
+    }
+    for (auto space : *continues_spaces) {
+        LOG(INFO) << space->GetName();
+        gc::space::SpaceType space_type = space->GetType();
+        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
+        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
+        if (mod_union_table) {
+            LOG(INFO) << "jiacheng mod_union_table";
+            if (space_type == gc::space::kSpaceTypeZygoteSpace) {
+                VisitModUnionTableCardCache(mod_union_table);
+            } else if (space_type == gc::space::kSpaceTypeImageSpace) {
+                VisitModUnionTableToZygoteAllocspace(mod_union_table);
+            }
+        } 
+        if (remembered_set) {
+            LOG(INFO) << "jiacheng remembered_set";
+            VisitRememberedSet(remembered_set);
+        }
+        if (mod_union_table == nullptr && remembered_set == nullptr) {
+            LOG(INFO) << "nullptr";
+        }
+    }
+    const std::vector<gc::space::DiscontinuousSpace*>* discontinues_spaces = &(heap->GetDiscontinuousSpaces());
+    for (auto space : *discontinues_spaces) {
+        LOG(INFO) << space->GetName();
+        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
+        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
+        if (mod_union_table) {
+            LOG(INFO) << "jiacheng mod_union_table";
+        } 
+        if (remembered_set) {
+            LOG(INFO) << "jiacheng remembered_set";
+        }
+        if (mod_union_table == nullptr && remembered_set == nullptr) {
+            LOG(INFO) << "nullptr";
+        }
+    }
+}
+
+} // namespace jiacheng
+} // namespace art
diff --git a/runtime/jiacheng_hack.h b/runtime/jiacheng_hack.h
new file mode 100644
index 0000000000..76ec57dd47
--- /dev/null
+++ b/runtime/jiacheng_hack.h
@@ -0,0 +1,104 @@
+#ifndef JIACHENG_HACK_H_
+#define JIACHENG_HACK_H_
+
+#include <set>
+
+namespace art{
+
+namespace gc {
+namespace accounting {
+template<size_t kAlignment> class SpaceBitmap;
+class HeapBitmap;
+class RememberedSet;
+class ModUnionTable;
+class CardTable;
+} // namespace accounting
+
+namespace space {
+class Space;
+class ImageSpace;
+class MallocSpace;
+class ZygoteSpace;
+class BumpPointerSpace;
+class LargeObjectSpace;
+class RegionSpace;
+} // namespace space
+
+namespace collector {
+class GarbageCollector;
+} // namespace collector
+
+class Heap;
+
+} // namespace gc
+
+namespace mirror {
+class Class;
+class Object;
+template<class T> class ObjectArray;
+}  // namespace mirror
+
+class Thread;
+class MemMap;
+class MemberOffset;
+
+// ------------ START -------------
+namespace jiacheng {
+
+typedef void(*WalkCallback)(void *start, void *end, size_t num_bytes, void* callback_arg);
+
+void Debug();
+
+void BeforeGarbageCollectorRun(const gc::collector::GarbageCollector* collector);
+
+void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector);
+
+void ReaderBarrierTrigger(mirror::Object* obj);
+
+void GCMarkTrigger(mirror::Object* obj);
+
+void UpdateActivityState(const char* package_name, const char* activity_name, int state);
+
+void OnAppStart();
+
+void SwapOut();
+
+void CurrentThreadSleepNano(const unsigned long n);
+
+bool CheckHot();
+
+void SwapOutSpace(gc::space::Space* space);
+
+// -------------- DEGUB ----------
+
+void PrintProcStat();
+
+void PrintProcStat(const char* info);
+
+bool ExistSwap();
+
+void VisitSpace(gc::space::Space* space);
+
+void VisitHeap(const gc::Heap* heap);
+
+void VisitMemMap(const MemMap* mem_map);
+
+template<size_t kAlignment>
+void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* );
+
+void VisitHeapBitmap(const gc::accounting::HeapBitmap* );
+
+void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set);
+
+void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table);
+
+void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table);
+
+void VisitCardTable(const gc::accounting::CardTable* card_table);
+
+void DebugPrintModUnionAndRememberSet();
+
+
+} // namespace jiacheng
+} // namespace art
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_region.cc b/runtime/jiacheng_region.cc
new file mode 100644
index 0000000000..fd954565e8
--- /dev/null
+++ b/runtime/jiacheng_region.cc
@@ -0,0 +1,41 @@
+#include "jiacheng_region.h"
+
+namespace art {
+namespace jiacheng {
+
+Region::Region():idx_(-1),begin_(nullptr),top_(nullptr),end_(nullptr) {
+}
+
+Region::~Region() {}
+
+void Region::Init(size_t idx, uint8_t* begin, uint8_t* end) {
+    idx_ = idx;
+    begin_ = begin;
+    top_.store(begin);
+    end_ = end;
+}
+
+mirror::Object* Region::Alloc(size_t num_bytes) {
+    uint8_t* old_top;
+    uint8_t* new_top;
+
+    old_top = top_.load();
+    new_top = old_top + num_bytes;
+    if (new_top > end_) {
+        return nullptr;
+    }
+    top_.store(new_top);
+    return reinterpret_cast<mirror::Object*>(old_top);
+}
+
+void Region::Clear() {
+    top_.store(begin_);
+}
+
+bool Region::IsFree() const {
+    return top_.load() == begin_;
+}
+
+
+} // namespace jiacheng
+} // namespace art
\ No newline at end of file
diff --git a/runtime/jiacheng_region.h b/runtime/jiacheng_region.h
new file mode 100644
index 0000000000..fedfb28994
--- /dev/null
+++ b/runtime/jiacheng_region.h
@@ -0,0 +1,59 @@
+#ifndef JIACHENG_REGION_H_
+#define JIACHENG_REGION_H_
+
+#include <atomic>
+
+namespace art{
+namespace mirror {
+    class Object;
+}
+
+// ------------ START -------------
+namespace jiacheng {
+
+class Region {
+public:
+    Region();
+    ~Region();
+
+    void Init(size_t idx, uint8_t* begin, uint8_t* end);
+
+    mirror::Object* Alloc(size_t num_bytes);
+
+    void Clear();
+
+    bool IsFree() const;
+
+    size_t Idx() const {
+        return idx_;
+    }
+
+    uint8_t* Begin() const {
+        return begin_;
+    }
+
+    uint8_t* Top() const {
+        return top_.load();
+    }
+
+    uint8_t* End() const {
+        return end_;
+    }
+
+    bool Contains(mirror::Object* ref) const {
+        return begin_ <= reinterpret_cast<uint8_t*>(ref) && reinterpret_cast<uint8_t*>(ref) < end_;
+    }
+
+// ---------------- 变量开始 ----------------------
+
+    size_t idx_;                        // 该Region在ColdSpace中的索引
+    uint8_t* begin_;                    // 这个Region的起始地址
+    std::atomic<uint8_t*> top_;         // Allocation的位置
+    uint8_t* end_;                      // 这个Region的结束地址
+
+};
+
+
+} // namespace jiacheng
+} // namespace art
+#endif
\ No newline at end of file
diff --git a/runtime/native/dalvik_system_VMRuntime.cc b/runtime/native/dalvik_system_VMRuntime.cc
index 399813c60e..0557da0b16 100644
--- a/runtime/native/dalvik_system_VMRuntime.cc
+++ b/runtime/native/dalvik_system_VMRuntime.cc
@@ -62,6 +62,10 @@ extern "C" void android_set_application_target_sdk_version(uint32_t version);
 #include "thread_list.h"
 #include "well_known_classes.h"
 
+// jiacheng start
+#include "jiacheng_hack.h"
+// jiacheng end
+
 namespace art {
 
 using android::base::StringPrintf;
@@ -321,6 +325,25 @@ static void VMRuntime_updateProcessState(JNIEnv*, jobject, jint process_state) {
   runtime->UpdateProcessState(static_cast<ProcessState>(process_state));
 }
 
+// jiacheng start
+static void VMRuntime_jiachengUpdateActivityState(JNIEnv* env, jobject, 
+                                                  jstring package_name, 
+                                                  jstring activity_name, 
+                                                  jint state) {
+  (void)env;
+  (void)package_name;
+  (void)activity_name;
+  (void)state;
+  // const char* raw_package_name = env->GetStringUTFChars(package_name, nullptr);
+  // const char* raw_activity_name = env->GetStringUTFChars(activity_name, nullptr);
+  // jiacheng::UpdateActivityState(raw_package_name, raw_activity_name, static_cast<int>(state));
+}
+
+static void VMRuntime_jiachengAppStart(JNIEnv*, jobject) {
+  jiacheng::OnAppStart();
+}
+// jiacheng end
+
 static void VMRuntime_notifyStartupCompleted(JNIEnv*, jobject) {
   Runtime::Current()->NotifyStartupCompleted();
 }
@@ -754,6 +777,10 @@ static JNINativeMethod gMethods[] = {
   NATIVE_METHOD(VMRuntime, requestHeapTrim, "()V"),
   NATIVE_METHOD(VMRuntime, runHeapTasks, "()V"),
   NATIVE_METHOD(VMRuntime, updateProcessState, "(I)V"),
+  // jiacheng start
+  NATIVE_METHOD(VMRuntime, jiachengUpdateActivityState, "(Ljava/lang/String;Ljava/lang/String;I)V"),
+  NATIVE_METHOD(VMRuntime, jiachengAppStart, "()V"),
+  // jiacheng end
   NATIVE_METHOD(VMRuntime, startHeapTaskProcessor, "()V"),
   NATIVE_METHOD(VMRuntime, startJitCompilation, "()V"),
   NATIVE_METHOD(VMRuntime, stopHeapTaskProcessor, "()V"),
diff --git a/runtime/read_barrier-inl.h b/runtime/read_barrier-inl.h
index 1bcbcff08c..1649bbe70e 100644
--- a/runtime/read_barrier-inl.h
+++ b/runtime/read_barrier-inl.h
@@ -27,6 +27,10 @@
 #include "mirror/reference.h"
 #include "runtime.h"
 
+// jiacheng start
+#include "jiacheng_hack.h"
+// jiacheng end
+
 namespace art {
 
 // Disabled for performance reasons.
@@ -71,10 +75,18 @@ inline MirrorType* ReadBarrier::Barrier(
         }
       }
       AssertToSpaceInvariant(obj, offset, ref);
+      // jiacheng start
+      jiacheng::ReaderBarrierTrigger(ref);
+      // jiacheng end
       return ref;
     } else if (kUseBrooksReadBarrier) {
       // To be implemented.
-      return ref_addr->template AsMirrorPtr<kIsVolatile>();
+      // jiacheng start
+      MirrorType* ref = ref_addr->template AsMirrorPtr<kIsVolatile>();
+      // return ref_addr->template AsMirrorPtr<kIsVolatile>();
+      jiacheng::ReaderBarrierTrigger(ref);
+      return ref;
+      // jiacheng end
     } else if (kUseTableLookupReadBarrier) {
       MirrorType* ref = ref_addr->template AsMirrorPtr<kIsVolatile>();
       MirrorType* old_ref = ref;
@@ -92,6 +104,9 @@ inline MirrorType* ReadBarrier::Barrier(
         }
       }
       AssertToSpaceInvariant(obj, offset, ref);
+      // jiacheng start
+      jiacheng::ReaderBarrierTrigger(ref);
+      // jiacheng end
       return ref;
     } else {
       LOG(FATAL) << "Unexpected read barrier type";
@@ -99,7 +114,12 @@ inline MirrorType* ReadBarrier::Barrier(
     }
   } else {
     // No read barrier.
-    return ref_addr->template AsMirrorPtr<kIsVolatile>();
+    // jiacheng start
+    // return ref_addr->template AsMirrorPtr<kIsVolatile>();
+    MirrorType* ref = ref_addr->template AsMirrorPtr<kIsVolatile>();
+    jiacheng::ReaderBarrierTrigger(ref);
+    return ref;
+    // jiacheng end
   }
 }
 
@@ -122,9 +142,15 @@ inline MirrorType* ReadBarrier::BarrierForRoot(MirrorType** root,
         ref = reinterpret_cast<MirrorType*>(Mark(ref));
       }
       AssertToSpaceInvariant(gc_root_source, ref);
+      // jiacheng start
+      jiacheng::ReaderBarrierTrigger(ref);
+      // jiacheng end
       return ref;
     } else if (kUseBrooksReadBarrier) {
       // To be implemented.
+      // jiacheng start
+      jiacheng::ReaderBarrierTrigger(ref);
+      // jiacheng end
       return ref;
     } else if (kUseTableLookupReadBarrier) {
       Thread* self = Thread::Current();
@@ -140,12 +166,18 @@ inline MirrorType* ReadBarrier::BarrierForRoot(MirrorType** root,
         }
       }
       AssertToSpaceInvariant(gc_root_source, ref);
+      // jiacheng start
+      jiacheng::ReaderBarrierTrigger(ref);
+      // jiacheng end
       return ref;
     } else {
       LOG(FATAL) << "Unexpected read barrier type";
       UNREACHABLE();
     }
   } else {
+    // jiacheng start
+    jiacheng::ReaderBarrierTrigger(ref);
+    // jiacheng end
     return ref;
   }
 }
@@ -163,9 +195,15 @@ inline MirrorType* ReadBarrier::BarrierForRoot(mirror::CompressedReference<Mirro
       ref = reinterpret_cast<MirrorType*>(Mark(ref));
     }
     AssertToSpaceInvariant(gc_root_source, ref);
+    // jiacheng start
+    jiacheng::ReaderBarrierTrigger(ref);
+    // jiacheng end
     return ref;
   } else if (with_read_barrier && kUseBrooksReadBarrier) {
     // To be implemented.
+    // jiacheng start
+    jiacheng::ReaderBarrierTrigger(ref);
+    // jiacheng end
     return ref;
   } else if (with_read_barrier && kUseTableLookupReadBarrier) {
     Thread* self = Thread::Current();
@@ -183,8 +221,14 @@ inline MirrorType* ReadBarrier::BarrierForRoot(mirror::CompressedReference<Mirro
       }
     }
     AssertToSpaceInvariant(gc_root_source, ref);
+    // jiacheng start
+    jiacheng::ReaderBarrierTrigger(ref);
+    // jiacheng end
     return ref;
   } else {
+    // jiacheng start
+    jiacheng::ReaderBarrierTrigger(ref);
+    // jiacheng end
     return ref;
   }
 }
-- 
2.34.1

