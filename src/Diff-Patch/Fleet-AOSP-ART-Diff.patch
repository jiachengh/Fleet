From d17ab3f4c9a9c426300783bf67f24735c948d376 Mon Sep 17 00:00:00 2001
From: jiachengh <jiacheng.huang@outlook.com>
Date: Mon, 23 Aug 2021 16:31:16 +0800
Subject: [PATCH 1/7] Cold Space

Change-Id: I79f0b7b09889c4f1619ecbbc788e138a086c4522
Signed-off-by: jiachengh <jiacheng.huang@outlook.com>
---
 dex2oat/dex2oat.cc                            |   5 +-
 runtime/Android.bp                            |   7 +
 runtime/gc/collector/concurrent_copying-inl.h |  65 +-
 runtime/gc/collector/concurrent_copying.cc    | 138 +++-
 runtime/gc/collector/garbage_collector.cc     |  13 +
 runtime/gc/heap.cc                            |  72 +++
 runtime/gc/heap.h                             |   7 +
 runtime/gc/space/region_space.cc              |   6 +
 runtime/jiacheng_activity_manager.cc          | 147 +++++
 runtime/jiacheng_activity_manager.h           |  88 +++
 runtime/jiacheng_cheatsheet.cc                |  26 +
 runtime/jiacheng_cheatsheet.h                 |  28 +
 runtime/jiacheng_cold_space.cc                | 171 +++++
 runtime/jiacheng_cold_space.h                 | 103 +++
 runtime/jiacheng_hack.cc                      | 594 ++++++++++++++++++
 runtime/jiacheng_hack.h                       | 104 +++
 runtime/jiacheng_region.cc                    |  41 ++
 runtime/jiacheng_region.h                     |  59 ++
 runtime/native/dalvik_system_VMRuntime.cc     |  27 +
 runtime/read_barrier-inl.h                    |  48 +-
 20 files changed, 1726 insertions(+), 23 deletions(-)
 create mode 100644 runtime/jiacheng_activity_manager.cc
 create mode 100644 runtime/jiacheng_activity_manager.h
 create mode 100644 runtime/jiacheng_cheatsheet.cc
 create mode 100644 runtime/jiacheng_cheatsheet.h
 create mode 100644 runtime/jiacheng_cold_space.cc
 create mode 100644 runtime/jiacheng_cold_space.h
 create mode 100644 runtime/jiacheng_hack.cc
 create mode 100644 runtime/jiacheng_hack.h
 create mode 100644 runtime/jiacheng_region.cc
 create mode 100644 runtime/jiacheng_region.h

diff --git a/dex2oat/dex2oat.cc b/dex2oat/dex2oat.cc
index 278523ec9a..bd9019a81c 100644
--- a/dex2oat/dex2oat.cc
+++ b/dex2oat/dex2oat.cc
@@ -2241,7 +2241,10 @@ class Dex2Oat final {
   }
 
   bool UseProfile() const {
-    return profile_file_fd_ != -1 || !profile_file_.empty();
+    // jiacheng start
+    // return profile_file_fd_ != -1 || !profile_file_.empty();
+    return false;
+    // jiacheng end
   }
 
   bool DoProfileGuidedOptimizations() const {
diff --git a/runtime/Android.bp b/runtime/Android.bp
index 7bf662c652..c494be159c 100644
--- a/runtime/Android.bp
+++ b/runtime/Android.bp
@@ -105,6 +105,13 @@ libart_cc_defaults {
         "interpreter/shadow_frame.cc",
         "interpreter/unstarted_runtime.cc",
         "java_frame_root_info.cc",
+// jiacheng start ------------------------------------
+        "jiacheng_cheatsheet.cc",
+        "jiacheng_cold_space.cc",
+        "jiacheng_hack.cc",
+        "jiacheng_region.cc",
+        "jiacheng_activity_manager.cc",
+// jiacheng end --------------------------------------
         "jdwp/jdwp_event.cc",
         "jdwp/jdwp_expand_buf.cc",
         "jdwp/jdwp_handler.cc",
diff --git a/runtime/gc/collector/concurrent_copying-inl.h b/runtime/gc/collector/concurrent_copying-inl.h
index 2de79107f4..ecf7caed2f 100644
--- a/runtime/gc/collector/concurrent_copying-inl.h
+++ b/runtime/gc/collector/concurrent_copying-inl.h
@@ -28,6 +28,11 @@
 #include "mirror/class.h"
 #include "mirror/object-readbarrier-inl.h"
 
+// jiacheng start  
+#include "jiacheng_cold_space.h"
+#include "jiacheng_hack.h"
+// jiacheng end
+
 namespace art {
 namespace gc {
 namespace collector {
@@ -149,14 +154,33 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
     // are consulted. If they look like gray but aren't really, the
     // read barriers slow path can trigger when it shouldn't. To guard
     // against this, return here if the CC collector isn't running.
+
+    // jiacheng start
+    jiacheng::GCMarkTrigger(from_ref);
+    // jiacheng end
     return from_ref;
   }
   DCHECK(region_space_ != nullptr) << "Read barrier slow path taken when CC isn't running?";
-  if (region_space_->HasAddress(from_ref)) {
+  // jiahceng start -------------------------------------_
+    if (jiacheng::ColdSpace::Current()->HasAddress(from_ref)) {
+      // Mark在ColdSpace中的对象，把该对象标灰
+      // bool success = from_ref->AtomicSetReadBarrierState(ReadBarrier::WhiteState(), ReadBarrier::GrayState());
+      bool success = from_ref->AtomicSetReadBarrierState(ReadBarrier::NonGrayState(), ReadBarrier::GrayState());
+      if (success) {
+        PushOntoMarkStack(self, from_ref);
+      }
+      jiacheng::GCMarkTrigger(from_ref);
+      return from_ref;
+    }  else if (region_space_->HasAddress(from_ref)) {
+  // if (region_space_->HasAddress(from_ref)) {
+  // jiacheng end -------------------------------------
     space::RegionSpace::RegionType rtype = region_space_->GetRegionTypeUnsafe(from_ref);
     switch (rtype) {
       case space::RegionSpace::RegionType::kRegionTypeToSpace:
         // It's already marked.
+        // jiacheng start
+        jiacheng::GCMarkTrigger(from_ref);
+        // jiacheng end
         return from_ref;
       case space::RegionSpace::RegionType::kRegionTypeFromSpace: {
         mirror::Object* to_ref = GetFwdPtr(from_ref);
@@ -166,18 +190,33 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
         }
         // The copy should either be in a to-space region, or in the
         // non-moving space, if it could not fit in a to-space region.
-        DCHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
+        // jiacheng start
+        // DCHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
+        //     << "from_ref=" << from_ref << " to_ref=" << to_ref;
+        DCHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref) 
+               || jiacheng::ColdSpace::Current()->HasAddress(to_ref))
             << "from_ref=" << from_ref << " to_ref=" << to_ref;
+        jiacheng::GCMarkTrigger(to_ref);
+        // jiacheng end
         return to_ref;
       }
-      case space::RegionSpace::RegionType::kRegionTypeUnevacFromSpace:
+      case space::RegionSpace::RegionType::kRegionTypeUnevacFromSpace: {
         if (kNoUnEvac && use_generational_cc_ && !region_space_->IsLargeObject(from_ref)) {
           if (!kFromGCThread) {
             DCHECK(IsMarkedInUnevacFromSpace(from_ref)) << "Returning unmarked object to mutator";
           }
+          // jiacheng start
+          jiacheng::GCMarkTrigger(from_ref);
+          // jiacheng end
           return from_ref;
         }
-        return MarkUnevacFromSpaceRegion(self, from_ref, region_space_bitmap_);
+        // jiacheng start
+        // return MarkUnevacFromSpaceRegion(self, from_ref, region_space_bitmap_);
+        mirror::Object* temp_ref = MarkUnevacFromSpaceRegion(self, from_ref, region_space_bitmap_);
+        jiacheng::GCMarkTrigger(temp_ref);
+        // jiacheng end
+        return temp_ref;
+      }
       default:
         // The reference is in an unused region. Remove memory protection from
         // the region space and log debugging information.
@@ -189,9 +228,19 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
     }
   } else {
     if (immune_spaces_.ContainsObject(from_ref)) {
-      return MarkImmuneSpace<kGrayImmuneObject>(self, from_ref);
+      // jiacheng start
+      // return MarkImmuneSpace<kGrayImmuneObject>(self, from_ref);
+      mirror::Object* temp_ref = MarkImmuneSpace<kGrayImmuneObject>(self, from_ref);
+      jiacheng::GCMarkTrigger(temp_ref);
+      return temp_ref;
+      // jiacheng end
     } else {
-      return MarkNonMoving(self, from_ref, holder, offset);
+      // jiacheng start
+      // return MarkNonMoving(self, from_ref, holder, offset);
+      mirror::Object* temp_ref = MarkNonMoving(self, from_ref, holder, offset);
+      jiacheng::GCMarkTrigger(temp_ref);
+      return temp_ref;
+      // jiacheng end
     }
   }
 }
@@ -225,7 +274,9 @@ inline mirror::Object* ConcurrentCopying::MarkFromReadBarrier(mirror::Object* fr
 }
 
 inline mirror::Object* ConcurrentCopying::GetFwdPtr(mirror::Object* from_ref) {
-  DCHECK(region_space_->IsInFromSpace(from_ref));
+  // jiacheng start
+  // DCHECK(region_space_->IsInFromSpace(from_ref));
+  // jiacheng end
   LockWord lw = from_ref->GetLockWord(false);
   if (lw.GetState() == LockWord::kForwardingAddress) {
     mirror::Object* fwd_ptr = reinterpret_cast<mirror::Object*>(lw.ForwardingAddress());
diff --git a/runtime/gc/collector/concurrent_copying.cc b/runtime/gc/collector/concurrent_copying.cc
index 9428a0b8cd..70c0d58882 100644
--- a/runtime/gc/collector/concurrent_copying.cc
+++ b/runtime/gc/collector/concurrent_copying.cc
@@ -47,6 +47,12 @@
 #include "thread_list.h"
 #include "well_known_classes.h"
 
+// jiacheng start
+#include "jiacheng_cold_space.h"
+#include "jiacheng_activity_manager.h"
+#include <iostream>
+// jiacheng end
+
 namespace art {
 namespace gc {
 namespace collector {
@@ -195,10 +201,16 @@ void ConcurrentCopying::RunPhases() {
   {
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
     InitializePhase();
+    // jiacheng start  -------------------
+    LOG(INFO) << "jiacheng concurrent_copying.cc 175 InitializePhase Pass" << std::flush;
+    // jiacheng end ----------------------
     // In case of forced evacuation, all regions are evacuated and hence no
     // need to compute live_bytes.
     if (use_generational_cc_ && !young_gen_ && !force_evacuate_all_) {
       MarkingPhase();
+    // jiacheng start  -------------------
+    LOG(INFO) << "jiacheng concurrent_copying.cc 195 MarkingPhase Pass" << std::flush;
+    // jiacheng end ----------------------
     }
   }
   if (kUseBakerReadBarrier && kGrayDirtyImmuneObjects) {
@@ -209,6 +221,9 @@ void ConcurrentCopying::RunPhases() {
     // the pause.
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
     GrayAllDirtyImmuneObjects();
+    // jiacheng start  -------------------
+    LOG(INFO) << "jiacheng concurrent_copying.cc 187 GrayAllDirtyImmuneObjects Pass" << std::flush;
+    // jiacheng end ----------------------
   }
   FlipThreadRoots();
   {
@@ -233,7 +248,13 @@ void ConcurrentCopying::RunPhases() {
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
     ReclaimPhase();
   }
+  // jiacheng start  -------------------
+  LOG(INFO) << "jiacheng concurrent_copying.cc 219 ReclaimPhase Pass" << std::flush;
+  // jiacheng end ----------------------
   FinishPhase();
+  // jiacheng start  -------------------
+  LOG(INFO) << "jiacheng concurrent_copying.cc 223 FinishPhase Pass" << std::flush;
+  // jiacheng end ----------------------
   CHECK(is_active_);
   is_active_ = false;
   thread_running_gc_ = nullptr;
@@ -1799,9 +1820,13 @@ void ConcurrentCopying::PushOntoMarkStack(Thread* const self, mirror::Object* to
         << "ref=" << to_ref
         << " self->gc_marking=" << self->GetIsGcMarking()
         << " cc->is_marking=" << is_marking_;
-    CHECK(self == thread_running_gc_)
-        << "Only GC-running thread should access the mark stack "
-        << "in the GC exclusive mark stack mode";
+
+    // jiacheng start ----------------------------
+    // CHECK(self == thread_running_gc_)
+    //     << "Only GC-running thread should access the mark stack "
+    //     << "in the GC exclusive mark stack mode";
+    // jiacheng end ------------------------------
+
     // Access the GC mark stack without a lock.
     if (UNLIKELY(gc_mark_stack_->IsFull())) {
       ExpandGcMarkStack();
@@ -2182,6 +2207,17 @@ inline void ConcurrentCopying::ProcessMarkStackRef(mirror::Object* to_ref) {
       perform_scan = true;
       break;
     default:
+  // // jiacheng start ---------------------------------
+  // code in android 9 这里不能直接用
+  // else if (jiacheng::ColdSpace::Current()->HasAddress(to_ref)) {
+  //   jiacheng::ColdSpace* cold_space = jiacheng::ColdSpace::Current();
+  //   if (!cold_space->GetMarkBitmap(to_ref)) {
+  //     cold_space->SetMarkBitmap(to_ref);
+  //     Scan(to_ref);
+  //   }
+  // }
+  // // jiacheng end -----------------------------------
+
       DCHECK(!region_space_->HasAddress(to_ref)) << to_ref;
       DCHECK(!immune_spaces_.ContainsObject(to_ref));
       // Non-moving or large-object space.
@@ -2244,9 +2280,24 @@ inline void ConcurrentCopying::ProcessMarkStackRef(mirror::Object* to_ref) {
                 (referent = to_ref->AsReference()->GetReferent<kWithoutReadBarrier>()) != nullptr &&
                 !IsInToSpace(referent)))) {
     // Leave this reference gray in the queue so that GetReferent() will trigger a read barrier. We
+    
     // will change it to non-gray later in ReferenceQueue::DisableReadBarrierForReference.
-    DCHECK(to_ref->AsReference()->GetPendingNext() != nullptr)
-        << "Left unenqueued ref gray " << to_ref;
+    // jiacheng start --------------------------
+    if (jiacheng::ColdSpace::Current()->HasAddress(referent)) {
+      if (kUseBakerReadBarrier) {
+        bool success = to_ref->AtomicSetReadBarrierState<std::memory_order_release>(
+            ReadBarrier::GrayState(),
+            ReadBarrier::NonGrayState());
+        DCHECK(success) << "Must succeed as we won the race.";
+      }
+    } else {
+      DCHECK(to_ref->AsReference()->GetPendingNext() != nullptr)
+          << "Left unenqueued ref gray " << to_ref;
+    }
+    // DCHECK(to_ref->AsReference()->GetPendingNext() != nullptr)
+    //     << "Left unenqueued ref gray " << to_ref;
+  // jiacheng end ----------------------------
+
   } else {
     // We may occasionally leave a reference non-gray in the queue if its referent happens to be
     // concurrently marked after the Scan() call above has enqueued the Reference, in which case the
@@ -2367,7 +2418,9 @@ void ConcurrentCopying::CheckEmptyMarkStack() {
   } else {
     // Shared, GC-exclusive, or off.
     MutexLock mu(thread_running_gc_, mark_stack_lock_);
-    CHECK(gc_mark_stack_->IsEmpty());
+    // jiacheng start -------------------------------
+    // CHECK(gc_mark_stack_->IsEmpty());
+    // jiacheng end ---------------------------------
     CHECK(revoked_mark_stacks_.empty());
   }
 }
@@ -2814,7 +2867,13 @@ void ConcurrentCopying::AssertToSpaceInvariant(mirror::Object* obj,
         LOG(FATAL) << "Invalid reference " << ref
                    << " referenced from object " << obj << " at offset " << offset;
       }
-    } else {
+    } 
+    // jiacheng start -------------------------
+    else if (jiacheng::ColdSpace::Current()->HasAddress(ref)) {
+      // pass
+    }
+    // jiacheng end ---------------------------
+    else {
       // Check to-space invariant in non-moving space.
       AssertToSpaceInvariantInNonMovingSpace(obj, ref);
     }
@@ -3070,6 +3129,11 @@ class ConcurrentCopying::RefFieldsVisitor {
 
 template <bool kNoUnEvac>
 inline void ConcurrentCopying::Scan(mirror::Object* to_ref) {
+  // jiacheng start  -------------------------------------
+  // LOG(INFO) << "jiacheng concurrent_copying.cc 2147 Scan() to_ref= " << to_ref 
+  //           << " ColdSpace::HasAddress()= " << jiacheng::ColdSpace::Current()->HasAddress(to_ref);
+
+  // jiacheng end ----------------------------------------
   // Cannot have `kNoUnEvac` when Generational CC collection is disabled.
   DCHECK(!kNoUnEvac || use_generational_cc_);
   if (kDisallowReadBarrierDuringScan && !Runtime::Current()->IsActiveTransaction()) {
@@ -3101,6 +3165,10 @@ inline void ConcurrentCopying::Process(mirror::Object* obj, MemberOffset offset)
       ref,
       /*holder=*/ obj,
       offset);
+  // jiacheng start
+  // LOG(INFO) << "Father= " << reinterpret_cast<size_t>(obj) << ' ' << (obj?obj->PrettyTypeOf():"null") 
+  //           << " Child= " << reinterpret_cast<size_t>(to_ref) << ' ' << (to_ref?to_ref->PrettyTypeOf():"null");
+  // jiacheng end
   if (to_ref == ref) {
     return;
   }
@@ -3336,8 +3404,25 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
   size_t bytes_allocated = 0U;
   size_t dummy;
   bool fall_back_to_non_moving = false;
-  mirror::Object* to_ref = region_space_->AllocNonvirtual</*kForEvac=*/ true>(
-      region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
+  // jiacheng start --------------------------------
+  // mirror::Object* to_ref = region_space_->AllocNonvirtual</*kForEvac=*/ true>(
+  //     region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
+  mirror::Object* to_ref = nullptr;
+  if (region_space_alloc_size <= jiacheng::ColdSpace::kRegionSize &&
+      jiacheng::ActivityManager::Current()->ShouldSwapOut(from_ref)) {
+    to_ref = jiacheng::ColdSpace::Current()->Alloc(region_space_alloc_size);
+    region_space_bytes_allocated = region_space_alloc_size;
+    LOG(INFO) << "jiacheng concurrent_copying.cc 2412 ColdSpace::Current()->Alloc()" 
+              << " region_space_alloc_size= " << region_space_alloc_size 
+              << " to_ref= " << to_ref
+              << " GetAllocatedObjNum()= " << jiacheng::ColdSpace::Current()->GetAllocatedObjNum();
+  }
+  if (!to_ref) {
+    to_ref = region_space_->AllocNonvirtual</*kForEvac*/ true>(
+            region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
+  }
+  // jiacheng end --------------------------------
+
   bytes_allocated = region_space_bytes_allocated;
   if (LIKELY(to_ref != nullptr)) {
     DCHECK_EQ(region_space_alloc_size, region_space_bytes_allocated);
@@ -3400,7 +3485,13 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
       // look like a valid but dead (dummy) object and keep it for
       // future reuse.
       FillWithDummyObject(self, to_ref, bytes_allocated);
-      if (!fall_back_to_non_moving) {
+      // jiacheng start  -----------------------------------
+      if (jiacheng::ColdSpace::Current()->HasAddress(to_ref)) {
+        /* Don't do any thing */
+      }
+      else if (!fall_back_to_non_moving) {
+      // if (!fall_back_to_non_moving) {
+      // jiacheng end -----------------------------------
         DCHECK(region_space_->IsInToSpace(to_ref));
         if (bytes_allocated > space::RegionSpace::kRegionSize) {
           // Free the large alloc.
@@ -3426,8 +3517,14 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
       to_ref = reinterpret_cast<mirror::Object*>(old_lock_word.ForwardingAddress());
       CHECK(to_ref != nullptr);
       CHECK_NE(to_ref, lost_fwd_ptr);
-      CHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
+
+      // jiacheng start ----------------------------------- 增加对ColdSpace的判断
+      // CHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
+      //     << "to_ref=" << to_ref << " " << heap_->DumpSpaces();
+      CHECK(region_space_->IsInToSpace(to_ref) || jiacheng::ColdSpace::Current()->HasAddress(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
           << "to_ref=" << to_ref << " " << heap_->DumpSpaces();
+      // jiacheng end -----------------------------------
+      
       CHECK_NE(to_ref->GetLockWord(false).GetState(), LockWord::kForwardingAddress);
       return to_ref;
     }
@@ -3461,7 +3558,14 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
         bytes_moved_.fetch_add(bytes_allocated, std::memory_order_relaxed);
       }
 
-      if (LIKELY(!fall_back_to_non_moving)) {
+      // jiacheng start  --------------------------------
+      if (jiacheng::ColdSpace::Current()->HasAddress(to_ref)) {
+        // pass
+        // LOG(INFO) << "jiacheng concurrent_copying.cc 2516";
+      } else if (LIKELY(!fall_back_to_non_moving)) {
+      // if (LIKELY(!fall_back_to_non_moving)) {
+      // jiacheng end  --------------------------------
+
         DCHECK(region_space_->IsInToSpace(to_ref));
       } else {
         DCHECK(heap_->non_moving_space_->HasAddress(to_ref));
@@ -3499,9 +3603,17 @@ mirror::Object* ConcurrentCopying::IsMarked(mirror::Object* from_ref) {
   mirror::Object* to_ref;
   if (rtype == space::RegionSpace::RegionType::kRegionTypeFromSpace) {
     to_ref = GetFwdPtr(from_ref);
+
+    // jiacheng start ------------------------------------
+    // DCHECK(to_ref == nullptr || region_space_->IsInToSpace(to_ref) ||
+    //        heap_->non_moving_space_->HasAddress(to_ref))
+    //     << "from_ref=" << from_ref << " to_ref=" << to_ref;
     DCHECK(to_ref == nullptr || region_space_->IsInToSpace(to_ref) ||
-           heap_->non_moving_space_->HasAddress(to_ref))
+           heap_->non_moving_space_->HasAddress(to_ref) || 
+           jiacheng::ColdSpace::Current()->HasAddress(to_ref))
         << "from_ref=" << from_ref << " to_ref=" << to_ref;
+    // jiacheng end  -------------------------------------
+    
   } else if (rtype == space::RegionSpace::RegionType::kRegionTypeUnevacFromSpace) {
     if (IsMarkedInUnevacFromSpace(from_ref)) {
       to_ref = from_ref;
diff --git a/runtime/gc/collector/garbage_collector.cc b/runtime/gc/collector/garbage_collector.cc
index 1785a7789b..565d38e6ec 100644
--- a/runtime/gc/collector/garbage_collector.cc
+++ b/runtime/gc/collector/garbage_collector.cc
@@ -38,6 +38,10 @@
 #include "thread-current-inl.h"
 #include "thread_list.h"
 
+// jiacheng start
+#include "jiacheng_hack.h"
+// jiacheng end
+
 namespace art {
 namespace gc {
 namespace collector {
@@ -144,6 +148,11 @@ uint64_t GarbageCollector::ExtractRssFromMincore(
 }
 
 void GarbageCollector::Run(GcCause gc_cause, bool clear_soft_references) {
+
+  // jiacheng start
+  jiacheng::BeforeGarbageCollectorRun(this);
+  // jiacheng end
+
   ScopedTrace trace(android::base::StringPrintf("%s %s GC", PrettyCause(gc_cause), GetName()));
   Thread* self = Thread::Current();
   uint64_t start_time = NanoTime();
@@ -182,6 +191,10 @@ void GarbageCollector::Run(GcCause gc_cause, bool clear_soft_references) {
     pause_histogram_.AdjustAndAddValue(pause_time);
   }
   is_transaction_active_ = false;
+
+  // jiacheng start
+  jiacheng::AfterGarbageCollectorRun(this);
+  // jiacheng end  
 }
 
 void GarbageCollector::SwapBitmaps() {
diff --git a/runtime/gc/heap.cc b/runtime/gc/heap.cc
index ff53f7896e..2720f4dab9 100644
--- a/runtime/gc/heap.cc
+++ b/runtime/gc/heap.cc
@@ -720,6 +720,78 @@ Heap::Heap(size_t initial_size,
   }
 }
 
+// jiacheng start
+void Heap::JiachengDebug() {
+  // 用于显示Heap当前的信息
+  Thread* self = Thread::Current();
+
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "alloc_spaces_.size= " << alloc_spaces_.size();
+  for (auto& it : alloc_spaces_) {
+      LOG(INFO) << "jiacheng heap.cc 641: "
+                << "space_addr= " << size_t(it);
+  } 
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "non_moving_space= " << size_t(non_moving_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "rosalloc_space_= " << size_t(rosalloc_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "dlmalloc_space_= " << size_t(dlmalloc_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "main_space_= " << size_t(main_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "large_object_space_= " << size_t(large_object_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "zygote_space_= " << size_t(zygote_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "bump_pointer_space_= " << size_t(bump_pointer_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "temp_space_= " << size_t(temp_space_);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "region_space_= " << size_t(region_space_); 
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "main_space_backup_= " << size_t(main_space_backup_.get());
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "current_allocator_= " << current_allocator_;   
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "current_non_moving_allocator_= " << current_non_moving_allocator_;   
+
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "collector_type_= " << collector_type_;
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "foreground_collector_type_= " << foreground_collector_type_;
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "background_collector_type_= " << background_collector_type_;
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "desired_collector_type_= " << desired_collector_type_;
+
+  gc_complete_lock_->ExclusiveLock(self);
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "collector_type_running_= " << collector_type_running_;
+  gc_complete_lock_->ExclusiveUnlock(self);
+
+
+  for (auto& it : gc_plan_) {
+    LOG(INFO) << "jiacheng heap.cc 641: "
+              << "gc_plan_= " << it;
+  }
+
+  for (auto& it : garbage_collectors_) {
+    LOG(INFO) << "jiacheng heap.cc 641: "
+              << "garbage_collector_= " << size_t(it);
+  }
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "semi_space_collector_= " << semi_space_collector_;
+  // LOG(INFO) << "jiacheng heap.cc 641: "
+  //           << "mark_compact_collector_= " << mark_compact_collector_;
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "concurrent_copying_collector_= " << concurrent_copying_collector_;
+
+  LOG(INFO) << "jiacheng heap.cc 641: "
+            << "use_tlab_= " << use_tlab_;
+}
+// jiacheng end
+
 MemMap Heap::MapAnonymousPreferredAddress(const char* name,
                                           uint8_t* request_begin,
                                           size_t capacity,
diff --git a/runtime/gc/heap.h b/runtime/gc/heap.h
index 5cf197869d..4f266fcd5e 100644
--- a/runtime/gc/heap.h
+++ b/runtime/gc/heap.h
@@ -128,7 +128,10 @@ static constexpr bool kUseThreadLocalAllocationStack = true;
 class Heap {
  public:
   static constexpr size_t kDefaultStartingSize = kPageSize;
+  // jiacheng start
   static constexpr size_t kDefaultInitialSize = 2 * MB;
+  // static constexpr size_t kDefaultInitialSize = 256 * MB;
+  // jiacheng end
   static constexpr size_t kDefaultMaximumSize = 256 * MB;
   static constexpr size_t kDefaultNonMovingSpaceCapacity = 64 * MB;
   static constexpr size_t kDefaultMaxFree = 2 * MB;
@@ -221,6 +224,10 @@ class Heap {
 
   ~Heap();
 
+  // jiacheng start
+  void JiachengDebug();
+  // jiacheng end
+
   // Allocates and initializes storage for an object instance.
   template <bool kInstrumented, typename PreFenceVisitor>
   mirror::Object* AllocObject(Thread* self,
diff --git a/runtime/gc/space/region_space.cc b/runtime/gc/space/region_space.cc
index 823043ec75..d0555b0896 100644
--- a/runtime/gc/space/region_space.cc
+++ b/runtime/gc/space/region_space.cc
@@ -47,6 +47,12 @@ static constexpr uint32_t kPoisonDeadObject = 0xBADDB01D;  // "BADDROID"
 // Whether we check a region's live bytes count against the region bitmap.
 static constexpr bool kCheckLiveBytesAgainstRegionBitmap = kIsDebugBuild;
 
+// jiacheng start
+// void RegionSpace::JiachengDebug() {
+  
+// }
+// jiacheng end
+
 MemMap RegionSpace::CreateMemMap(const std::string& name,
                                  size_t capacity,
                                  uint8_t* requested_begin) {
diff --git a/runtime/jiacheng_activity_manager.cc b/runtime/jiacheng_activity_manager.cc
new file mode 100644
index 0000000000..9f359b1a74
--- /dev/null
+++ b/runtime/jiacheng_activity_manager.cc
@@ -0,0 +1,147 @@
+#include "thread-current-inl.h"
+#include "base/mutex.h"
+
+#include "jiacheng_activity_manager.h"
+
+namespace art {
+namespace jiacheng {
+
+Mutex ActivityManager::singleton_lock_("Activity Manager Singleton Lock", kLoggingLock);
+ActivityManager* ActivityManager::activity_manager_(nullptr); 
+
+ActivityManager::ActivityManager():
+    activity_manager_lock_("Activity Manager Lock", kLoggingLock),
+    // current_working_set_(new std::set<mirror::Object*>()),
+    current_working_set_(nullptr),
+    current_activity_name_(""),
+    activity_ws_map_(),
+    sampling_(false),
+    in_gc_(true),
+    gc_time_(0) {
+    
+    // default working set
+    // activity_ws_map_[""] = current_working_set_;
+}
+
+ActivityManager::~ActivityManager() {
+}
+
+ActivityManager* ActivityManager::Create() {
+    ActivityManager* it = new ActivityManager();
+    return it;
+}
+
+ActivityManager* ActivityManager::Current() {
+    if (activity_manager_ == nullptr) {
+        Thread* self = Thread::Current();
+        singleton_lock_.ExclusiveLock(self);
+        if (activity_manager_ == nullptr) {
+            activity_manager_ = Create();
+        }
+        singleton_lock_.ExclusiveUnlock(self);
+    }
+    return activity_manager_;
+}
+
+void ActivityManager::JiachengDebug() const {
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "current_working_set_=" << size_t(current_working_set_);
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "current_activity_name_=" << current_activity_name_;
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "activity_ws_map_= " << activity_ws_map_.size();
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "sampling_= " << sampling_.load();
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "in_gc_= " << in_gc_.load();
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "gc_time_= " << gc_time_.load();
+}
+
+bool ActivityManager::ShouldSwapOut(mirror::Object *obj) {
+    bool res = false;
+    // Thread* self = Thread::Current();
+    // activity_manager_lock_.ExclusiveLock(self);
+    if (current_working_set_ != nullptr && current_working_set_->find(obj) == current_working_set_->end()) {
+        res = true;
+    }
+    // activity_manager_lock_.ExclusiveUnlock(self);
+    return res;
+
+    // (void)obj;
+    // return true;
+}
+
+
+void ActivityManager::RecordWS(mirror::Object* obj) {
+    // 只要指定采样的时候才采样
+    if (!sampling_.load()) { 
+        return;
+    }
+
+    Thread *self = Thread::Current();
+
+    activity_manager_lock_.ExclusiveLock(self);
+    if (current_working_set_) {
+        current_working_set_->insert(obj);
+    }
+    activity_manager_lock_.ExclusiveUnlock(self);
+}
+
+ 
+void ActivityManager::UpdateActivityState(const std::string& activity_name, int state) {
+    if (state != 1) { // RESUMED
+        return;
+    }
+    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 83 UpdateActivityState()"
+              << " activity_name= " << activity_name
+              << " state= " << state
+              << std::flush;
+    // Debug Start 计算每个工作集之间的交集
+    for (const auto& it : activity_ws_map_) {
+        LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 68 activity_set_size= "
+                  << it.first << ' '
+                  << (it.second)->size();
+    }
+    Thread *self = Thread::Current();
+    // std::vector<mirror::Object*> intersection;
+
+    // activity_manager_lock_.ExclusiveLock(self);
+    // for (const auto& it : activity_ws_map_) {
+    //     const std::set<mirror::Object*>* s1 = it.second;
+    //     for (const auto& it2 : activity_ws_map_) {
+    //         const std::set<mirror::Object*>* s2 = it2.second;
+    //         std::set_intersection(
+    //             s1->begin(), s1->end(), 
+    //             s2->begin(), s2->end(), 
+    //             std::back_inserter(intersection)
+    //         );
+    //         LOG(INFO) << "intersection.size()# " <<it.first << " and " << it2.first << "= " << intersection.size();
+    //         intersection.clear();
+    //     }
+    // }
+    // activity_manager_lock_.ExclusiveUnlock(self);
+    // Debug End
+
+
+    // 更新当前的Activity Name
+    activity_manager_lock_.ExclusiveLock(self);
+    
+    current_activity_name_ = activity_name;
+
+    std::map<std::string, std::set<mirror::Object*>*>::iterator it = activity_ws_map_.find(current_activity_name_);
+    if (it == activity_ws_map_.end()) {
+        current_working_set_ = new std::set<mirror::Object*>();
+        activity_ws_map_[current_activity_name_] = current_working_set_;
+    } else {
+        current_working_set_ = it->second;
+    }
+    activity_manager_lock_.ExclusiveUnlock(self);
+}
+
+
+void ActivityManager::ForgetWorkingSet() {
+    Thread* self = Thread::Current();
+    activity_manager_lock_.ExclusiveLock(self);
+    if (current_working_set_) {
+        current_working_set_->clear();
+    }
+    activity_manager_lock_.ExclusiveUnlock(self);
+}
+
+} // namespace jiacheng
+} // namespace art
\ No newline at end of file
diff --git a/runtime/jiacheng_activity_manager.h b/runtime/jiacheng_activity_manager.h
new file mode 100644
index 0000000000..cba767f77d
--- /dev/null
+++ b/runtime/jiacheng_activity_manager.h
@@ -0,0 +1,88 @@
+#ifndef JIACHENG_ACTIVITY_MANAGER_H_
+#define JIACHENG_ACTIVITY_MANAGER_H_
+
+#include <set>
+#include <map>
+#include <atomic>
+
+#include "base/mutex.h"
+
+namespace art {
+
+namespace mirror {
+    class Object;
+}
+
+namespace jiacheng {
+
+class ActivityManager {
+public:
+    ActivityManager();
+    ~ActivityManager();
+
+    static Mutex singleton_lock_;
+    static ActivityManager* activity_manager_; 
+
+    static ActivityManager* Create();
+    static ActivityManager* Current();
+
+    void JiachengDebug() const;
+
+    bool ShouldSwapOut(mirror::Object *obj);
+
+    void RecordWS(mirror::Object* obj);
+
+    void UpdateActivityState(const std::string& activity_name, int state);
+
+    /* 每次GC完成之后重新估计当前Activity的工作集 */
+    void ForgetWorkingSet();
+
+    bool GetSampling() const {
+        return sampling_.load();
+    }
+
+    void SetSampling(bool sampling) {
+        sampling_.store(sampling);
+    }
+
+    bool GetInGC() const {
+        return in_gc_.load();
+    }
+
+    void SetInGC(bool in_gc) {
+        in_gc_.store(in_gc);
+    }
+
+    size_t GetGCTime() const {
+        return gc_time_.load();
+    }
+
+    void IncGCTime() {
+        gc_time_.fetch_add(1);
+    }
+
+    // 用于保护current_working_set, activity_set, current_activity_name
+    Mutex activity_manager_lock_; 
+
+    // 当前Activity使用工作集的缓存指针，从而不需要每次都从map中查找
+    std::set<mirror::Object*>* current_working_set_;
+
+    // 保存当前的用户看到的Activity名
+    std::string current_activity_name_;
+
+    // 保存了ActivityName : WorkingSet 的映射
+    std::map<std::string, std::set<mirror::Object*> *> activity_ws_map_; 
+
+    std::atomic<bool> sampling_;
+
+    // 每次GC开始的时候设置为true, GC结束的时候设置为false
+    std::atomic<bool> in_gc_;
+
+    // GC发生的次数
+    std::atomic<size_t> gc_time_;
+};
+
+}
+}
+
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_cheatsheet.cc b/runtime/jiacheng_cheatsheet.cc
new file mode 100644
index 0000000000..eb0d51034d
--- /dev/null
+++ b/runtime/jiacheng_cheatsheet.cc
@@ -0,0 +1,26 @@
+#include "jiacheng_cheatsheet.h"
+
+
+namespace art {
+namespace jiacheng {
+
+
+void CheatSheet::AddRememberedSet(uint8_t *obj) {
+    remembered_set_.insert(obj);
+}
+
+void CheatSheet::AddColdSet(uint8_t *obj) {
+    cold_set_.insert(obj);
+}
+
+bool CheatSheet::InRememberedSet(uint8_t *obj) {
+    return remembered_set_.find(obj) != remembered_set_.end();
+}
+
+bool CheatSheet::InColdSet(uint8_t *obj) {
+    return cold_set_.find(obj) != cold_set_.end();
+}
+
+
+}
+}
\ No newline at end of file
diff --git a/runtime/jiacheng_cheatsheet.h b/runtime/jiacheng_cheatsheet.h
new file mode 100644
index 0000000000..7ce875dbb9
--- /dev/null
+++ b/runtime/jiacheng_cheatsheet.h
@@ -0,0 +1,28 @@
+#ifndef JIACHENG_CHEATSHEET_H_
+#define JIACHENG_CHEATSHEET_H_
+
+#include <set>
+
+namespace art {
+namespace jiacheng {
+
+class CheatSheet {
+public:
+    CheatSheet();
+    ~CheatSheet();
+
+    void AddRememberedSet(uint8_t *obj);
+    void AddColdSet(uint8_t *obj);
+
+    bool InRememberedSet(uint8_t *obj);
+    bool InColdSet(uint8_t * obj);
+
+    std::set<uint8_t*> remembered_set_;
+    std::set<uint8_t*> cold_set_;
+    std::set<uint8_t*> hot_set_;
+};
+
+}
+}
+
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_cold_space.cc b/runtime/jiacheng_cold_space.cc
new file mode 100644
index 0000000000..e224d03925
--- /dev/null
+++ b/runtime/jiacheng_cold_space.cc
@@ -0,0 +1,171 @@
+#include <fstream>
+#include <thread>
+#include <chrono>
+#include <atomic>
+#include <sys/mman.h>
+
+#include "base/mem_map.h"
+#include "gc/space/region_space.h"
+#include "base/mutex.h"
+#include "thread_list.h"
+#include "thread-current-inl.h"
+
+#include "jiacheng_hack.h"
+#include "jiacheng_cold_space.h"
+#include "jiacheng_region.h"
+
+
+namespace art{
+namespace jiacheng {
+
+Mutex ColdSpace::singleton_lock_("Cold Space Singleton Lock", kLoggingLock);
+
+ColdSpace* ColdSpace::cold_space_ = nullptr;
+
+ColdSpace::ColdSpace(MemMap* mem_map):
+    region_lock_("Cold Space Lock", kLoggingLock),
+    mem_map_(mem_map),
+    begin_(mem_map->Begin()),
+    end_(mem_map->End()),
+    num_regions_(mem_map->Size() / kRegionSize),
+    top_region_idx_(0U),
+    current_region_(nullptr),
+    madvice_top_region_idx_(0),
+    allocated_obj_num_(0),
+    mark_bitmap_(),
+    remembered_set_(),
+    remembered_root_stack_() {
+    
+    regions_.reset(new Region[num_regions_]);
+    uint8_t* region_addr = mem_map->Begin();
+    for (size_t i = 0; i < num_regions_; ++i, region_addr += kRegionSize) {
+        regions_[i].Init(i, region_addr, region_addr + kRegionSize);
+    }
+    current_region_ = &regions_[top_region_idx_++];
+
+}
+
+ColdSpace::~ColdSpace() {}
+
+ColdSpace* ColdSpace::Current() {
+    if (cold_space_ == nullptr) {
+        Thread* self = Thread::Current();
+        singleton_lock_.ExclusiveLock(self);
+        if (cold_space_ == nullptr) {
+            cold_space_ = Create();
+        }
+        singleton_lock_.ExclusiveUnlock(self);
+    }
+    return cold_space_;
+}
+
+
+ColdSpace* ColdSpace::Create() {
+    std::string error_msg;
+    MemMap mem_map = MemMap::MapAnonymous("Cold Space",
+                                            nullptr,
+                                            kCapacitySize + kRegionSize,
+                                            PROT_READ | PROT_WRITE,
+                                            true,
+                                            false,
+                                            nullptr,
+                                            &error_msg);
+
+    // if (!mem_map) {
+    //     LOG(INFO) << "jiacheng jiacheng_cold_space.cc 46 mem_map=nullptr error_msg= " << error_msg; 
+    // }
+    return new ColdSpace(&mem_map);
+}
+
+void ColdSpace::JiachengDebug() {
+    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "mem_map_= " << size_t(mem_map_); 
+    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "num_regions_= " << num_regions_; 
+    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "top_region_idx_= " << top_region_idx_; 
+    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "current_region_= " << current_region_; 
+    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "allocated_obj_num_= " << allocated_obj_num_.load(); 
+}
+
+
+mirror::Object* ColdSpace::Alloc(size_t num_bytes) {
+    num_bytes = RoundUp(num_bytes, kAlignment);
+    mirror::Object* obj;
+    obj = current_region_->Alloc(num_bytes);
+    if (obj != nullptr) {
+        allocated_obj_num_.fetch_add(1);
+        return obj;
+    }
+    Region* r = AllocateRegion();
+    if (r == nullptr) {
+        LOG(INFO) << "jiacheng jiacheng_cold_space.cc 83 AllocateRegion() ColdSpace已满!";
+        return nullptr;
+    }
+    current_region_ = r;
+    obj = current_region_->Alloc(num_bytes);
+    if (obj != nullptr) {
+        allocated_obj_num_.fetch_add(1);
+    }
+    return obj;
+}
+
+Region* ColdSpace::AllocateRegion() {
+    if (top_region_idx_ >= num_regions_) {
+        return nullptr;
+    }
+    return &regions_[top_region_idx_++];
+}
+
+void ColdSpace::SwapOut() {
+    // if (madvice_top_region_idx_ < top_region_idx_ - 1) { // 把Current之前的Region进行Swap
+    //     uint8_t* begin = regions_[madvice_top_region_idx_].Begin();
+    //     uint8_t* end = regions_[top_region_idx_ - 2].End();
+    //     LOG(INFO) << "jiacheng jiacheng_cold_space.cc 111 begin= " << size_t(begin) << " end= " << size_t(end) 
+    //               << " madvice_top_region_idx_= " << madvice_top_region_idx_
+    //               << " top_region_idx_= " << top_region_idx_;
+    //     madvise(begin, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(begin) - 1, 233);
+    //     madvice_top_region_idx_ = top_region_idx_ - 1;
+    // }
+    if (0 < top_region_idx_ - 1) { // 把Current之前的Region进行Swap
+        uint8_t* begin = regions_[0].Begin();
+        uint8_t* end = regions_[top_region_idx_ - 2].End();
+        LOG(INFO) << "jiacheng jiacheng_cold_space.cc 111 begin= " << size_t(begin) << " end= " << size_t(end) 
+                  << " madvice_top_region_idx_= " << madvice_top_region_idx_
+                  << " top_region_idx_= " << top_region_idx_;
+        madvise(begin, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(begin) - 1, 233);
+        // madvice_top_region_idx_ = top_region_idx_ - 1;
+    }
+}
+
+bool ColdSpace::HasAddress(mirror::Object* obj) const {
+    const uint8_t* byte_ptr = reinterpret_cast<const uint8_t*>(obj);
+    return byte_ptr >= Begin() && byte_ptr < End();
+}
+
+bool ColdSpace::GetMarkBitmap(mirror::Object* to_ref) {
+    return mark_bitmap_.find(to_ref) != remembered_set_.end();
+}
+
+void ColdSpace::SetMarkBitmap(mirror::Object* to_ref) {
+    mark_bitmap_.insert(to_ref);
+}
+
+void ColdSpace::ResetMarkBitmap() {
+    mark_bitmap_.clear();
+}
+
+void ColdSpace::AddRememberedSet(mirror::Object* obj) {
+    remembered_set_.insert(obj);
+}
+
+// 把Obj对象中包含的所有引用加入的根集
+void ColdSpace::AddRememberedRootSet(mirror::Object* obj) {
+    remembered_root_stack_.push_back(obj);
+}
+
+// 得到GC之前的根集合
+std::vector<mirror::Object*>* ColdSpace::GetRememberedRootStack() {
+    return &(remembered_root_stack_);
+}
+
+
+} // namespace jiacheng
+} // namespace art
diff --git a/runtime/jiacheng_cold_space.h b/runtime/jiacheng_cold_space.h
new file mode 100644
index 0000000000..46e8242bcb
--- /dev/null
+++ b/runtime/jiacheng_cold_space.h
@@ -0,0 +1,103 @@
+#ifndef JIACHENG_COLD_SPACE_H_
+#define JIACHENG_COLD_SPACE_H_
+
+#include <atomic>
+#include "base/mutex.h"
+
+namespace art{
+
+namespace mirror {
+class Object;
+}  // namespace mirror
+
+class MemMap;
+
+// ------------ START -------------
+namespace jiacheng {
+
+class Region;
+
+class ColdSpace {
+public: 
+  ColdSpace(MemMap* mem_map);
+  ~ColdSpace();
+
+  static Mutex singleton_lock_;
+  static ColdSpace* cold_space_; 
+
+  static ColdSpace* Create();
+  static ColdSpace* Current();
+
+  void JiachengDebug();
+
+  mirror::Object* Alloc(size_t num_bytes);
+
+  Region* AllocateRegion();
+
+  void SwapOut();
+
+  bool HasAddress(mirror::Object* obj) const;
+
+  bool GetMarkBitmap(mirror::Object* to_ref);
+
+  void SetMarkBitmap(mirror::Object* to_ref);
+
+  void ResetMarkBitmap();
+
+  void AddRememberedSet(mirror::Object* obj);
+
+  void AddRememberedRootSet(mirror::Object* obj);
+
+  std::vector<mirror::Object*>* GetRememberedRootStack();
+
+  uint8_t* Begin() const {
+    return begin_;
+  }
+
+  uint8_t* End() const {
+    return end_;
+  }
+
+  size_t GetAllocatedObjNum() const {
+    return allocated_obj_num_.load();
+  }
+
+
+  // ---------------- 变量开始 ----------------------
+  // Object alignment within the space.
+  static constexpr size_t kAlignment = kObjectAlignment;
+  // The region size.
+  static constexpr size_t kRegionSize = 4 * KB;
+  // The capacity size.
+  static constexpr size_t kCapacitySize = kRegionSize * 1024 * 100; // 400MB
+
+  Mutex region_lock_;
+
+  MemMap* mem_map_;
+
+  uint8_t* begin_;
+  uint8_t* end_;
+
+  std::unique_ptr<Region[]> regions_;
+
+  size_t num_regions_;             
+
+  size_t top_region_idx_;
+
+  Region* current_region_;         
+
+  size_t madvice_top_region_idx_;
+
+  std::atomic<size_t> allocated_obj_num_;
+
+  std::set<mirror::Object*> mark_bitmap_;
+
+  std::set<mirror::Object*> remembered_set_;
+
+  std::vector<mirror::Object*> remembered_root_stack_;
+};
+
+
+} // namespace jiacheng
+} // namespace art
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_hack.cc b/runtime/jiacheng_hack.cc
new file mode 100644
index 0000000000..f44515e7f0
--- /dev/null
+++ b/runtime/jiacheng_hack.cc
@@ -0,0 +1,594 @@
+#include <fstream>
+#include <thread>
+#include <chrono>
+#include <atomic>
+#include <sys/mman.h>
+#include <string>
+
+#include "jiacheng_hack.h"
+#include "jiacheng_cold_space.h"
+#include "jiacheng_activity_manager.h"
+
+#include "gc/accounting/card_table.h"
+#include "gc/space/space-inl.h"
+#include "gc/heap.h"
+#include "gc/space/zygote_space.h"
+#include "gc/space/bump_pointer_space-inl.h"
+#include "gc/space/bump_pointer_space-walk-inl.h"
+#include "gc/space/dlmalloc_space-inl.h"
+#include "gc/space/image_space.h"
+#include "gc/space/large_object_space.h"
+#include "gc/space/malloc_space.h"
+#include "gc/space/region_space-inl.h"
+#include "gc/space/rosalloc_space-inl.h"
+#include "mirror/class-inl.h"
+#include "obj_ptr-inl.h"
+#include "scoped_thread_state_change-inl.h"
+#include "thread_list.h"
+#include "gc/accounting/mod_union_table-inl.h"
+#include "gc/accounting/remembered_set.h"
+#include "base/mutex.h"
+
+#include "read_barrier_config.h"
+
+namespace art{
+namespace jiacheng {
+
+static std::set<mirror::Object*> read_set;
+static Mutex read_set_lock("read_set_lock", kLoggingLock);
+
+static std::set<mirror::Object*> gc_set;
+static Mutex gc_set_lock("gc_set_lock", kLoggingLock);
+
+void Debug() {
+    ColdSpace::Current()->JiachengDebug();
+    ActivityManager::Current()->JiachengDebug();
+
+    Runtime* runtime = Runtime::Current();
+    gc::Heap* heap = runtime->GetHeap();
+
+    heap->JiachengDebug();
+}
+
+
+/*
+ * 每次GC开始的时候，调用该方法
+ */
+void BeforeGarbageCollectorRun(const gc::collector::GarbageCollector* collector) {
+    LOG(INFO) << "jiacheng" << " BeforeGarbageCollectorRun" 
+              << " NanoTime: " << NanoTime()
+              << " GarbageCollector.name_ " << collector->GetName()
+              << " GetGcType()" << collector->GetGcType();
+
+    ActivityManager* activity_manager = ActivityManager::Current();
+    activity_manager->SetSampling(false);
+    activity_manager->SetInGC(true);
+
+    Thread* self = Thread::Current();
+    read_set_lock.ExclusiveLock(self);
+    LOG(INFO) << "jiacheng " << __FILE__ << __LINE__
+              << " read_set.size()= " << read_set.size();
+    read_set_lock.ExclusiveUnlock(self);
+    
+    read_set_lock.ExclusiveLock(self);
+    read_set.clear();
+    read_set_lock.ExclusiveUnlock(self);
+    gc_set_lock.ExclusiveLock(self);
+    gc_set.clear();
+    gc_set_lock.ExclusiveUnlock(self);
+}
+
+/*
+ * 每次GC结束的时候，调用该方法
+ */
+void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector) {
+    // ActivityManager* activity_manager = ActivityManager::Current();
+    // activity_manager->SetSampling(true);
+    // activity_manager->SetInGC(false);
+    // activity_manager->IncGCTime();
+
+    // Debug();
+    // SwapOut();
+    // activity_manager->ForgetWorkingSet();
+    // ColdSpace::Current()->ResetMarkBitmap();
+    const gc::collector::Iteration* iteration = collector->GetCurrentIteration();
+    
+    LOG(INFO) << "jiacheng" << " AfterGarbageCollectorRun" 
+              << " NanoTime: " << NanoTime()
+              << " GcCause: " << iteration->GetGcCause()
+              << " GetGcType()" << collector->GetGcType();  
+
+    Thread* self = Thread::Current();
+    gc_set_lock.ExclusiveLock(self);
+    LOG(INFO) << "jiacheng " << __FILE__ << __LINE__
+              << " gc_set.size()= " << gc_set.size();
+    gc_set_lock.ExclusiveUnlock(self);
+
+    read_set_lock.ExclusiveLock(self);
+    read_set.clear();
+    read_set_lock.ExclusiveUnlock(self);
+    gc_set_lock.ExclusiveLock(self);
+    gc_set.clear();
+    gc_set_lock.ExclusiveUnlock(self);
+}
+
+/*
+ * 每次发生读屏障的时候，调用该方法
+ */
+
+void ReaderBarrierTrigger(mirror::Object* obj) {
+    // (void)obj;
+    if (Runtime::Current()->IsZygote()) {
+        return;
+    }
+    // if (!Runtime::Current()->InJankPerceptibleProcessState()) {
+    //     return;
+    // }
+    Thread* self = Thread::Current();
+
+    read_set_lock.ExclusiveLock(self);
+    read_set.insert(obj);
+    read_set_lock.ExclusiveUnlock(self);
+
+//     // com.jiacheng.activitylifecycletest = 34
+//     // com.taobao.taobao = 17
+    // const std::string& package_name = Runtime::Current()->GetProcessPackageName();
+    // if (!(package_name.length() == 17 && package_name[4] == 't')) { 
+    //     return;
+    // }
+    // ActivityManager::Current()->RecordWS(obj);
+
+//     LOG(INFO) << "jiacheng ReaderBarrierTrigger "
+//               << "obj= " << reinterpret_cast<size_t>(obj) << ' '
+//               << "offset= " << reinterpret_cast<size_t>(offset) << ' '
+//               << "ref= " << reinterpret_cast<size_t>(ref_addr) << ' '
+//               << "GetProcessPackageName= " << Runtime::Current()->GetProcessPackageName() << ' ';
+
+}
+
+void GCMarkTrigger(mirror::Object* obj) {
+    if (Runtime::Current()->IsZygote()) {
+        return;
+    }
+    Thread* self = Thread::Current();
+
+    gc_set_lock.ExclusiveLock(self);
+    gc_set.insert(obj);
+    gc_set_lock.ExclusiveUnlock(self);
+}
+
+
+
+/* 
+ * AMS通过在系统启动的时候注册的service调用该函数
+ * enum ActivityState {
+ *     INITIALIZING, 0
+ *     RESUMED, 1
+ *     PAUSING, 2
+ *     PAUSED, 3 
+ *     STOPPING, 4
+ *     STOPPED, 5
+ *     FINISHING, 6
+ *     DESTROYING, 7
+ *     DESTROYED 8
+ *}
+ */
+void UpdateActivityState(const char* package_name, const char* activity_name, int state) { 
+    (void)package_name;
+    std::string name(activity_name);
+    ActivityManager::Current()->UpdateActivityState(name, state);
+}
+
+/*
+ * 在App启动的main函数中调用该函数
+ */
+void OnAppStart() {
+    LOG(INFO) << "jiacheng jiacheng_hack.cc 127 OnAppStart()";
+    // auto func = []()->void {
+    //     ActivityManager* activity_manager = ActivityManager::Current();
+    //     for (;;) {
+    //         if (!activity_manager->GetInGC()) {
+    //             SwapOut();
+    //             LOG(INFO) << "jiacheng jiacheng_hack.cc 144 执行换出!";
+    //         }
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //         CurrentThreadSleepNano(1000000000);
+    //     }
+    // };
+    // std::thread on_app_start_thread(func);
+    // on_app_start_thread.detach();
+}
+
+// 对ColdSpace中的Region进行Swap
+void SwapOut() {
+    if (Runtime::Current()->IsZygote()) {
+        return;
+    }
+    // if (activity_set.size() < 2 || GC_time.load() < 10) {
+    //     return;
+    // }
+    if (Runtime::Current()->InJankPerceptibleProcessState()) {
+        return;
+    }
+    // com.jiacheng.activitylifecycletest = 34
+    // com.taobao.taobao = 17
+    // const std::string& package_name = Runtime::Current()->GetProcessPackageName();
+    // if (!(package_name.length() == 17 && package_name[4] == 't')) { 
+    //     return;
+    // }
+
+    // 对所有Space中的对象进行Swap
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    Thread* self = Thread::Current();
+    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
+    {
+        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
+        continues_spaces = &(heap->GetContinuousSpaces());
+    }
+    for (auto space : *continues_spaces) {
+        LOG(INFO) << "jiacheng_hack.cc 185 SwapOut() continues_spaces " << space->GetName();
+        madvise(space->Begin(), space->Size(), 233);
+        // SwapOutSpace(space);
+    }
+    const std::vector<gc::space::DiscontinuousSpace*>& discontinues_spaces = heap->GetDiscontinuousSpaces();
+    for (auto space : discontinues_spaces) {
+        SwapOutSpace(space);
+    }    
+
+    // 不直接使用SwapOutSpace()函数对所有Space中的对象进行Swap
+    // LOG(INFO) << "jiacheng jiacheng_hack.cc 180 SwapOut()";
+    // ColdSpace* cold_space = ColdSpace::Current();
+    // cold_space->SwapOut();
+}
+
+
+void CurrentThreadSleepNano(const unsigned long n) {
+    std::this_thread::sleep_for(std::chrono::nanoseconds(n));
+}
+
+// 防止某个操作过于频繁
+bool CheckHot() {
+    static std::atomic<uint64_t> last_time(0);
+    uint64_t get_last_time = last_time.load();
+    uint64_t this_time = art::NanoTime();
+    if (this_time - get_last_time < 5000000000) {
+        return true;
+    } else {
+        last_time.store(this_time);
+        return false;
+    }
+}
+
+void SwapOutSpace(gc::space::Space* space) {
+    Thread* self = Thread::Current();
+    gc::space::SpaceType space_type = space->GetType();
+    WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* ) {
+        // if (start != end && ActivityManager::Current()->ShouldSwapOut(reinterpret_cast<mirror::Object*>(start))) {
+        if (start != end) {
+            LOG(INFO) << "jiacheng_hack.cc 143 ShouldSwapOut() obj= " << size_t(start) << " size= " << size_t(end) - size_t(start);
+            madvise(start, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start), 233);
+        }
+    };    
+    auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_){
+        // if (obj && ActivityManager::Current()->ShouldSwapOut(obj)) {
+        if (obj) {
+            LOG(INFO) << "jiacheng_hack.cc 150 ShouldSwapOut() obj= " << size_t(obj) << " size= " << obj->SizeOf();
+            madvise(static_cast<void *>(obj), obj->SizeOf(), 233);
+        }
+    };
+    switch (space_type) {
+        case gc::space::kSpaceTypeImageSpace: {
+            // gc::space::ImageSpace* this_space = space->AsImageSpace();
+            break;
+        }
+        case gc::space::kSpaceTypeMallocSpace: {
+            gc::space::MallocSpace* this_space = space->AsMallocSpace();
+            this_space->Walk(walk_callback, nullptr);
+            break;
+        }
+        case gc::space::kSpaceTypeZygoteSpace: {
+            // gc::space::ZygoteSpace* this_space = space->AsZygoteSpace();
+            break;
+        }
+        case gc::space::kSpaceTypeBumpPointerSpace: {
+            gc::space::BumpPointerSpace* this_space = space->AsBumpPointerSpace();
+            { 
+                WriterMutexLock mu(self, *Locks::mutator_lock_);  
+                this_space -> Walk(visitor);
+            }
+            break;
+        }
+        case gc::space::kSpaceTypeLargeObjectSpace: {
+            gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
+            this_space->Walk(walk_callback, nullptr);
+            break;
+        }
+        case gc::space::kSpaceTypeRegionSpace: {
+            gc::space::RegionSpace* this_space = space->AsRegionSpace();   
+            {
+                WriterMutexLock mu(self, *Locks::mutator_lock_);  
+                this_space -> Walk(visitor);
+            }
+            break;
+        }
+        default:
+            LOG(INFO) << "jiacheng " << "jiacheng_hack.cc 100. Can not find space.";
+    }
+}
+
+// ------------------- static ---------------------
+
+void PrintProcStat() {
+    static std::ifstream stat;
+    static std::string line;
+    stat.open("/proc/stat");
+    if (!stat.is_open()) {
+        LOG(INFO) << "jiacheng" << " /proc/stat can not open!";
+    } else {
+        while(getline(stat, line)) {
+            LOG(INFO) << "jiacheng " << line;
+        }
+        stat.close();
+    }
+
+}
+
+void PrintProcStat(const char* info) {
+    static std::ifstream stat;
+    static std::string line;
+    stat.open("/proc/stat");
+    if (!stat.is_open()) {
+        LOG(INFO) << "jiacheng" << " /proc/stat can not open!";
+    } else {
+        while(getline(stat, line)) {
+            LOG(INFO) << "jiacheng " << info << ' ' << line;
+        }
+        stat.close();
+    }
+}
+
+bool ExistSwap() {
+    static bool exist;
+    static std::ifstream stat;
+    static std::string line;
+    int line_number = 0;
+    if (exist) {
+        return true;
+    }
+    stat.open("/proc/swaps");
+    if (!stat.is_open()) {
+        LOG(INFO) << "jiacheng" << " /proc/swaps can not open!";
+    } else {
+        while(getline(stat, line)) {
+            line_number++;
+            if (line_number > 1) {
+                exist = true;
+                break;
+            }
+        }
+        stat.close();
+    }
+    return exist;
+}
+
+void VisitSpace(gc::space::Space* space) {
+    gc::space::SpaceType space_type = space->GetType();
+    Thread* self = Thread::Current();
+    WalkCallback walk_callback = [](void *start, void *end, size_t num_bytes, void* ) {
+        LOG(INFO) << "jiacheng " << "start= " << start << ' ' << "end= " << end << ' ' << "num_bytes= " << num_bytes;
+    };    
+    auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_){
+        if (!obj) {
+            LOG(INFO) << "jiacheng Object=Null";
+            return; 
+        }
+        LOG(INFO) << "jiacheng Object= " << obj << " Size= " << obj->SizeOf() << " Type= " << obj->PrettyTypeOf();
+    };
+    switch (space_type) {
+        case gc::space::kSpaceTypeImageSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "ImageSpace: ";
+            gc::space::ImageSpace* this_space = space->AsImageSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            break;
+        }
+        case gc::space::kSpaceTypeMallocSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "MallocSpace: ";
+            gc::space::MallocSpace* this_space = space->AsMallocSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            this_space->Walk(walk_callback, nullptr);
+            break;
+        }
+        case gc::space::kSpaceTypeZygoteSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "ZygoteSpace: ";
+            gc::space::ZygoteSpace* this_space = space->AsZygoteSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            break;
+        }
+        case gc::space::kSpaceTypeBumpPointerSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "BumpPointerSpace: ";
+            gc::space::BumpPointerSpace* this_space = space->AsBumpPointerSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            {
+                ReaderMutexLock mu(self, *Locks::mutator_lock_);   
+                this_space->Walk(visitor);
+            }
+            break;
+        }
+        case gc::space::kSpaceTypeLargeObjectSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "LargeObjectSpace: ";
+            gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            this_space->Walk(walk_callback, nullptr);
+            break;
+        }
+        case gc::space::kSpaceTypeRegionSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "RegionSpace: ";
+            gc::space::RegionSpace* this_space = space->AsRegionSpace();   
+            this_space->Dump(LOG_STREAM(INFO));
+            {
+                WriterMutexLock mu(self, *Locks::mutator_lock_);           
+                this_space->Walk(visitor);
+            }
+            break;
+        }
+        default:
+            LOG(INFO) << "jiacheng " << "jiacheng_hack.cc 100. Can not find space.";
+    }
+}
+
+void VisitHeap(const gc::Heap* heap) {
+    Thread* self = Thread::Current();
+    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
+    {
+        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
+        continues_spaces = &(heap->GetContinuousSpaces());
+    }
+    for (auto space : *continues_spaces) {
+        VisitSpace(space);
+    }
+    const std::vector<gc::space::DiscontinuousSpace*>& discontinues_spaces = heap->GetDiscontinuousSpaces();
+    for (auto space : discontinues_spaces) {
+        VisitSpace(space);
+    }    
+}
+
+
+void VisitMemMap(const MemMap* mem_map) {
+    LOG(INFO) << "jiacheng VisitMemMap ";
+    LOG(INFO) << (*mem_map);
+    uint8_t* begin = mem_map->Begin();
+    uint8_t* end = mem_map->End();
+    void* base_begin = mem_map->BaseBegin();
+    void* base_end = mem_map->BaseEnd();
+    LOG(INFO) << "begin= " << reinterpret_cast<size_t>(begin) << ' '
+              << "end= " << reinterpret_cast<size_t>(end) << ' '
+              << "base_begin= " << reinterpret_cast<size_t>(base_begin) << ' '
+              << "base_end= " << reinterpret_cast<size_t>(base_end);
+    // print every byte
+    // for(uint8_t* p = begin; p != end; ++p) {
+    //     LOG(INFO) << static_cast<int>(*p);
+    // }
+
+}
+
+template<size_t kAlignment>
+void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* ) {
+}
+
+void VisitHeapBitmap(const gc::accounting::HeapBitmap* ) {
+}
+
+void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set) {
+    LOG(INFO) << "jiacheng VisitRememberedSet ";
+    auto table = const_cast<gc::accounting::RememberedSet*>(remembered_set);
+    {
+        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
+        table->Dump(LOG_STREAM(INFO));
+    }
+
+}
+
+void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table) {
+    LOG(INFO) << "jiacheng VisitModUnionTableToZygoteAllocspace ";
+    auto table = const_cast<gc::accounting::ModUnionTableToZygoteAllocspace*>(static_cast<const gc::accounting::ModUnionTableToZygoteAllocspace*>(mod_union_table));
+    {
+        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
+        table->Dump(LOG_STREAM(INFO));
+    }
+}
+
+void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table) {
+    LOG(INFO) << "jiacheng VisitModUnionTableCardCache ";
+    auto table = const_cast<gc::accounting::ModUnionTableCardCache*>(static_cast<const gc::accounting::ModUnionTableCardCache*>(mod_union_table));
+    {
+        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
+        table->Dump(LOG_STREAM(INFO));
+    }
+}
+
+void VisitCardTable(const gc::accounting::CardTable* card_table) {
+    (void)card_table;
+    LOG(INFO) << "jiacheng VisitCardTable ";
+    // MemMap* mem_map = &(card_table->mem_map_);
+    // uint8_t* const biased_begin = card_table->biased_begin_;
+    // const size_t offset = card_table->offset_;
+
+    // VisitMemMap(mem_map);
+    // LOG(INFO) << "biased_begin= " << reinterpret_cast<size_t>(biased_begin);
+    // LOG(INFO) << "offset= " << offset;
+}
+
+void DebugPrintModUnionAndRememberSet() {
+    if (Runtime::Current()->IsZygote()) {
+        return;
+    }
+    if (!Runtime::Current()->InJankPerceptibleProcessState()) {
+      LOG(INFO) << "jiacheng " << "InJankPerceptibleProcessState" ;
+      return;
+    }
+    // if (jiacheng::CheckHot()) {
+    //   LOG(INFO) << "jiacheng " << "CheckHot";
+    //   return;
+    // }  
+    if (!jiacheng::ExistSwap()) {
+      return;
+    }
+
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    VisitHeap(heap);
+
+    Thread* self = Thread::Current();
+    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
+    {
+        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
+        continues_spaces = &(heap->GetContinuousSpaces());
+    }
+    for (auto space : *continues_spaces) {
+        LOG(INFO) << space->GetName();
+        gc::space::SpaceType space_type = space->GetType();
+        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
+        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
+        if (mod_union_table) {
+            LOG(INFO) << "jiacheng mod_union_table";
+            if (space_type == gc::space::kSpaceTypeZygoteSpace) {
+                VisitModUnionTableCardCache(mod_union_table);
+            } else if (space_type == gc::space::kSpaceTypeImageSpace) {
+                VisitModUnionTableToZygoteAllocspace(mod_union_table);
+            }
+        } 
+        if (remembered_set) {
+            LOG(INFO) << "jiacheng remembered_set";
+            VisitRememberedSet(remembered_set);
+        }
+        if (mod_union_table == nullptr && remembered_set == nullptr) {
+            LOG(INFO) << "nullptr";
+        }
+    }
+    const std::vector<gc::space::DiscontinuousSpace*>* discontinues_spaces = &(heap->GetDiscontinuousSpaces());
+    for (auto space : *discontinues_spaces) {
+        LOG(INFO) << space->GetName();
+        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
+        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
+        if (mod_union_table) {
+            LOG(INFO) << "jiacheng mod_union_table";
+        } 
+        if (remembered_set) {
+            LOG(INFO) << "jiacheng remembered_set";
+        }
+        if (mod_union_table == nullptr && remembered_set == nullptr) {
+            LOG(INFO) << "nullptr";
+        }
+    }
+}
+
+} // namespace jiacheng
+} // namespace art
diff --git a/runtime/jiacheng_hack.h b/runtime/jiacheng_hack.h
new file mode 100644
index 0000000000..76ec57dd47
--- /dev/null
+++ b/runtime/jiacheng_hack.h
@@ -0,0 +1,104 @@
+#ifndef JIACHENG_HACK_H_
+#define JIACHENG_HACK_H_
+
+#include <set>
+
+namespace art{
+
+namespace gc {
+namespace accounting {
+template<size_t kAlignment> class SpaceBitmap;
+class HeapBitmap;
+class RememberedSet;
+class ModUnionTable;
+class CardTable;
+} // namespace accounting
+
+namespace space {
+class Space;
+class ImageSpace;
+class MallocSpace;
+class ZygoteSpace;
+class BumpPointerSpace;
+class LargeObjectSpace;
+class RegionSpace;
+} // namespace space
+
+namespace collector {
+class GarbageCollector;
+} // namespace collector
+
+class Heap;
+
+} // namespace gc
+
+namespace mirror {
+class Class;
+class Object;
+template<class T> class ObjectArray;
+}  // namespace mirror
+
+class Thread;
+class MemMap;
+class MemberOffset;
+
+// ------------ START -------------
+namespace jiacheng {
+
+typedef void(*WalkCallback)(void *start, void *end, size_t num_bytes, void* callback_arg);
+
+void Debug();
+
+void BeforeGarbageCollectorRun(const gc::collector::GarbageCollector* collector);
+
+void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector);
+
+void ReaderBarrierTrigger(mirror::Object* obj);
+
+void GCMarkTrigger(mirror::Object* obj);
+
+void UpdateActivityState(const char* package_name, const char* activity_name, int state);
+
+void OnAppStart();
+
+void SwapOut();
+
+void CurrentThreadSleepNano(const unsigned long n);
+
+bool CheckHot();
+
+void SwapOutSpace(gc::space::Space* space);
+
+// -------------- DEGUB ----------
+
+void PrintProcStat();
+
+void PrintProcStat(const char* info);
+
+bool ExistSwap();
+
+void VisitSpace(gc::space::Space* space);
+
+void VisitHeap(const gc::Heap* heap);
+
+void VisitMemMap(const MemMap* mem_map);
+
+template<size_t kAlignment>
+void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* );
+
+void VisitHeapBitmap(const gc::accounting::HeapBitmap* );
+
+void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set);
+
+void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table);
+
+void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table);
+
+void VisitCardTable(const gc::accounting::CardTable* card_table);
+
+void DebugPrintModUnionAndRememberSet();
+
+
+} // namespace jiacheng
+} // namespace art
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_region.cc b/runtime/jiacheng_region.cc
new file mode 100644
index 0000000000..fd954565e8
--- /dev/null
+++ b/runtime/jiacheng_region.cc
@@ -0,0 +1,41 @@
+#include "jiacheng_region.h"
+
+namespace art {
+namespace jiacheng {
+
+Region::Region():idx_(-1),begin_(nullptr),top_(nullptr),end_(nullptr) {
+}
+
+Region::~Region() {}
+
+void Region::Init(size_t idx, uint8_t* begin, uint8_t* end) {
+    idx_ = idx;
+    begin_ = begin;
+    top_.store(begin);
+    end_ = end;
+}
+
+mirror::Object* Region::Alloc(size_t num_bytes) {
+    uint8_t* old_top;
+    uint8_t* new_top;
+
+    old_top = top_.load();
+    new_top = old_top + num_bytes;
+    if (new_top > end_) {
+        return nullptr;
+    }
+    top_.store(new_top);
+    return reinterpret_cast<mirror::Object*>(old_top);
+}
+
+void Region::Clear() {
+    top_.store(begin_);
+}
+
+bool Region::IsFree() const {
+    return top_.load() == begin_;
+}
+
+
+} // namespace jiacheng
+} // namespace art
\ No newline at end of file
diff --git a/runtime/jiacheng_region.h b/runtime/jiacheng_region.h
new file mode 100644
index 0000000000..fedfb28994
--- /dev/null
+++ b/runtime/jiacheng_region.h
@@ -0,0 +1,59 @@
+#ifndef JIACHENG_REGION_H_
+#define JIACHENG_REGION_H_
+
+#include <atomic>
+
+namespace art{
+namespace mirror {
+    class Object;
+}
+
+// ------------ START -------------
+namespace jiacheng {
+
+class Region {
+public:
+    Region();
+    ~Region();
+
+    void Init(size_t idx, uint8_t* begin, uint8_t* end);
+
+    mirror::Object* Alloc(size_t num_bytes);
+
+    void Clear();
+
+    bool IsFree() const;
+
+    size_t Idx() const {
+        return idx_;
+    }
+
+    uint8_t* Begin() const {
+        return begin_;
+    }
+
+    uint8_t* Top() const {
+        return top_.load();
+    }
+
+    uint8_t* End() const {
+        return end_;
+    }
+
+    bool Contains(mirror::Object* ref) const {
+        return begin_ <= reinterpret_cast<uint8_t*>(ref) && reinterpret_cast<uint8_t*>(ref) < end_;
+    }
+
+// ---------------- 变量开始 ----------------------
+
+    size_t idx_;                        // 该Region在ColdSpace中的索引
+    uint8_t* begin_;                    // 这个Region的起始地址
+    std::atomic<uint8_t*> top_;         // Allocation的位置
+    uint8_t* end_;                      // 这个Region的结束地址
+
+};
+
+
+} // namespace jiacheng
+} // namespace art
+#endif
\ No newline at end of file
diff --git a/runtime/native/dalvik_system_VMRuntime.cc b/runtime/native/dalvik_system_VMRuntime.cc
index 399813c60e..0557da0b16 100644
--- a/runtime/native/dalvik_system_VMRuntime.cc
+++ b/runtime/native/dalvik_system_VMRuntime.cc
@@ -62,6 +62,10 @@ extern "C" void android_set_application_target_sdk_version(uint32_t version);
 #include "thread_list.h"
 #include "well_known_classes.h"
 
+// jiacheng start
+#include "jiacheng_hack.h"
+// jiacheng end
+
 namespace art {
 
 using android::base::StringPrintf;
@@ -321,6 +325,25 @@ static void VMRuntime_updateProcessState(JNIEnv*, jobject, jint process_state) {
   runtime->UpdateProcessState(static_cast<ProcessState>(process_state));
 }
 
+// jiacheng start
+static void VMRuntime_jiachengUpdateActivityState(JNIEnv* env, jobject, 
+                                                  jstring package_name, 
+                                                  jstring activity_name, 
+                                                  jint state) {
+  (void)env;
+  (void)package_name;
+  (void)activity_name;
+  (void)state;
+  // const char* raw_package_name = env->GetStringUTFChars(package_name, nullptr);
+  // const char* raw_activity_name = env->GetStringUTFChars(activity_name, nullptr);
+  // jiacheng::UpdateActivityState(raw_package_name, raw_activity_name, static_cast<int>(state));
+}
+
+static void VMRuntime_jiachengAppStart(JNIEnv*, jobject) {
+  jiacheng::OnAppStart();
+}
+// jiacheng end
+
 static void VMRuntime_notifyStartupCompleted(JNIEnv*, jobject) {
   Runtime::Current()->NotifyStartupCompleted();
 }
@@ -754,6 +777,10 @@ static JNINativeMethod gMethods[] = {
   NATIVE_METHOD(VMRuntime, requestHeapTrim, "()V"),
   NATIVE_METHOD(VMRuntime, runHeapTasks, "()V"),
   NATIVE_METHOD(VMRuntime, updateProcessState, "(I)V"),
+  // jiacheng start
+  NATIVE_METHOD(VMRuntime, jiachengUpdateActivityState, "(Ljava/lang/String;Ljava/lang/String;I)V"),
+  NATIVE_METHOD(VMRuntime, jiachengAppStart, "()V"),
+  // jiacheng end
   NATIVE_METHOD(VMRuntime, startHeapTaskProcessor, "()V"),
   NATIVE_METHOD(VMRuntime, startJitCompilation, "()V"),
   NATIVE_METHOD(VMRuntime, stopHeapTaskProcessor, "()V"),
diff --git a/runtime/read_barrier-inl.h b/runtime/read_barrier-inl.h
index 1bcbcff08c..1649bbe70e 100644
--- a/runtime/read_barrier-inl.h
+++ b/runtime/read_barrier-inl.h
@@ -27,6 +27,10 @@
 #include "mirror/reference.h"
 #include "runtime.h"
 
+// jiacheng start
+#include "jiacheng_hack.h"
+// jiacheng end
+
 namespace art {
 
 // Disabled for performance reasons.
@@ -71,10 +75,18 @@ inline MirrorType* ReadBarrier::Barrier(
         }
       }
       AssertToSpaceInvariant(obj, offset, ref);
+      // jiacheng start
+      jiacheng::ReaderBarrierTrigger(ref);
+      // jiacheng end
       return ref;
     } else if (kUseBrooksReadBarrier) {
       // To be implemented.
-      return ref_addr->template AsMirrorPtr<kIsVolatile>();
+      // jiacheng start
+      MirrorType* ref = ref_addr->template AsMirrorPtr<kIsVolatile>();
+      // return ref_addr->template AsMirrorPtr<kIsVolatile>();
+      jiacheng::ReaderBarrierTrigger(ref);
+      return ref;
+      // jiacheng end
     } else if (kUseTableLookupReadBarrier) {
       MirrorType* ref = ref_addr->template AsMirrorPtr<kIsVolatile>();
       MirrorType* old_ref = ref;
@@ -92,6 +104,9 @@ inline MirrorType* ReadBarrier::Barrier(
         }
       }
       AssertToSpaceInvariant(obj, offset, ref);
+      // jiacheng start
+      jiacheng::ReaderBarrierTrigger(ref);
+      // jiacheng end
       return ref;
     } else {
       LOG(FATAL) << "Unexpected read barrier type";
@@ -99,7 +114,12 @@ inline MirrorType* ReadBarrier::Barrier(
     }
   } else {
     // No read barrier.
-    return ref_addr->template AsMirrorPtr<kIsVolatile>();
+    // jiacheng start
+    // return ref_addr->template AsMirrorPtr<kIsVolatile>();
+    MirrorType* ref = ref_addr->template AsMirrorPtr<kIsVolatile>();
+    jiacheng::ReaderBarrierTrigger(ref);
+    return ref;
+    // jiacheng end
   }
 }
 
@@ -122,9 +142,15 @@ inline MirrorType* ReadBarrier::BarrierForRoot(MirrorType** root,
         ref = reinterpret_cast<MirrorType*>(Mark(ref));
       }
       AssertToSpaceInvariant(gc_root_source, ref);
+      // jiacheng start
+      jiacheng::ReaderBarrierTrigger(ref);
+      // jiacheng end
       return ref;
     } else if (kUseBrooksReadBarrier) {
       // To be implemented.
+      // jiacheng start
+      jiacheng::ReaderBarrierTrigger(ref);
+      // jiacheng end
       return ref;
     } else if (kUseTableLookupReadBarrier) {
       Thread* self = Thread::Current();
@@ -140,12 +166,18 @@ inline MirrorType* ReadBarrier::BarrierForRoot(MirrorType** root,
         }
       }
       AssertToSpaceInvariant(gc_root_source, ref);
+      // jiacheng start
+      jiacheng::ReaderBarrierTrigger(ref);
+      // jiacheng end
       return ref;
     } else {
       LOG(FATAL) << "Unexpected read barrier type";
       UNREACHABLE();
     }
   } else {
+    // jiacheng start
+    jiacheng::ReaderBarrierTrigger(ref);
+    // jiacheng end
     return ref;
   }
 }
@@ -163,9 +195,15 @@ inline MirrorType* ReadBarrier::BarrierForRoot(mirror::CompressedReference<Mirro
       ref = reinterpret_cast<MirrorType*>(Mark(ref));
     }
     AssertToSpaceInvariant(gc_root_source, ref);
+    // jiacheng start
+    jiacheng::ReaderBarrierTrigger(ref);
+    // jiacheng end
     return ref;
   } else if (with_read_barrier && kUseBrooksReadBarrier) {
     // To be implemented.
+    // jiacheng start
+    jiacheng::ReaderBarrierTrigger(ref);
+    // jiacheng end
     return ref;
   } else if (with_read_barrier && kUseTableLookupReadBarrier) {
     Thread* self = Thread::Current();
@@ -183,8 +221,14 @@ inline MirrorType* ReadBarrier::BarrierForRoot(mirror::CompressedReference<Mirro
       }
     }
     AssertToSpaceInvariant(gc_root_source, ref);
+    // jiacheng start
+    jiacheng::ReaderBarrierTrigger(ref);
+    // jiacheng end
     return ref;
   } else {
+    // jiacheng start
+    jiacheng::ReaderBarrierTrigger(ref);
+    // jiacheng end
     return ref;
   }
 }
-- 
2.34.1


From 3c18ed55178a9f8c2baef43342efc2a16ff93e4b Mon Sep 17 00:00:00 2001
From: jiachengh <jiacheng.huang@outlook.com>
Date: Sat, 4 Sep 2021 17:14:08 +0800
Subject: [PATCH 2/7] profiler

Change-Id: I864c8d02b4edcb3f863a707abae00578bd70f4ec
Signed-off-by: jiachengh <jiacheng.huang@outlook.com>
---
 runtime/Android.bp                         |   2 +
 runtime/base/locks.h                       |   4 +
 runtime/gc/collector/concurrent_copying.cc |  11 +-
 runtime/gc/heap.cc                         | 111 ++---
 runtime/gc/space/region_space.cc           |   4 +-
 runtime/gc/space/region_space.h            |   4 +
 runtime/jiacheng_activity_manager.cc       |  17 +-
 runtime/jiacheng_activity_manager.h        |  33 +-
 runtime/jiacheng_cold_space.cc             |   2 +-
 runtime/jiacheng_hack.cc                   | 511 +++++----------------
 runtime/jiacheng_hack.h                    |  47 +-
 runtime/jiacheng_profiler.cc               | 148 ++++++
 runtime/jiacheng_profiler.h                |  76 +++
 runtime/jiacheng_utils.cc                  | 263 +++++++++++
 runtime/jiacheng_utils.h                   |  77 ++++
 runtime/read_barrier-inl.h                 |  24 +-
 16 files changed, 766 insertions(+), 568 deletions(-)
 create mode 100644 runtime/jiacheng_profiler.cc
 create mode 100644 runtime/jiacheng_profiler.h
 create mode 100644 runtime/jiacheng_utils.cc
 create mode 100644 runtime/jiacheng_utils.h

diff --git a/runtime/Android.bp b/runtime/Android.bp
index c494be159c..80db5b4e86 100644
--- a/runtime/Android.bp
+++ b/runtime/Android.bp
@@ -111,6 +111,8 @@ libart_cc_defaults {
         "jiacheng_hack.cc",
         "jiacheng_region.cc",
         "jiacheng_activity_manager.cc",
+        "jiacheng_utils.cc",
+        "jiacheng_profiler.cc",
 // jiacheng end --------------------------------------
         "jdwp/jdwp_event.cc",
         "jdwp/jdwp_expand_buf.cc",
diff --git a/runtime/base/locks.h b/runtime/base/locks.h
index b15fd32f4d..19ed22bc0d 100644
--- a/runtime/base/locks.h
+++ b/runtime/base/locks.h
@@ -41,6 +41,10 @@ class Thread;
 // [1] http://www.drdobbs.com/parallel/use-lock-hierarchies-to-avoid-deadlock/204801163
 enum LockLevel : uint8_t {
   kLoggingLock = 0,
+  // jiacheng start
+  kJiachengWorkingSetLock,
+  kJiachengColdSpaceLock,
+  // jiacheng end
   kSwapMutexesLock,
   kUnexpectedSignalLock,
   kThreadSuspendCountLock,
diff --git a/runtime/gc/collector/concurrent_copying.cc b/runtime/gc/collector/concurrent_copying.cc
index 70c0d58882..335cdc98a4 100644
--- a/runtime/gc/collector/concurrent_copying.cc
+++ b/runtime/gc/collector/concurrent_copying.cc
@@ -50,6 +50,7 @@
 // jiacheng start
 #include "jiacheng_cold_space.h"
 #include "jiacheng_activity_manager.h"
+#include "jiacheng_profiler.h"
 #include <iostream>
 // jiacheng end
 
@@ -2207,8 +2208,8 @@ inline void ConcurrentCopying::ProcessMarkStackRef(mirror::Object* to_ref) {
       perform_scan = true;
       break;
     default:
-  // // jiacheng start ---------------------------------
-  // code in android 9 这里不能直接用
+  // jiacheng start ---------------------------------
+  // code in android 这里不能直接用
   // else if (jiacheng::ColdSpace::Current()->HasAddress(to_ref)) {
   //   jiacheng::ColdSpace* cold_space = jiacheng::ColdSpace::Current();
   //   if (!cold_space->GetMarkBitmap(to_ref)) {
@@ -2216,7 +2217,7 @@ inline void ConcurrentCopying::ProcessMarkStackRef(mirror::Object* to_ref) {
   //     Scan(to_ref);
   //   }
   // }
-  // // jiacheng end -----------------------------------
+  // jiacheng end -----------------------------------
 
       DCHECK(!region_space_->HasAddress(to_ref)) << to_ref;
       DCHECK(!immune_spaces_.ContainsObject(to_ref));
@@ -3409,10 +3410,10 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
   //     region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
   mirror::Object* to_ref = nullptr;
   if (region_space_alloc_size <= jiacheng::ColdSpace::kRegionSize &&
-      jiacheng::ActivityManager::Current()->ShouldSwapOut(from_ref)) {
+      jiacheng::Profiler::Current()->ShouldSwapOut(from_ref)) {
     to_ref = jiacheng::ColdSpace::Current()->Alloc(region_space_alloc_size);
     region_space_bytes_allocated = region_space_alloc_size;
-    LOG(INFO) << "jiacheng concurrent_copying.cc 2412 ColdSpace::Current()->Alloc()" 
+    LOG(INFO) << "jiacheng concurrent_copying.cc 3415 ColdSpace::Current()->Alloc()" 
               << " region_space_alloc_size= " << region_space_alloc_size 
               << " to_ref= " << to_ref
               << " GetAllocatedObjNum()= " << jiacheng::ColdSpace::Current()->GetAllocatedObjNum();
diff --git a/runtime/gc/heap.cc b/runtime/gc/heap.cc
index 2720f4dab9..ee8e46beea 100644
--- a/runtime/gc/heap.cc
+++ b/runtime/gc/heap.cc
@@ -724,71 +724,54 @@ Heap::Heap(size_t initial_size,
 void Heap::JiachengDebug() {
   // 用于显示Heap当前的信息
   Thread* self = Thread::Current();
+  (void)self;
+
+  // 查看vector<> continuous_spaces_
+  {
+    ReaderMutexLock mu(self, *Locks::mutator_lock_);
+    for (size_t i = 0; i < continuous_spaces_.size(); ++i) {
+      space::ContinuousSpace* s = continuous_spaces_[i];
+      LOG(INFO) << "jiacheng heap.cc 732"
+                << " continuous_spaces_[" << i << "]" 
+                << " GetType= " << s->GetType()
+                << " ADDR= " << size_t(s)
+                ;
+    }
+
+    // 查看vector<> discontinuous_spaces_
+    for (size_t i = 0; i < discontinuous_spaces_.size(); ++i) {
+      space::DiscontinuousSpace* s = discontinuous_spaces_[i];
+      LOG(INFO) << "jiacheng heap.cc 732"
+                << " discontinuous_spaces_[" << i << "]" 
+                << " GetType= " << s->GetType()
+                << " ADDR= " << size_t(s)
+                ;
+    }
+  }
+
+  // 查看vector<> alloc_spaces_
+  for (size_t i = 0; i < alloc_spaces_.size(); ++i) {
+    space::AllocSpace* s = alloc_spaces_[i];
+    LOG(INFO) << "jiacheng heap.cc 732"
+              << " alloc_spaces_[" << i << "]" 
+              << " ADDR= " << size_t(s)
+              ;
+  }
+
+  // 查看Heap中的Space变量
+  LOG(INFO) << "jiacheng heap.cc 732"
+            << " non_moving_space_.ADDR= " << size_t(non_moving_space_)
+            << " rosalloc_space_.ADDR= " << size_t(rosalloc_space_)
+            << " dlmalloc_space_.ADDR= " << size_t(dlmalloc_space_)
+            << " main_space_.ADDR= " << size_t(main_space_)
+            << " large_object_space_.ADDR= " << size_t(large_object_space_)
+            ;
+
+  // 其他信息
+  LOG(INFO) << "jiacheng heap.cc 732"
+            << "kDefaultLargeObjectSpaceType= " << (kDefaultLargeObjectSpaceType == space::LargeObjectSpaceType::kFreeList) ? "kFreeList" : "kMap"
+            ;
 
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "alloc_spaces_.size= " << alloc_spaces_.size();
-  for (auto& it : alloc_spaces_) {
-      LOG(INFO) << "jiacheng heap.cc 641: "
-                << "space_addr= " << size_t(it);
-  } 
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "non_moving_space= " << size_t(non_moving_space_);
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "rosalloc_space_= " << size_t(rosalloc_space_);
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "dlmalloc_space_= " << size_t(dlmalloc_space_);
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "main_space_= " << size_t(main_space_);
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "large_object_space_= " << size_t(large_object_space_);
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "zygote_space_= " << size_t(zygote_space_);
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "bump_pointer_space_= " << size_t(bump_pointer_space_);
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "temp_space_= " << size_t(temp_space_);
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "region_space_= " << size_t(region_space_); 
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "main_space_backup_= " << size_t(main_space_backup_.get());
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "current_allocator_= " << current_allocator_;   
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "current_non_moving_allocator_= " << current_non_moving_allocator_;   
-
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "collector_type_= " << collector_type_;
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "foreground_collector_type_= " << foreground_collector_type_;
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "background_collector_type_= " << background_collector_type_;
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "desired_collector_type_= " << desired_collector_type_;
-
-  gc_complete_lock_->ExclusiveLock(self);
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "collector_type_running_= " << collector_type_running_;
-  gc_complete_lock_->ExclusiveUnlock(self);
-
-
-  for (auto& it : gc_plan_) {
-    LOG(INFO) << "jiacheng heap.cc 641: "
-              << "gc_plan_= " << it;
-  }
-
-  for (auto& it : garbage_collectors_) {
-    LOG(INFO) << "jiacheng heap.cc 641: "
-              << "garbage_collector_= " << size_t(it);
-  }
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "semi_space_collector_= " << semi_space_collector_;
-  // LOG(INFO) << "jiacheng heap.cc 641: "
-  //           << "mark_compact_collector_= " << mark_compact_collector_;
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "concurrent_copying_collector_= " << concurrent_copying_collector_;
-
-  LOG(INFO) << "jiacheng heap.cc 641: "
-            << "use_tlab_= " << use_tlab_;
 }
 // jiacheng end
 
diff --git a/runtime/gc/space/region_space.cc b/runtime/gc/space/region_space.cc
index d0555b0896..36a9d0a672 100644
--- a/runtime/gc/space/region_space.cc
+++ b/runtime/gc/space/region_space.cc
@@ -48,9 +48,9 @@ static constexpr uint32_t kPoisonDeadObject = 0xBADDB01D;  // "BADDROID"
 static constexpr bool kCheckLiveBytesAgainstRegionBitmap = kIsDebugBuild;
 
 // jiacheng start
-// void RegionSpace::JiachengDebug() {
+void RegionSpace::JiachengDebug() const {
   
-// }
+}
 // jiacheng end
 
 MemMap RegionSpace::CreateMemMap(const std::string& name,
diff --git a/runtime/gc/space/region_space.h b/runtime/gc/space/region_space.h
index 26af6331cc..90cde6dd71 100644
--- a/runtime/gc/space/region_space.h
+++ b/runtime/gc/space/region_space.h
@@ -369,6 +369,10 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
     return time_;
   }
 
+  // jiacheng start
+  void JiachengDebug() const;
+  // jiacheng end
+
  private:
   RegionSpace(const std::string& name, MemMap&& mem_map, bool use_generational_cc);
 
diff --git a/runtime/jiacheng_activity_manager.cc b/runtime/jiacheng_activity_manager.cc
index 9f359b1a74..f546100e83 100644
--- a/runtime/jiacheng_activity_manager.cc
+++ b/runtime/jiacheng_activity_manager.cc
@@ -14,10 +14,7 @@ ActivityManager::ActivityManager():
     // current_working_set_(new std::set<mirror::Object*>()),
     current_working_set_(nullptr),
     current_activity_name_(""),
-    activity_ws_map_(),
-    sampling_(false),
-    in_gc_(true),
-    gc_time_(0) {
+    activity_ws_map_() {
     
     // default working set
     // activity_ws_map_[""] = current_working_set_;
@@ -27,8 +24,8 @@ ActivityManager::~ActivityManager() {
 }
 
 ActivityManager* ActivityManager::Create() {
-    ActivityManager* it = new ActivityManager();
-    return it;
+    ActivityManager* activity_manager = new ActivityManager();
+    return activity_manager;
 }
 
 ActivityManager* ActivityManager::Current() {
@@ -47,9 +44,6 @@ void ActivityManager::JiachengDebug() const {
     LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "current_working_set_=" << size_t(current_working_set_);
     LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "current_activity_name_=" << current_activity_name_;
     LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "activity_ws_map_= " << activity_ws_map_.size();
-    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "sampling_= " << sampling_.load();
-    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "in_gc_= " << in_gc_.load();
-    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "gc_time_= " << gc_time_.load();
 }
 
 bool ActivityManager::ShouldSwapOut(mirror::Object *obj) {
@@ -68,11 +62,6 @@ bool ActivityManager::ShouldSwapOut(mirror::Object *obj) {
 
 
 void ActivityManager::RecordWS(mirror::Object* obj) {
-    // 只要指定采样的时候才采样
-    if (!sampling_.load()) { 
-        return;
-    }
-
     Thread *self = Thread::Current();
 
     activity_manager_lock_.ExclusiveLock(self);
diff --git a/runtime/jiacheng_activity_manager.h b/runtime/jiacheng_activity_manager.h
index cba767f77d..d548b8af0d 100644
--- a/runtime/jiacheng_activity_manager.h
+++ b/runtime/jiacheng_activity_manager.h
@@ -37,30 +37,7 @@ public:
     /* 每次GC完成之后重新估计当前Activity的工作集 */
     void ForgetWorkingSet();
 
-    bool GetSampling() const {
-        return sampling_.load();
-    }
-
-    void SetSampling(bool sampling) {
-        sampling_.store(sampling);
-    }
-
-    bool GetInGC() const {
-        return in_gc_.load();
-    }
-
-    void SetInGC(bool in_gc) {
-        in_gc_.store(in_gc);
-    }
-
-    size_t GetGCTime() const {
-        return gc_time_.load();
-    }
-
-    void IncGCTime() {
-        gc_time_.fetch_add(1);
-    }
-
+private:
     // 用于保护current_working_set, activity_set, current_activity_name
     Mutex activity_manager_lock_; 
 
@@ -72,14 +49,6 @@ public:
 
     // 保存了ActivityName : WorkingSet 的映射
     std::map<std::string, std::set<mirror::Object*> *> activity_ws_map_; 
-
-    std::atomic<bool> sampling_;
-
-    // 每次GC开始的时候设置为true, GC结束的时候设置为false
-    std::atomic<bool> in_gc_;
-
-    // GC发生的次数
-    std::atomic<size_t> gc_time_;
 };
 
 }
diff --git a/runtime/jiacheng_cold_space.cc b/runtime/jiacheng_cold_space.cc
index e224d03925..c26a6bf6b7 100644
--- a/runtime/jiacheng_cold_space.cc
+++ b/runtime/jiacheng_cold_space.cc
@@ -72,7 +72,7 @@ ColdSpace* ColdSpace::Create() {
                                             &error_msg);
 
     // if (!mem_map) {
-    //     LOG(INFO) << "jiacheng jiacheng_cold_space.cc 46 mem_map=nullptr error_msg= " << error_msg; 
+    //     LOG(INFO) << "jiacheng jiacheng_cold_space.cc 75 mem_map=nullptr error_msg= " << error_msg; 
     // }
     return new ColdSpace(&mem_map);
 }
diff --git a/runtime/jiacheng_hack.cc b/runtime/jiacheng_hack.cc
index f44515e7f0..5ed1982c64 100644
--- a/runtime/jiacheng_hack.cc
+++ b/runtime/jiacheng_hack.cc
@@ -2,12 +2,15 @@
 #include <thread>
 #include <chrono>
 #include <atomic>
-#include <sys/mman.h>
 #include <string>
+#include <sys/mman.h>
+
 
 #include "jiacheng_hack.h"
 #include "jiacheng_cold_space.h"
 #include "jiacheng_activity_manager.h"
+#include "jiacheng_utils.h"
+#include "jiacheng_profiler.h"
 
 #include "gc/accounting/card_table.h"
 #include "gc/space/space-inl.h"
@@ -34,20 +37,64 @@
 namespace art{
 namespace jiacheng {
 
-static std::set<mirror::Object*> read_set;
-static Mutex read_set_lock("read_set_lock", kLoggingLock);
-
-static std::set<mirror::Object*> gc_set;
-static Mutex gc_set_lock("gc_set_lock", kLoggingLock);
-
-void Debug() {
-    ColdSpace::Current()->JiachengDebug();
-    ActivityManager::Current()->JiachengDebug();
+typedef void(*WalkCallback)(void *start, void *end, size_t num_bytes, void* callback_arg);
 
+// 在App启动的main函数中调用该函数
+void OnAppStart() {
     Runtime* runtime = Runtime::Current();
-    gc::Heap* heap = runtime->GetHeap();
+    const std::string& process_package_name = runtime->GetProcessPackageName();
+
+    LOG(INFO) << "jiacheng jiacheng_hack.cc 53" 
+              << " OnAppStart()"
+              << " process_package_name= " << process_package_name
+              ;
+    // 在APP启动时，异步调用
+    auto func = [&]()->void {
+        // ActivityManager* activity_manager = ActivityManager::Current();
+        for (;;) {
+            // if (!activity_manager->GetInGC()) {
+            //     SwapOut();
+            //     LOG(INFO) << "jiacheng jiacheng_hack.cc 144 执行换出!";
+            // }
+
+            gc::Heap* heap = runtime->GetHeap();
+            heap->JiachengDebug();
+
+            CurrentThreadSleepNano(1000000000);
+            CurrentThreadSleepNano(1000000000);
+            CurrentThreadSleepNano(1000000000);
+            CurrentThreadSleepNano(1000000000);
+            CurrentThreadSleepNano(1000000000);
+
+            CurrentThreadSleepNano(1000000000);
+            CurrentThreadSleepNano(1000000000);
+            CurrentThreadSleepNano(1000000000);
+            CurrentThreadSleepNano(1000000000);
+            CurrentThreadSleepNano(1000000000);
+        }
+    };
+    std::thread on_app_start_thread(func);
+    on_app_start_thread.detach();
+}
 
-    heap->JiachengDebug();
+/* 
+ * AMS通过在系统启动的时候注册的service调用该函数
+ * enum ActivityState {
+ *     INITIALIZING, 0
+ *     RESUMED, 1
+ *     PAUSING, 2
+ *     PAUSED, 3 
+ *     STOPPING, 4
+ *     STOPPED, 5
+ *     FINISHING, 6
+ *     DESTROYING, 7
+ *     DESTROYED 8
+ *}
+ */
+void UpdateActivityState(const char* package_name, const char* activity_name, int state) { 
+    (void)package_name;
+    std::string name(activity_name);
+    ActivityManager::Current()->UpdateActivityState(name, state);
 }
 
 
@@ -56,26 +103,19 @@ void Debug() {
  */
 void BeforeGarbageCollectorRun(const gc::collector::GarbageCollector* collector) {
     LOG(INFO) << "jiacheng" << " BeforeGarbageCollectorRun" 
-              << " NanoTime: " << NanoTime()
-              << " GarbageCollector.name_ " << collector->GetName()
-              << " GetGcType()" << collector->GetGcType();
+              << " NanoTime= " << NanoTime()
+              << " GarbageCollector.GetName()= " << collector->GetName()
+              << " GetGcType()= " << collector->GetGcType();
 
-    ActivityManager* activity_manager = ActivityManager::Current();
-    activity_manager->SetSampling(false);
-    activity_manager->SetInGC(true);
+    // ActivityManager* activity_manager = ActivityManager::Current();
+    // (void)activity_manager;
+
+    // Profiler* profiler = Profiler::Current();
+    // profiler->SetDuringGcFlag();
+    // profiler->JiachengDebug();
+    // profiler->ClearReadWorkingSet();
+    // profiler->ClearGcWorkingSet();
 
-    Thread* self = Thread::Current();
-    read_set_lock.ExclusiveLock(self);
-    LOG(INFO) << "jiacheng " << __FILE__ << __LINE__
-              << " read_set.size()= " << read_set.size();
-    read_set_lock.ExclusiveUnlock(self);
-    
-    read_set_lock.ExclusiveLock(self);
-    read_set.clear();
-    read_set_lock.ExclusiveUnlock(self);
-    gc_set_lock.ExclusiveLock(self);
-    gc_set.clear();
-    gc_set_lock.ExclusiveUnlock(self);
 }
 
 /*
@@ -83,10 +123,6 @@ void BeforeGarbageCollectorRun(const gc::collector::GarbageCollector* collector)
  */
 void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector) {
     // ActivityManager* activity_manager = ActivityManager::Current();
-    // activity_manager->SetSampling(true);
-    // activity_manager->SetInGC(false);
-    // activity_manager->IncGCTime();
-
     // Debug();
     // SwapOut();
     // activity_manager->ForgetWorkingSet();
@@ -94,118 +130,78 @@ void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector)
     const gc::collector::Iteration* iteration = collector->GetCurrentIteration();
     
     LOG(INFO) << "jiacheng" << " AfterGarbageCollectorRun" 
-              << " NanoTime: " << NanoTime()
-              << " GcCause: " << iteration->GetGcCause()
-              << " GetGcType()" << collector->GetGcType();  
-
-    Thread* self = Thread::Current();
-    gc_set_lock.ExclusiveLock(self);
-    LOG(INFO) << "jiacheng " << __FILE__ << __LINE__
-              << " gc_set.size()= " << gc_set.size();
-    gc_set_lock.ExclusiveUnlock(self);
-
-    read_set_lock.ExclusiveLock(self);
-    read_set.clear();
-    read_set_lock.ExclusiveUnlock(self);
-    gc_set_lock.ExclusiveLock(self);
-    gc_set.clear();
-    gc_set_lock.ExclusiveUnlock(self);
+              << " NanoTime= " << NanoTime()
+              << " GcCause= " << iteration->GetGcCause()
+              << " GetGcType= " << collector->GetGcType();
+
+    // Profiler* profiler = Profiler::Current();
+    // profiler->ClearDuringGcFlag();
+    // profiler->IncreaseGcNumber();
+    // profiler->InitColdSet();
+    // profiler->JiachengDebug();
+
+    // profiler->ClearReadWorkingSet();
+    // profiler->ClearGcWorkingSet();
 }
 
 /*
  * 每次发生读屏障的时候，调用该方法
  */
 
-void ReaderBarrierTrigger(mirror::Object* obj) {
-    // (void)obj;
+void ReadBarrierTrigger(mirror::Object* obj) {
+    (void)obj;
     if (Runtime::Current()->IsZygote()) {
         return;
     }
     // if (!Runtime::Current()->InJankPerceptibleProcessState()) {
     //     return;
     // }
-    Thread* self = Thread::Current();
 
-    read_set_lock.ExclusiveLock(self);
-    read_set.insert(obj);
-    read_set_lock.ExclusiveUnlock(self);
-
-//     // com.jiacheng.activitylifecycletest = 34
-//     // com.taobao.taobao = 17
+    // com.jiacheng.activitylifecycletest = 34
+    // com.taobao.taobao = 17
     // const std::string& package_name = Runtime::Current()->GetProcessPackageName();
     // if (!(package_name.length() == 17 && package_name[4] == 't')) { 
     //     return;
     // }
-    // ActivityManager::Current()->RecordWS(obj);
 
-//     LOG(INFO) << "jiacheng ReaderBarrierTrigger "
-//               << "obj= " << reinterpret_cast<size_t>(obj) << ' '
-//               << "offset= " << reinterpret_cast<size_t>(offset) << ' '
-//               << "ref= " << reinterpret_cast<size_t>(ref_addr) << ' '
-//               << "GetProcessPackageName= " << Runtime::Current()->GetProcessPackageName() << ' ';
+    Profiler* profiler = Profiler::Current();
+    (void)profiler;
+
+    // profiler->RecordReadWorkingSet(obj);
+    // ActivityManager::Current()->RecordWS(obj);
 
 }
 
 void GCMarkTrigger(mirror::Object* obj) {
+    (void)obj;
     if (Runtime::Current()->IsZygote()) {
         return;
     }
-    Thread* self = Thread::Current();
+    // if (!Runtime::Current()->InJankPerceptibleProcessState()) {
+    //     return;
+    // }
+    
+    // com.jiacheng.activitylifecycletest = 34
+    // com.taobao.taobao = 17
+    // const std::string& package_name = Runtime::Current()->GetProcessPackageName();
+    // if (!(package_name.length() == 17 && package_name[4] == 't')) { 
+    //     return;
+    // }
 
-    gc_set_lock.ExclusiveLock(self);
-    gc_set.insert(obj);
-    gc_set_lock.ExclusiveUnlock(self);
-}
+    Profiler* profiler = Profiler::Current();
+    (void)profiler;
 
+    // profiler->RecordGcWorkingSet(obj);
+}
 
+void Debug() {
+    ColdSpace::Current()->JiachengDebug();
+    ActivityManager::Current()->JiachengDebug();
 
-/* 
- * AMS通过在系统启动的时候注册的service调用该函数
- * enum ActivityState {
- *     INITIALIZING, 0
- *     RESUMED, 1
- *     PAUSING, 2
- *     PAUSED, 3 
- *     STOPPING, 4
- *     STOPPED, 5
- *     FINISHING, 6
- *     DESTROYING, 7
- *     DESTROYED 8
- *}
- */
-void UpdateActivityState(const char* package_name, const char* activity_name, int state) { 
-    (void)package_name;
-    std::string name(activity_name);
-    ActivityManager::Current()->UpdateActivityState(name, state);
-}
+    Runtime* runtime = Runtime::Current();
+    gc::Heap* heap = runtime->GetHeap();
 
-/*
- * 在App启动的main函数中调用该函数
- */
-void OnAppStart() {
-    LOG(INFO) << "jiacheng jiacheng_hack.cc 127 OnAppStart()";
-    // auto func = []()->void {
-    //     ActivityManager* activity_manager = ActivityManager::Current();
-    //     for (;;) {
-    //         if (!activity_manager->GetInGC()) {
-    //             SwapOut();
-    //             LOG(INFO) << "jiacheng jiacheng_hack.cc 144 执行换出!";
-    //         }
-    //         CurrentThreadSleepNano(1000000000);
-    //         CurrentThreadSleepNano(1000000000);
-    //         CurrentThreadSleepNano(1000000000);
-    //         CurrentThreadSleepNano(1000000000);
-    //         CurrentThreadSleepNano(1000000000);
-
-    //         CurrentThreadSleepNano(1000000000);
-    //         CurrentThreadSleepNano(1000000000);
-    //         CurrentThreadSleepNano(1000000000);
-    //         CurrentThreadSleepNano(1000000000);
-    //         CurrentThreadSleepNano(1000000000);
-    //     }
-    // };
-    // std::thread on_app_start_thread(func);
-    // on_app_start_thread.detach();
+    heap->JiachengDebug();
 }
 
 // 对ColdSpace中的Region进行Swap
@@ -251,26 +247,10 @@ void SwapOut() {
 }
 
 
-void CurrentThreadSleepNano(const unsigned long n) {
-    std::this_thread::sleep_for(std::chrono::nanoseconds(n));
-}
-
-// 防止某个操作过于频繁
-bool CheckHot() {
-    static std::atomic<uint64_t> last_time(0);
-    uint64_t get_last_time = last_time.load();
-    uint64_t this_time = art::NanoTime();
-    if (this_time - get_last_time < 5000000000) {
-        return true;
-    } else {
-        last_time.store(this_time);
-        return false;
-    }
-}
-
 void SwapOutSpace(gc::space::Space* space) {
     Thread* self = Thread::Current();
     gc::space::SpaceType space_type = space->GetType();
+    
     WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* ) {
         // if (start != end && ActivityManager::Current()->ShouldSwapOut(reinterpret_cast<mirror::Object*>(start))) {
         if (start != end) {
@@ -325,270 +305,5 @@ void SwapOutSpace(gc::space::Space* space) {
     }
 }
 
-// ------------------- static ---------------------
-
-void PrintProcStat() {
-    static std::ifstream stat;
-    static std::string line;
-    stat.open("/proc/stat");
-    if (!stat.is_open()) {
-        LOG(INFO) << "jiacheng" << " /proc/stat can not open!";
-    } else {
-        while(getline(stat, line)) {
-            LOG(INFO) << "jiacheng " << line;
-        }
-        stat.close();
-    }
-
-}
-
-void PrintProcStat(const char* info) {
-    static std::ifstream stat;
-    static std::string line;
-    stat.open("/proc/stat");
-    if (!stat.is_open()) {
-        LOG(INFO) << "jiacheng" << " /proc/stat can not open!";
-    } else {
-        while(getline(stat, line)) {
-            LOG(INFO) << "jiacheng " << info << ' ' << line;
-        }
-        stat.close();
-    }
-}
-
-bool ExistSwap() {
-    static bool exist;
-    static std::ifstream stat;
-    static std::string line;
-    int line_number = 0;
-    if (exist) {
-        return true;
-    }
-    stat.open("/proc/swaps");
-    if (!stat.is_open()) {
-        LOG(INFO) << "jiacheng" << " /proc/swaps can not open!";
-    } else {
-        while(getline(stat, line)) {
-            line_number++;
-            if (line_number > 1) {
-                exist = true;
-                break;
-            }
-        }
-        stat.close();
-    }
-    return exist;
-}
-
-void VisitSpace(gc::space::Space* space) {
-    gc::space::SpaceType space_type = space->GetType();
-    Thread* self = Thread::Current();
-    WalkCallback walk_callback = [](void *start, void *end, size_t num_bytes, void* ) {
-        LOG(INFO) << "jiacheng " << "start= " << start << ' ' << "end= " << end << ' ' << "num_bytes= " << num_bytes;
-    };    
-    auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_){
-        if (!obj) {
-            LOG(INFO) << "jiacheng Object=Null";
-            return; 
-        }
-        LOG(INFO) << "jiacheng Object= " << obj << " Size= " << obj->SizeOf() << " Type= " << obj->PrettyTypeOf();
-    };
-    switch (space_type) {
-        case gc::space::kSpaceTypeImageSpace: {
-            LOG(INFO) << "jiacheng VisitSpace " << "ImageSpace: ";
-            gc::space::ImageSpace* this_space = space->AsImageSpace();
-            this_space->Dump(LOG_STREAM(INFO));
-            break;
-        }
-        case gc::space::kSpaceTypeMallocSpace: {
-            LOG(INFO) << "jiacheng VisitSpace " << "MallocSpace: ";
-            gc::space::MallocSpace* this_space = space->AsMallocSpace();
-            this_space->Dump(LOG_STREAM(INFO));
-            this_space->Walk(walk_callback, nullptr);
-            break;
-        }
-        case gc::space::kSpaceTypeZygoteSpace: {
-            LOG(INFO) << "jiacheng VisitSpace " << "ZygoteSpace: ";
-            gc::space::ZygoteSpace* this_space = space->AsZygoteSpace();
-            this_space->Dump(LOG_STREAM(INFO));
-            break;
-        }
-        case gc::space::kSpaceTypeBumpPointerSpace: {
-            LOG(INFO) << "jiacheng VisitSpace " << "BumpPointerSpace: ";
-            gc::space::BumpPointerSpace* this_space = space->AsBumpPointerSpace();
-            this_space->Dump(LOG_STREAM(INFO));
-            {
-                ReaderMutexLock mu(self, *Locks::mutator_lock_);   
-                this_space->Walk(visitor);
-            }
-            break;
-        }
-        case gc::space::kSpaceTypeLargeObjectSpace: {
-            LOG(INFO) << "jiacheng VisitSpace " << "LargeObjectSpace: ";
-            gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
-            this_space->Dump(LOG_STREAM(INFO));
-            this_space->Walk(walk_callback, nullptr);
-            break;
-        }
-        case gc::space::kSpaceTypeRegionSpace: {
-            LOG(INFO) << "jiacheng VisitSpace " << "RegionSpace: ";
-            gc::space::RegionSpace* this_space = space->AsRegionSpace();   
-            this_space->Dump(LOG_STREAM(INFO));
-            {
-                WriterMutexLock mu(self, *Locks::mutator_lock_);           
-                this_space->Walk(visitor);
-            }
-            break;
-        }
-        default:
-            LOG(INFO) << "jiacheng " << "jiacheng_hack.cc 100. Can not find space.";
-    }
-}
-
-void VisitHeap(const gc::Heap* heap) {
-    Thread* self = Thread::Current();
-    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
-    {
-        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
-        continues_spaces = &(heap->GetContinuousSpaces());
-    }
-    for (auto space : *continues_spaces) {
-        VisitSpace(space);
-    }
-    const std::vector<gc::space::DiscontinuousSpace*>& discontinues_spaces = heap->GetDiscontinuousSpaces();
-    for (auto space : discontinues_spaces) {
-        VisitSpace(space);
-    }    
-}
-
-
-void VisitMemMap(const MemMap* mem_map) {
-    LOG(INFO) << "jiacheng VisitMemMap ";
-    LOG(INFO) << (*mem_map);
-    uint8_t* begin = mem_map->Begin();
-    uint8_t* end = mem_map->End();
-    void* base_begin = mem_map->BaseBegin();
-    void* base_end = mem_map->BaseEnd();
-    LOG(INFO) << "begin= " << reinterpret_cast<size_t>(begin) << ' '
-              << "end= " << reinterpret_cast<size_t>(end) << ' '
-              << "base_begin= " << reinterpret_cast<size_t>(base_begin) << ' '
-              << "base_end= " << reinterpret_cast<size_t>(base_end);
-    // print every byte
-    // for(uint8_t* p = begin; p != end; ++p) {
-    //     LOG(INFO) << static_cast<int>(*p);
-    // }
-
-}
-
-template<size_t kAlignment>
-void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* ) {
-}
-
-void VisitHeapBitmap(const gc::accounting::HeapBitmap* ) {
-}
-
-void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set) {
-    LOG(INFO) << "jiacheng VisitRememberedSet ";
-    auto table = const_cast<gc::accounting::RememberedSet*>(remembered_set);
-    {
-        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
-        table->Dump(LOG_STREAM(INFO));
-    }
-
-}
-
-void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table) {
-    LOG(INFO) << "jiacheng VisitModUnionTableToZygoteAllocspace ";
-    auto table = const_cast<gc::accounting::ModUnionTableToZygoteAllocspace*>(static_cast<const gc::accounting::ModUnionTableToZygoteAllocspace*>(mod_union_table));
-    {
-        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
-        table->Dump(LOG_STREAM(INFO));
-    }
-}
-
-void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table) {
-    LOG(INFO) << "jiacheng VisitModUnionTableCardCache ";
-    auto table = const_cast<gc::accounting::ModUnionTableCardCache*>(static_cast<const gc::accounting::ModUnionTableCardCache*>(mod_union_table));
-    {
-        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
-        table->Dump(LOG_STREAM(INFO));
-    }
-}
-
-void VisitCardTable(const gc::accounting::CardTable* card_table) {
-    (void)card_table;
-    LOG(INFO) << "jiacheng VisitCardTable ";
-    // MemMap* mem_map = &(card_table->mem_map_);
-    // uint8_t* const biased_begin = card_table->biased_begin_;
-    // const size_t offset = card_table->offset_;
-
-    // VisitMemMap(mem_map);
-    // LOG(INFO) << "biased_begin= " << reinterpret_cast<size_t>(biased_begin);
-    // LOG(INFO) << "offset= " << offset;
-}
-
-void DebugPrintModUnionAndRememberSet() {
-    if (Runtime::Current()->IsZygote()) {
-        return;
-    }
-    if (!Runtime::Current()->InJankPerceptibleProcessState()) {
-      LOG(INFO) << "jiacheng " << "InJankPerceptibleProcessState" ;
-      return;
-    }
-    // if (jiacheng::CheckHot()) {
-    //   LOG(INFO) << "jiacheng " << "CheckHot";
-    //   return;
-    // }  
-    if (!jiacheng::ExistSwap()) {
-      return;
-    }
-
-    gc::Heap* heap = Runtime::Current()->GetHeap();
-    VisitHeap(heap);
-
-    Thread* self = Thread::Current();
-    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
-    {
-        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
-        continues_spaces = &(heap->GetContinuousSpaces());
-    }
-    for (auto space : *continues_spaces) {
-        LOG(INFO) << space->GetName();
-        gc::space::SpaceType space_type = space->GetType();
-        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
-        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
-        if (mod_union_table) {
-            LOG(INFO) << "jiacheng mod_union_table";
-            if (space_type == gc::space::kSpaceTypeZygoteSpace) {
-                VisitModUnionTableCardCache(mod_union_table);
-            } else if (space_type == gc::space::kSpaceTypeImageSpace) {
-                VisitModUnionTableToZygoteAllocspace(mod_union_table);
-            }
-        } 
-        if (remembered_set) {
-            LOG(INFO) << "jiacheng remembered_set";
-            VisitRememberedSet(remembered_set);
-        }
-        if (mod_union_table == nullptr && remembered_set == nullptr) {
-            LOG(INFO) << "nullptr";
-        }
-    }
-    const std::vector<gc::space::DiscontinuousSpace*>* discontinues_spaces = &(heap->GetDiscontinuousSpaces());
-    for (auto space : *discontinues_spaces) {
-        LOG(INFO) << space->GetName();
-        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
-        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
-        if (mod_union_table) {
-            LOG(INFO) << "jiacheng mod_union_table";
-        } 
-        if (remembered_set) {
-            LOG(INFO) << "jiacheng remembered_set";
-        }
-        if (mod_union_table == nullptr && remembered_set == nullptr) {
-            LOG(INFO) << "nullptr";
-        }
-    }
-}
-
 } // namespace jiacheng
 } // namespace art
diff --git a/runtime/jiacheng_hack.h b/runtime/jiacheng_hack.h
index 76ec57dd47..7737067873 100644
--- a/runtime/jiacheng_hack.h
+++ b/runtime/jiacheng_hack.h
@@ -42,62 +42,29 @@ class Thread;
 class MemMap;
 class MemberOffset;
 
-// ------------ START -------------
 namespace jiacheng {
 
-typedef void(*WalkCallback)(void *start, void *end, size_t num_bytes, void* callback_arg);
+// ---------------- 前端事件 --------------
+void OnAppStart();
 
-void Debug();
+void UpdateActivityState(const char* package_name, const char* activity_name, int state);
 
+// ---------------- ART事件 --------------
 void BeforeGarbageCollectorRun(const gc::collector::GarbageCollector* collector);
 
 void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector);
 
-void ReaderBarrierTrigger(mirror::Object* obj);
+void ReadBarrierTrigger(mirror::Object* obj);
 
 void GCMarkTrigger(mirror::Object* obj);
 
-void UpdateActivityState(const char* package_name, const char* activity_name, int state);
-
-void OnAppStart();
+// ---------------- 内部调用 --------------
+void Debug();
 
 void SwapOut();
 
-void CurrentThreadSleepNano(const unsigned long n);
-
-bool CheckHot();
-
 void SwapOutSpace(gc::space::Space* space);
 
-// -------------- DEGUB ----------
-
-void PrintProcStat();
-
-void PrintProcStat(const char* info);
-
-bool ExistSwap();
-
-void VisitSpace(gc::space::Space* space);
-
-void VisitHeap(const gc::Heap* heap);
-
-void VisitMemMap(const MemMap* mem_map);
-
-template<size_t kAlignment>
-void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* );
-
-void VisitHeapBitmap(const gc::accounting::HeapBitmap* );
-
-void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set);
-
-void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table);
-
-void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table);
-
-void VisitCardTable(const gc::accounting::CardTable* card_table);
-
-void DebugPrintModUnionAndRememberSet();
-
 
 } // namespace jiacheng
 } // namespace art
diff --git a/runtime/jiacheng_profiler.cc b/runtime/jiacheng_profiler.cc
new file mode 100644
index 0000000000..cddaa2e394
--- /dev/null
+++ b/runtime/jiacheng_profiler.cc
@@ -0,0 +1,148 @@
+#include "jiacheng_profiler.h"
+
+#include "thread-inl.h"
+
+namespace art {
+namespace jiacheng {
+
+Mutex Profiler::singleton_lock_("Profiler Singleton Lock", kLoggingLock);
+Profiler* Profiler::instance_(nullptr); 
+
+Profiler* Profiler::Create() {
+    Profiler* it = new Profiler();
+    return it;
+}
+
+Profiler* Profiler::Current() {
+    if (instance_ == nullptr) {
+        Thread* self = Thread::Current();
+        singleton_lock_.ExclusiveLock(self);
+        if (instance_ == nullptr) {
+            instance_ = Create();
+        }
+        singleton_lock_.ExclusiveUnlock(self);
+    }
+    return instance_;
+}
+
+Profiler::Profiler():
+    read_working_set_(),
+    read_working_set_lock_("read_working_set_lock", kJiachengWorkingSetLock),
+    gc_working_set_(),
+    gc_working_set_lock_("gc_working_set_lock", kJiachengWorkingSetLock),
+    cold_set_(),
+    cold_set_lock_("cold_set_lock", kJiachengColdSpaceLock),
+    during_gc_flag_(false),
+    gc_number_(0) {
+}
+
+Profiler::~Profiler() = default;
+
+void Profiler::JiachengDebug() {
+    Thread* self = Thread::Current();
+
+    gc_working_set_lock_.ExclusiveLock(self);
+    size_t gc_working_set_size = gc_working_set_.size();
+    gc_working_set_lock_.ExclusiveUnlock(self);
+
+    read_working_set_lock_.ExclusiveLock(self);
+    size_t read_working_set_size = read_working_set_.size();
+    read_working_set_lock_.ExclusiveUnlock(self);
+
+    cold_set_lock_.ExclusiveLock(self);
+    size_t cold_set_size = cold_set_.size();
+    cold_set_lock_.ExclusiveUnlock(self);
+
+    LOG(INFO) << "jiacheng jiacheng_profiler.cc 39" 
+              << " gc_working_set_.size()= " << gc_working_set_size
+              << " read_working_set_.size()= " << read_working_set_size
+              << " cold_set_.size()= " << cold_set_size
+              << " during_gc_flag_= " << during_gc_flag_.load()
+              << " gc_number_= " << gc_number_.load()
+              ;
+}
+
+
+void Profiler::RecordReadWorkingSet(mirror::Object* obj) {
+    Thread* self = Thread::Current();
+    read_working_set_lock_.ExclusiveLock(self);
+    read_working_set_.insert(obj);
+    read_working_set_lock_.ExclusiveUnlock(self);
+}
+
+void Profiler::ClearReadWorkingSet() {
+    Thread* self = Thread::Current();
+    read_working_set_lock_.ExclusiveLock(self);
+    read_working_set_.clear();
+    read_working_set_lock_.ExclusiveUnlock(self);
+}
+
+void Profiler::RecordGcWorkingSet(mirror::Object* obj) {
+    Thread* self = Thread::Current();
+    gc_working_set_lock_.ExclusiveLock(self);
+    gc_working_set_.insert(obj);
+    gc_working_set_lock_.ExclusiveUnlock(self);
+}
+
+void Profiler::ClearGcWorkingSet() {
+    Thread* self = Thread::Current();
+    gc_working_set_lock_.ExclusiveLock(self);
+    gc_working_set_.clear();
+    gc_working_set_lock_.ExclusiveUnlock(self);
+}
+
+void Profiler::SetDuringGcFlag() {
+    during_gc_flag_.store(1);
+}
+
+void Profiler::ClearDuringGcFlag() {
+    during_gc_flag_.store(0);
+}
+
+bool Profiler::GetDuringGcFlag() {
+    return during_gc_flag_.load();
+}
+
+void Profiler::IncreaseGcNumber() {
+    gc_number_.fetch_add(1);
+}
+
+uint32_t Profiler::GetGcNumber() {
+    return gc_number_.load();
+}
+
+void Profiler::InitColdSet() {
+    Thread* self = Thread::Current();
+    cold_set_lock_.ExclusiveLock(self);
+    cold_set_.clear();
+
+    // GC工作集 - Read工作集
+    gc_working_set_lock_.ExclusiveLock(self);
+    for (mirror::Object* obj : gc_working_set_) {
+        cold_set_.insert(obj);
+    }
+    gc_working_set_lock_.ExclusiveUnlock(self);
+
+    read_working_set_lock_.ExclusiveLock(self);
+    for (mirror::Object* obj : read_working_set_) {
+        cold_set_.erase(obj);
+    }
+    read_working_set_lock_.ExclusiveUnlock(self);
+    
+    cold_set_lock_.ExclusiveUnlock(self);
+}
+
+bool Profiler::ShouldSwapOut(mirror::Object* obj) {
+    (void)obj;
+    // Thread* self = Thread::Current();
+    // cold_set_lock_.ExclusiveLock(self);
+    // bool res = cold_set_.find(obj) != cold_set_.end();
+    // cold_set_lock_.ExclusiveUnlock(self);
+    // return res;
+    return false;
+}
+
+
+ 
+} // namespace jiacheng
+} // namespace art
\ No newline at end of file
diff --git a/runtime/jiacheng_profiler.h b/runtime/jiacheng_profiler.h
new file mode 100644
index 0000000000..44076311df
--- /dev/null
+++ b/runtime/jiacheng_profiler.h
@@ -0,0 +1,76 @@
+#ifndef ART_RUNTIME_JIACHENG_PROFILER_H_
+#define ART_RUNTIME_JIACHENG_PROFILER_H_
+
+#include <set>
+#include <map>
+#include <atomic>
+
+#include "base/mutex.h"
+
+namespace art {
+
+namespace mirror {
+    class Object;
+}
+
+namespace jiacheng {
+
+class Profiler {
+public:
+    static Mutex singleton_lock_;
+    static Profiler* instance_; 
+
+    static Profiler* Create();
+    static Profiler* Current();
+
+    Profiler();
+    ~Profiler();
+
+    void JiachengDebug();
+
+    void RecordReadWorkingSet(mirror::Object* obj);
+
+    void ClearReadWorkingSet();
+
+    void RecordGcWorkingSet(mirror::Object* obj);
+
+    void ClearGcWorkingSet();
+
+    void SetDuringGcFlag();
+
+    void ClearDuringGcFlag();
+
+    bool GetDuringGcFlag();
+
+    void IncreaseGcNumber();
+
+    uint32_t GetGcNumber();
+
+    void InitColdSet();
+
+    bool ShouldSwapOut(mirror::Object* obj);
+
+private:
+    // Mutator的Read Working Set
+    std::set<mirror::Object*> read_working_set_;
+    Mutex read_working_set_lock_;
+
+    // GC的Read Working Set
+    std::set<mirror::Object*> gc_working_set_;
+    Mutex gc_working_set_lock_;
+
+    // 需要换出去的对象集合Cold Set
+    std::set<mirror::Object*> cold_set_;
+    Mutex cold_set_lock_;
+
+    // 每次GC开始的时候设置为true, GC结束的时候设置为false
+    std::atomic<bool> during_gc_flag_;
+
+    // 历史GC发生的总次数
+    std::atomic<uint32_t> gc_number_;
+};
+
+}
+}
+
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_utils.cc b/runtime/jiacheng_utils.cc
new file mode 100644
index 0000000000..796f8293ed
--- /dev/null
+++ b/runtime/jiacheng_utils.cc
@@ -0,0 +1,263 @@
+#include <chrono>
+#include <atomic>
+#include <thread>
+
+#include "jiacheng_utils.h"
+
+#include "gc/accounting/card_table.h"
+#include "gc/space/space-inl.h"
+#include "gc/heap.h"
+#include "gc/space/zygote_space.h"
+#include "gc/space/bump_pointer_space-inl.h"
+#include "gc/space/bump_pointer_space-walk-inl.h"
+#include "gc/space/dlmalloc_space-inl.h"
+#include "gc/space/image_space.h"
+#include "gc/space/large_object_space.h"
+#include "gc/space/malloc_space.h"
+#include "gc/space/region_space-inl.h"
+#include "gc/space/rosalloc_space-inl.h"
+#include "mirror/class-inl.h"
+#include "obj_ptr-inl.h"
+#include "scoped_thread_state_change-inl.h"
+#include "thread_list.h"
+#include "gc/accounting/mod_union_table-inl.h"
+#include "gc/accounting/remembered_set.h"
+#include "base/mutex.h"
+#include "read_barrier_config.h"
+
+
+namespace art {
+namespace jiacheng {
+
+typedef void(*WalkCallback)(void *start, void *end, size_t num_bytes, void* callback_arg);
+    
+void CurrentThreadSleepNano(const unsigned long n) {
+    std::this_thread::sleep_for(std::chrono::nanoseconds(n));
+}
+
+// 防止某个操作过于频繁
+bool CheckHot() {
+    static std::atomic<uint64_t> last_time(0);
+    uint64_t get_last_time = last_time.load();
+    uint64_t this_time = art::NanoTime();
+    if (this_time - get_last_time < 5000000000) {
+        return true;
+    } else {
+        last_time.store(this_time);
+        return false;
+    }
+}
+
+/* ------------------- debug --------------------- */
+
+void VisitSpace(gc::space::Space* space) {
+    gc::space::SpaceType space_type = space->GetType();
+    Thread* self = Thread::Current();
+    WalkCallback walk_callback = [](void *start, void *end, size_t num_bytes, void* ) {
+        LOG(INFO) << "jiacheng " << "start= " << start << ' ' << "end= " << end << ' ' << "num_bytes= " << num_bytes;
+    };    
+    auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_){
+        if (!obj) {
+            LOG(INFO) << "jiacheng Object=Null";
+            return; 
+        }
+        LOG(INFO) << "jiacheng Object= " << obj << " Size= " << obj->SizeOf() << " Type= " << obj->PrettyTypeOf();
+    };
+    switch (space_type) {
+        case gc::space::kSpaceTypeImageSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "ImageSpace: ";
+            gc::space::ImageSpace* this_space = space->AsImageSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            break;
+        }
+        case gc::space::kSpaceTypeMallocSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "MallocSpace: ";
+            gc::space::MallocSpace* this_space = space->AsMallocSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            this_space->Walk(walk_callback, nullptr);
+            break;
+        }
+        case gc::space::kSpaceTypeZygoteSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "ZygoteSpace: ";
+            gc::space::ZygoteSpace* this_space = space->AsZygoteSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            break;
+        }
+        case gc::space::kSpaceTypeBumpPointerSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "BumpPointerSpace: ";
+            gc::space::BumpPointerSpace* this_space = space->AsBumpPointerSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            {
+                ReaderMutexLock mu(self, *Locks::mutator_lock_);   
+                this_space->Walk(visitor);
+            }
+            break;
+        }
+        case gc::space::kSpaceTypeLargeObjectSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "LargeObjectSpace: ";
+            gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
+            this_space->Dump(LOG_STREAM(INFO));
+            this_space->Walk(walk_callback, nullptr);
+            break;
+        }
+        case gc::space::kSpaceTypeRegionSpace: {
+            LOG(INFO) << "jiacheng VisitSpace " << "RegionSpace: ";
+            gc::space::RegionSpace* this_space = space->AsRegionSpace();   
+            this_space->Dump(LOG_STREAM(INFO));
+            {
+                WriterMutexLock mu(self, *Locks::mutator_lock_);           
+                this_space->Walk(visitor);
+            }
+            break;
+        }
+        default:
+            LOG(INFO) << "jiacheng " << "jiacheng_hack.cc 100. Can not find space.";
+    }
+}
+
+void VisitHeap(const gc::Heap* heap) {
+    Thread* self = Thread::Current();
+    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
+    {
+        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
+        continues_spaces = &(heap->GetContinuousSpaces());
+    }
+    for (auto space : *continues_spaces) {
+        VisitSpace(space);
+    }
+    const std::vector<gc::space::DiscontinuousSpace*>& discontinues_spaces = heap->GetDiscontinuousSpaces();
+    for (auto space : discontinues_spaces) {
+        VisitSpace(space);
+    }    
+}
+
+
+void VisitMemMap(const MemMap* mem_map) {
+    LOG(INFO) << "jiacheng VisitMemMap ";
+    LOG(INFO) << (*mem_map);
+    uint8_t* begin = mem_map->Begin();
+    uint8_t* end = mem_map->End();
+    void* base_begin = mem_map->BaseBegin();
+    void* base_end = mem_map->BaseEnd();
+    LOG(INFO) << "begin= " << reinterpret_cast<size_t>(begin) << ' '
+              << "end= " << reinterpret_cast<size_t>(end) << ' '
+              << "base_begin= " << reinterpret_cast<size_t>(base_begin) << ' '
+              << "base_end= " << reinterpret_cast<size_t>(base_end);
+    // print every byte
+    // for(uint8_t* p = begin; p != end; ++p) {
+    //     LOG(INFO) << static_cast<int>(*p);
+    // }
+
+}
+
+template<size_t kAlignment>
+void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* ) {
+}
+
+void VisitHeapBitmap(const gc::accounting::HeapBitmap* ) {
+}
+
+void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set) {
+    LOG(INFO) << "jiacheng VisitRememberedSet ";
+    auto table = const_cast<gc::accounting::RememberedSet*>(remembered_set);
+    {
+        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
+        table->Dump(LOG_STREAM(INFO));
+    }
+
+}
+
+void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table) {
+    LOG(INFO) << "jiacheng VisitModUnionTableToZygoteAllocspace ";
+    auto table = const_cast<gc::accounting::ModUnionTableToZygoteAllocspace*>(static_cast<const gc::accounting::ModUnionTableToZygoteAllocspace*>(mod_union_table));
+    {
+        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
+        table->Dump(LOG_STREAM(INFO));
+    }
+}
+
+void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table) {
+    LOG(INFO) << "jiacheng VisitModUnionTableCardCache ";
+    auto table = const_cast<gc::accounting::ModUnionTableCardCache*>(static_cast<const gc::accounting::ModUnionTableCardCache*>(mod_union_table));
+    {
+        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
+        table->Dump(LOG_STREAM(INFO));
+    }
+}
+
+void VisitCardTable(const gc::accounting::CardTable* card_table) {
+    (void)card_table;
+    LOG(INFO) << "jiacheng VisitCardTable ";
+    // MemMap* mem_map = &(card_table->mem_map_);
+    // uint8_t* const biased_begin = card_table->biased_begin_;
+    // const size_t offset = card_table->offset_;
+
+    // VisitMemMap(mem_map);
+    // LOG(INFO) << "biased_begin= " << reinterpret_cast<size_t>(biased_begin);
+    // LOG(INFO) << "offset= " << offset;
+}
+
+void DebugPrintModUnionAndRememberSet() {
+    if (Runtime::Current()->IsZygote()) {
+        return;
+    }
+    if (!Runtime::Current()->InJankPerceptibleProcessState()) {
+      LOG(INFO) << "jiacheng " << "InJankPerceptibleProcessState" ;
+      return;
+    }
+    // if (jiacheng::CheckHot()) {
+    //   LOG(INFO) << "jiacheng " << "CheckHot";
+    //   return;
+    // }  
+
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    VisitHeap(heap);
+
+    Thread* self = Thread::Current();
+    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
+    {
+        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
+        continues_spaces = &(heap->GetContinuousSpaces());
+    }
+    for (auto space : *continues_spaces) {
+        LOG(INFO) << space->GetName();
+        gc::space::SpaceType space_type = space->GetType();
+        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
+        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
+        if (mod_union_table) {
+            LOG(INFO) << "jiacheng mod_union_table";
+            if (space_type == gc::space::kSpaceTypeZygoteSpace) {
+                VisitModUnionTableCardCache(mod_union_table);
+            } else if (space_type == gc::space::kSpaceTypeImageSpace) {
+                VisitModUnionTableToZygoteAllocspace(mod_union_table);
+            }
+        } 
+        if (remembered_set) {
+            LOG(INFO) << "jiacheng remembered_set";
+            VisitRememberedSet(remembered_set);
+        }
+        if (mod_union_table == nullptr && remembered_set == nullptr) {
+            LOG(INFO) << "nullptr";
+        }
+    }
+    const std::vector<gc::space::DiscontinuousSpace*>* discontinues_spaces = &(heap->GetDiscontinuousSpaces());
+    for (auto space : *discontinues_spaces) {
+        LOG(INFO) << space->GetName();
+        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
+        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
+        if (mod_union_table) {
+            LOG(INFO) << "jiacheng mod_union_table";
+        } 
+        if (remembered_set) {
+            LOG(INFO) << "jiacheng remembered_set";
+        }
+        if (mod_union_table == nullptr && remembered_set == nullptr) {
+            LOG(INFO) << "nullptr";
+        }
+    }
+}
+
+
+
+}
+}
\ No newline at end of file
diff --git a/runtime/jiacheng_utils.h b/runtime/jiacheng_utils.h
new file mode 100644
index 0000000000..4ec4ee4653
--- /dev/null
+++ b/runtime/jiacheng_utils.h
@@ -0,0 +1,77 @@
+#ifndef ART_RUNTIME_JIACHENG_UTILS_H_
+#define ART_RUNTIME_JIACHENG_UTILS_H_
+
+// 与ART不相关的功能
+
+namespace art {
+namespace gc {
+namespace accounting {
+template<size_t kAlignment> class SpaceBitmap;
+class HeapBitmap;
+class RememberedSet;
+class ModUnionTable;
+class CardTable;
+} // namespace accounting
+
+namespace space {
+class Space;
+class ImageSpace;
+class MallocSpace;
+class ZygoteSpace;
+class BumpPointerSpace;
+class LargeObjectSpace;
+class RegionSpace;
+} // namespace space
+
+namespace collector {
+class GarbageCollector;
+} // namespace collector
+
+class Heap;
+
+} // namespace gc
+
+namespace mirror {
+class Class;
+class Object;
+template<class T> class ObjectArray;
+}  // namespace mirror
+
+class Thread;
+class MemMap;
+class MemberOffset;
+
+namespace jiacheng {
+
+void CurrentThreadSleepNano(const unsigned long n);
+
+bool CheckHot();
+
+/* ------------------- debug --------------------- */
+
+void VisitSpace(gc::space::Space* space);
+
+void VisitHeap(const gc::Heap* heap);
+
+void VisitMemMap(const MemMap* mem_map);
+
+template<size_t kAlignment>
+void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* );
+
+void VisitHeapBitmap(const gc::accounting::HeapBitmap* );
+
+void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set);
+
+void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table);
+
+void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table);
+
+void VisitCardTable(const gc::accounting::CardTable* card_table);
+
+void DebugPrintModUnionAndRememberSet();
+
+} // namespace jiacheng
+} // namespace art
+
+
+#endif
\ No newline at end of file
diff --git a/runtime/read_barrier-inl.h b/runtime/read_barrier-inl.h
index 1649bbe70e..bbb87098d7 100644
--- a/runtime/read_barrier-inl.h
+++ b/runtime/read_barrier-inl.h
@@ -76,7 +76,7 @@ inline MirrorType* ReadBarrier::Barrier(
       }
       AssertToSpaceInvariant(obj, offset, ref);
       // jiacheng start
-      jiacheng::ReaderBarrierTrigger(ref);
+      jiacheng::ReadBarrierTrigger(ref);
       // jiacheng end
       return ref;
     } else if (kUseBrooksReadBarrier) {
@@ -84,7 +84,7 @@ inline MirrorType* ReadBarrier::Barrier(
       // jiacheng start
       MirrorType* ref = ref_addr->template AsMirrorPtr<kIsVolatile>();
       // return ref_addr->template AsMirrorPtr<kIsVolatile>();
-      jiacheng::ReaderBarrierTrigger(ref);
+      jiacheng::ReadBarrierTrigger(ref);
       return ref;
       // jiacheng end
     } else if (kUseTableLookupReadBarrier) {
@@ -105,7 +105,7 @@ inline MirrorType* ReadBarrier::Barrier(
       }
       AssertToSpaceInvariant(obj, offset, ref);
       // jiacheng start
-      jiacheng::ReaderBarrierTrigger(ref);
+      jiacheng::ReadBarrierTrigger(ref);
       // jiacheng end
       return ref;
     } else {
@@ -117,7 +117,7 @@ inline MirrorType* ReadBarrier::Barrier(
     // jiacheng start
     // return ref_addr->template AsMirrorPtr<kIsVolatile>();
     MirrorType* ref = ref_addr->template AsMirrorPtr<kIsVolatile>();
-    jiacheng::ReaderBarrierTrigger(ref);
+    jiacheng::ReadBarrierTrigger(ref);
     return ref;
     // jiacheng end
   }
@@ -143,13 +143,13 @@ inline MirrorType* ReadBarrier::BarrierForRoot(MirrorType** root,
       }
       AssertToSpaceInvariant(gc_root_source, ref);
       // jiacheng start
-      jiacheng::ReaderBarrierTrigger(ref);
+      jiacheng::ReadBarrierTrigger(ref);
       // jiacheng end
       return ref;
     } else if (kUseBrooksReadBarrier) {
       // To be implemented.
       // jiacheng start
-      jiacheng::ReaderBarrierTrigger(ref);
+      jiacheng::ReadBarrierTrigger(ref);
       // jiacheng end
       return ref;
     } else if (kUseTableLookupReadBarrier) {
@@ -167,7 +167,7 @@ inline MirrorType* ReadBarrier::BarrierForRoot(MirrorType** root,
       }
       AssertToSpaceInvariant(gc_root_source, ref);
       // jiacheng start
-      jiacheng::ReaderBarrierTrigger(ref);
+      jiacheng::ReadBarrierTrigger(ref);
       // jiacheng end
       return ref;
     } else {
@@ -176,7 +176,7 @@ inline MirrorType* ReadBarrier::BarrierForRoot(MirrorType** root,
     }
   } else {
     // jiacheng start
-    jiacheng::ReaderBarrierTrigger(ref);
+    jiacheng::ReadBarrierTrigger(ref);
     // jiacheng end
     return ref;
   }
@@ -196,13 +196,13 @@ inline MirrorType* ReadBarrier::BarrierForRoot(mirror::CompressedReference<Mirro
     }
     AssertToSpaceInvariant(gc_root_source, ref);
     // jiacheng start
-    jiacheng::ReaderBarrierTrigger(ref);
+    jiacheng::ReadBarrierTrigger(ref);
     // jiacheng end
     return ref;
   } else if (with_read_barrier && kUseBrooksReadBarrier) {
     // To be implemented.
     // jiacheng start
-    jiacheng::ReaderBarrierTrigger(ref);
+    jiacheng::ReadBarrierTrigger(ref);
     // jiacheng end
     return ref;
   } else if (with_read_barrier && kUseTableLookupReadBarrier) {
@@ -222,12 +222,12 @@ inline MirrorType* ReadBarrier::BarrierForRoot(mirror::CompressedReference<Mirro
     }
     AssertToSpaceInvariant(gc_root_source, ref);
     // jiacheng start
-    jiacheng::ReaderBarrierTrigger(ref);
+    jiacheng::ReadBarrierTrigger(ref);
     // jiacheng end
     return ref;
   } else {
     // jiacheng start
-    jiacheng::ReaderBarrierTrigger(ref);
+    jiacheng::ReadBarrierTrigger(ref);
     // jiacheng end
     return ref;
   }
-- 
2.34.1


From e3ac61424e53d7973c85496e410088aa5c14f316 Mon Sep 17 00:00:00 2001
From: jiachengh <jiacheng.huang@outlook.com>
Date: Wed, 4 May 2022 20:47:26 +0800
Subject: [PATCH 3/7] start removing bloom filter

Change-Id: Ib4ef1e9cf1e53290a93ec376a090111609028f84
Signed-off-by: jiachengh <jiacheng.huang@outlook.com>
---
 compiler/optimizing/code_generator.cc         |   4 +-
 compiler/optimizing/code_generator_arm64.cc   | 347 ++++++++++++-
 compiler/optimizing/code_generator_arm64.h    |  20 +
 .../instruction_simplifier_shared.cc          |   7 +
 dex2oat/dex2oat.cc                            |   5 +-
 libartbase/base/macros.h                      |  11 +-
 runtime/Android.bp                            |   5 +-
 runtime/arch/arm/entrypoints_init_arm.cc      |   9 +
 runtime/arch/arm64/entrypoints_init_arm64.cc  |   8 +
 runtime/class_linker_test.cc                  |  24 +-
 .../quick/quick_entrypoints_list.h            |   3 +
 runtime/fault_handler.cc                      |   9 +
 runtime/gc/collector/concurrent_copying-inl.h |  81 ++-
 runtime/gc/collector/concurrent_copying.cc    | 301 +++++++----
 runtime/gc/collector/concurrent_copying.h     |  15 +
 runtime/gc/heap.cc                            |  65 +--
 runtime/gc/heap.h                             |   6 +
 runtime/gc/space/image_space.cc               |  10 +-
 runtime/gc/space/region_space-inl.h           |  24 +
 runtime/gc/space/region_space.cc              | 442 +++++++++++++++-
 runtime/gc/space/region_space.h               | 162 +++++-
 runtime/interpreter/interpreter.cc            |   5 +-
 runtime/jiacheng_activity_manager.h           |   5 +-
 runtime/jiacheng_barrier.cc                   |  42 ++
 runtime/jiacheng_barrier.h                    |  16 +
 runtime/jiacheng_bloom_filter.h               | 133 +++++
 runtime/jiacheng_cheatsheet.cc                |  34 +-
 runtime/jiacheng_cheatsheet.h                 |  38 +-
 runtime/jiacheng_cold_space.cc                | 171 -------
 runtime/jiacheng_cold_space.h                 | 103 ----
 runtime/jiacheng_debug.cc                     | 472 ++++++++++++++++++
 runtime/jiacheng_debug.h                      |  63 +++
 runtime/jiacheng_hack.cc                      | 357 ++++---------
 runtime/jiacheng_hack.h                       |  54 +-
 runtime/jiacheng_profiler.cc                  | 187 ++++---
 runtime/jiacheng_profiler.h                   |  49 +-
 runtime/jiacheng_region.cc                    |  41 --
 runtime/jiacheng_region.h                     |  59 ---
 runtime/jiacheng_swapper.cc                   | 187 +++++++
 runtime/jiacheng_swapper.h                    |  61 +++
 runtime/jiacheng_utils.cc                     | 325 ++++--------
 runtime/jiacheng_utils.h                      |  65 +--
 runtime/jni/java_vm_ext.cc                    |   1 +
 runtime/jni/jni_internal.cc                   |   3 +
 runtime/mirror/array-inl.h                    |   9 +
 runtime/mirror/array.h                        |  18 +-
 runtime/mirror/class.cc                       |   1 -
 runtime/mirror/object-inl.h                   |   7 +
 runtime/mirror/object.cc                      |   9 +
 runtime/mirror/object.h                       |  31 +-
 runtime/native/dalvik_system_VMRuntime.cc     |  11 +-
 runtime/read_barrier-inl.h                    |  44 +-
 52 files changed, 2772 insertions(+), 1387 deletions(-)
 create mode 100644 runtime/jiacheng_barrier.cc
 create mode 100644 runtime/jiacheng_barrier.h
 create mode 100644 runtime/jiacheng_bloom_filter.h
 delete mode 100644 runtime/jiacheng_cold_space.cc
 delete mode 100644 runtime/jiacheng_cold_space.h
 create mode 100644 runtime/jiacheng_debug.cc
 create mode 100644 runtime/jiacheng_debug.h
 delete mode 100644 runtime/jiacheng_region.cc
 delete mode 100644 runtime/jiacheng_region.h
 create mode 100644 runtime/jiacheng_swapper.cc
 create mode 100644 runtime/jiacheng_swapper.h

diff --git a/compiler/optimizing/code_generator.cc b/compiler/optimizing/code_generator.cc
index 2bbb570c8d..576f18f5cb 100644
--- a/compiler/optimizing/code_generator.cc
+++ b/compiler/optimizing/code_generator.cc
@@ -497,9 +497,11 @@ void CodeGenerator::InitializeCodeGeneration(size_t number_of_spill_slots,
 void CodeGenerator::CreateCommonInvokeLocationSummary(
     HInvoke* invoke, InvokeDexCallingConventionVisitor* visitor) {
   ArenaAllocator* allocator = invoke->GetBlock()->GetGraph()->GetAllocator();
+  // jiacheng start
   LocationSummary* locations = new (allocator) LocationSummary(invoke,
                                                                LocationSummary::kCallOnMainOnly);
-
+  // LocationSummary* locations = new (allocator) LocationSummary(invoke, LocationSummary::kCallOnMainAndSlowPath, true);
+  // jiacheng end
   for (size_t i = 0; i < invoke->GetNumberOfArguments(); i++) {
     HInstruction* input = invoke->InputAt(i);
     locations->SetInAt(i, visitor->GetNextLocation(input->GetType()));
diff --git a/compiler/optimizing/code_generator_arm64.cc b/compiler/optimizing/code_generator_arm64.cc
index 3086882678..99287cf900 100644
--- a/compiler/optimizing/code_generator_arm64.cc
+++ b/compiler/optimizing/code_generator_arm64.cc
@@ -840,6 +840,42 @@ class ReadBarrierForRootSlowPathARM64 : public SlowPathCodeARM64 {
   DISALLOW_COPY_AND_ASSIGN(ReadBarrierForRootSlowPathARM64);
 };
 
+// jiacheng start
+class JiachengBarrierSlowPathARM64 : public SlowPathCodeARM64 {
+ public:
+  JiachengBarrierSlowPathARM64(HInstruction* instruction, Location obj)
+      : SlowPathCodeARM64(instruction), obj_(obj) {
+  }
+
+  void EmitNativeCode(CodeGenerator* codegen) override {
+    CodeGeneratorARM64* arm64_codegen = down_cast<CodeGeneratorARM64*>(codegen);
+    LocationSummary* locations = instruction_->GetLocations();
+    DataType::Type type = DataType::Type::kUint64;
+    
+    __ Bind(GetEntryLabel());
+    SaveLiveRegisters(codegen, locations);
+
+    InvokeRuntimeCallingConvention calling_convention;
+    arm64_codegen->MoveLocation(LocationFrom(calling_convention.GetRegisterAt(0)), obj_, type);
+    arm64_codegen->InvokeRuntime(kQuickJiachengBarrier,
+                                 instruction_,
+                                 instruction_->GetDexPc(),
+                                 this);
+    RestoreLiveRegisters(codegen, locations);
+    __ B(GetExitLabel());
+  }
+
+  bool IsFatal() const override { return true; }
+
+  const char* GetDescription() const override { return "JiachengBarrierSlowPathARM64"; }
+
+ private:
+  const Location obj_;
+
+  DISALLOW_COPY_AND_ASSIGN(JiachengBarrierSlowPathARM64);
+};
+// jiacheng end
+
 #undef __
 
 Location InvokeDexCallingConventionVisitorARM64::GetNextLocation(DataType::Type type) {
@@ -1834,13 +1870,20 @@ void LocationsBuilderARM64::HandleFieldGet(HInstruction* instruction,
 
   bool object_field_get_with_read_barrier =
       kEmitCompilerReadBarrier && (instruction->GetType() == DataType::Type::kReference);
-  LocationSummary* locations =
-      new (GetGraph()->GetAllocator()) LocationSummary(instruction,
-                                                       object_field_get_with_read_barrier
-                                                           ? LocationSummary::kCallOnSlowPath
-                                                           : LocationSummary::kNoCall);
+  // jiacheng start
+  // LocationSummary* locations =
+  //     new (GetGraph()->GetAllocator()) LocationSummary(instruction,
+  //                                                      object_field_get_with_read_barrier
+  //                                                          ? LocationSummary::kCallOnSlowPath
+  //                                                          : LocationSummary::kNoCall);
+  LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kCallOnSlowPath);
+  // jiacheng end
+
   if (object_field_get_with_read_barrier && kUseBakerReadBarrier) {
-    locations->SetCustomSlowPathCallerSaves(RegisterSet::Empty());  // No caller-save registers.
+    // jiacheng start
+    // locations->SetCustomSlowPathCallerSaves(RegisterSet::Empty());  // No caller-save registers.
+    // jiacheng end
+
     // We need a temporary register for the read barrier load in
     // CodeGeneratorARM64::GenerateFieldLoadWithBakerReadBarrier()
     // only if the field is volatile or the offset is too big.
@@ -1856,6 +1899,7 @@ void LocationsBuilderARM64::HandleFieldGet(HInstruction* instruction,
     // The output overlaps for an object field get when read barriers
     // are enabled: we do not want the load to overwrite the object's
     // location, as we need it to emit the read barrier.
+
     locations->SetOut(
         Location::RequiresRegister(),
         object_field_get_with_read_barrier ? Location::kOutputOverlap : Location::kNoOutputOverlap);
@@ -1873,6 +1917,10 @@ void InstructionCodeGeneratorARM64::HandleFieldGet(HInstruction* instruction,
   DataType::Type load_type = instruction->GetType();
   MemOperand field = HeapOperand(InputRegisterAt(instruction, 0), field_info.GetFieldOffset());
 
+  // jiacheng start
+  codegen_->GenerateJiachengBarrier(instruction, base_loc);
+  // jiacheng end
+
   if (kEmitCompilerReadBarrier && kUseBakerReadBarrier &&
       load_type == DataType::Type::kReference) {
     // Object FieldGet with Baker's read barrier case.
@@ -1914,8 +1962,13 @@ void InstructionCodeGeneratorARM64::HandleFieldGet(HInstruction* instruction,
 }
 
 void LocationsBuilderARM64::HandleFieldSet(HInstruction* instruction) {
+  // jiacheng start
+  // LocationSummary* locations =
+  //     new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kNoCall);
   LocationSummary* locations =
-      new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kNoCall);
+      new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kCallOnSlowPath);
+  // jiacheng end
+
   locations->SetInAt(0, Location::RequiresRegister());
   if (IsConstantZeroBitPattern(instruction->InputAt(1))) {
     locations->SetInAt(1, Location::ConstantLocation(instruction->InputAt(1)->AsConstant()));
@@ -1937,6 +1990,10 @@ void InstructionCodeGeneratorARM64::HandleFieldSet(HInstruction* instruction,
   Offset offset = field_info.GetFieldOffset();
   DataType::Type field_type = field_info.GetFieldType();
 
+  // jiacheng start
+  codegen_->GenerateJiachengBarrier(instruction, LocationFrom(obj));
+  // jiacheng end
+  
   {
     // We use a block to end the scratch scope before the write barrier, thus
     // freeing the temporary registers so they can be used in `MarkGCCard`.
@@ -2302,13 +2359,19 @@ void InstructionCodeGeneratorARM64::VisitMultiplyAccumulate(HMultiplyAccumulate*
 void LocationsBuilderARM64::VisitArrayGet(HArrayGet* instruction) {
   bool object_array_get_with_read_barrier =
       kEmitCompilerReadBarrier && (instruction->GetType() == DataType::Type::kReference);
-  LocationSummary* locations =
-      new (GetGraph()->GetAllocator()) LocationSummary(instruction,
-                                                       object_array_get_with_read_barrier
-                                                           ? LocationSummary::kCallOnSlowPath
-                                                           : LocationSummary::kNoCall);
+  // jiacheng start
+  // LocationSummary* locations =
+  //     new (GetGraph()->GetAllocator()) LocationSummary(instruction,
+  //                                                      object_array_get_with_read_barrier
+  //                                                          ? LocationSummary::kCallOnSlowPath
+  //                                                          : LocationSummary::kNoCall);
+  LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kCallOnSlowPath);
+  // jiacheng end
+
   if (object_array_get_with_read_barrier && kUseBakerReadBarrier) {
-    locations->SetCustomSlowPathCallerSaves(RegisterSet::Empty());  // No caller-save registers.
+    // jiacheng start
+    // locations->SetCustomSlowPathCallerSaves(RegisterSet::Empty());  // No caller-save registers.
+    // jiacheng end
     if (instruction->GetIndex()->IsConstant()) {
       // Array loads with constant index are treated as field loads.
       // We need a temporary register for the read barrier load in
@@ -2353,6 +2416,10 @@ void InstructionCodeGeneratorARM64::VisitArrayGet(HArrayGet* instruction) {
   MacroAssembler* masm = GetVIXLAssembler();
   UseScratchRegisterScope temps(masm);
 
+  // jiacheng start
+  codegen_->GenerateJiachengBarrier(instruction, LocationFrom(obj));
+  // jiacheng end
+
   // The non-Baker read barrier instrumentation of object ArrayGet instructions
   // does not support the HIntermediateAddress instruction.
   DCHECK(!((type == DataType::Type::kReference) &&
@@ -2474,7 +2541,11 @@ void InstructionCodeGeneratorARM64::VisitArrayGet(HArrayGet* instruction) {
 }
 
 void LocationsBuilderARM64::VisitArrayLength(HArrayLength* instruction) {
-  LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction);
+  // jiacheng start
+  // LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction);
+  LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kCallOnSlowPath);
+  // jiacheng end
+
   locations->SetInAt(0, Location::RequiresRegister());
   locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
 }
@@ -2482,6 +2553,12 @@ void LocationsBuilderARM64::VisitArrayLength(HArrayLength* instruction) {
 void InstructionCodeGeneratorARM64::VisitArrayLength(HArrayLength* instruction) {
   uint32_t offset = CodeGenerator::GetArrayLengthOffset(instruction);
   vixl::aarch64::Register out = OutputRegister(instruction);
+  
+  // jiacheng start
+  Register obj = InputRegisterAt(instruction, 0);
+  codegen_->GenerateJiachengBarrier(instruction, LocationFrom(obj));
+  // jiacheng end
+
   {
     // Ensure that between load and MaybeRecordImplicitNullCheck there are no pools emitted.
     EmissionCheckScope guard(GetVIXLAssembler(), kMaxMacroInstructionSizeInBytes);
@@ -2497,12 +2574,16 @@ void InstructionCodeGeneratorARM64::VisitArrayLength(HArrayLength* instruction)
 void LocationsBuilderARM64::VisitArraySet(HArraySet* instruction) {
   DataType::Type value_type = instruction->GetComponentType();
 
+
+  // jiacheng start
   bool may_need_runtime_call_for_type_check = instruction->NeedsTypeCheck();
   LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(
       instruction,
       may_need_runtime_call_for_type_check ?
           LocationSummary::kCallOnSlowPath :
           LocationSummary::kNoCall);
+  // LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kCallOnSlowPath);
+  // jiacheng end
   locations->SetInAt(0, Location::RequiresRegister());
   locations->SetInAt(1, Location::RegisterOrConstant(instruction->InputAt(1)));
   if (IsConstantZeroBitPattern(instruction->InputAt(2))) {
@@ -2529,6 +2610,11 @@ void InstructionCodeGeneratorARM64::VisitArraySet(HArraySet* instruction) {
   MemOperand destination = HeapOperand(array);
   MacroAssembler* masm = GetVIXLAssembler();
 
+  // jiacheng start
+  // codegen_->GenerateJiachengBarrier(instruction, LocationFrom(array));
+  // codegen_->GenerateJiachengBarrierRaw(instruction, LocationFrom(array));
+  // jiacheng end
+
   if (!needs_write_barrier) {
     DCHECK(!may_need_runtime_call_for_type_check);
     if (index.IsConstant()) {
@@ -3982,6 +4068,10 @@ void InstructionCodeGeneratorARM64::VisitInvokeInterface(HInvokeInterface* invok
   // Ensure that between load and MaybeRecordImplicitNullCheck there are no pools emitted.
   if (receiver.IsStackSlot()) {
     __ Ldr(temp.W(), StackOperandFrom(receiver));
+    // jiacheng start
+    // codegen_->GenerateJiachengBarrier(invoke, LocationFrom(temp));
+    // codegen_->GenerateJiachengBarrierRaw(invoke, LocationFrom(temp));
+    // jiacheng end
     {
       EmissionCheckScope guard(GetVIXLAssembler(), kMaxMacroInstructionSizeInBytes);
       // /* HeapReference<Class> */ temp = temp->klass_
@@ -3989,6 +4079,10 @@ void InstructionCodeGeneratorARM64::VisitInvokeInterface(HInvokeInterface* invok
       codegen_->MaybeRecordImplicitNullCheck(invoke);
     }
   } else {
+    // jiacheng start
+    // codegen_->GenerateJiachengBarrier(invoke, receiver);
+    // codegen_->GenerateJiachengBarrierRaw(invoke, receiver);
+    // jiacheng end
     EmissionCheckScope guard(GetVIXLAssembler(), kMaxMacroInstructionSizeInBytes);
     // /* HeapReference<Class> */ temp = receiver->klass_
     __ Ldr(temp.W(), HeapOperandFrom(receiver, class_offset));
@@ -4007,6 +4101,12 @@ void InstructionCodeGeneratorARM64::VisitInvokeInterface(HInvokeInterface* invok
       MemOperand(temp, mirror::Class::ImtPtrOffset(kArm64PointerSize).Uint32Value()));
   uint32_t method_offset = static_cast<uint32_t>(ImTable::OffsetOfElement(
       invoke->GetImtIndex(), kArm64PointerSize));
+
+  // jiacheng start
+  // codegen_->GenerateJiachengBarrier(invoke, LocationFrom(temp));
+  // codegen_->GenerateJiachengBarrierRaw(invoke, LocationFrom(temp));
+  // jiacheng end
+
   // temp = temp->GetImtEntryAt(method_offset);
   __ Ldr(temp, MemOperand(temp, method_offset));
   // lr = temp->GetEntryPoint();
@@ -4167,6 +4267,11 @@ void CodeGeneratorARM64::GenerateVirtualCall(
   Offset entry_point = ArtMethod::EntryPointFromQuickCompiledCodeOffset(kArm64PointerSize);
 
   DCHECK(receiver.IsRegister());
+  
+  // jiacheng start
+  // GenerateJiachengBarrier(LocationFrom(receiver));
+  // codegen_->GenerateJiachengBarrierRaw(invoke, LocationFrom(receiver));
+  // jiacheng end
 
   {
     // Ensure that between load and MaybeRecordImplicitNullCheck there are no pools emitted.
@@ -4182,6 +4287,12 @@ void CodeGeneratorARM64::GenerateVirtualCall(
   // intact/accessible until the end of the marking phase (the
   // concurrent copying collector may not in the future).
   GetAssembler()->MaybeUnpoisonHeapReference(temp.W());
+
+  // jiacheng start
+  // GenerateJiachengBarrier(LocationFrom(temp));
+  // codegen_->GenerateJiachengBarrierRaw(invoke, LocationFrom(temp));
+  // jiacheng end
+
   // temp = temp->GetMethodAt(method_offset);
   __ Ldr(temp, MemOperand(temp, method_offset));
   // lr = temp->GetEntryPoint();
@@ -5704,6 +5815,12 @@ void InstructionCodeGeneratorARM64::GenerateReferenceLoadOneRegister(
     ReadBarrierOption read_barrier_option) {
   DataType::Type type = DataType::Type::kReference;
   Register out_reg = RegisterFrom(out, type);
+
+  // jiacheng start
+  // codegen_->GenerateJiachengBarrier(LocationFrom(out_reg));
+  // codegen_->GenerateJiachengBarrierRaw(instruction, LocationFrom(out_reg));
+  // jiacheng end
+  
   if (read_barrier_option == kWithReadBarrier) {
     CHECK(kEmitCompilerReadBarrier);
     if (kUseBakerReadBarrier) {
@@ -5745,6 +5862,12 @@ void InstructionCodeGeneratorARM64::GenerateReferenceLoadTwoRegisters(
   DataType::Type type = DataType::Type::kReference;
   Register out_reg = RegisterFrom(out, type);
   Register obj_reg = RegisterFrom(obj, type);
+
+  // jiacheng start
+  // codegen_->GenerateJiachengBarrier(LocationFrom(obj_reg));
+  // codegen_->GenerateJiachengBarrierRaw(instruction, LocationFrom(obj_reg));
+  // jiacheng end
+
   if (read_barrier_option == kWithReadBarrier) {
     CHECK(kEmitCompilerReadBarrier);
     if (kUseBakerReadBarrier) {
@@ -5780,6 +5903,12 @@ void CodeGeneratorARM64::GenerateGcRootFieldLoad(
     ReadBarrierOption read_barrier_option) {
   DCHECK(fixup_label == nullptr || offset == 0u);
   Register root_reg = RegisterFrom(root, DataType::Type::kReference);
+
+  // jiacheng start
+  // GenerateJiachengBarrier(LocationFrom(obj));
+  // codegen_->GenerateJiachengBarrierRaw(instruction, LocationFrom(obj));
+  // jiacheng end
+
   if (read_barrier_option == kWithReadBarrier) {
     DCHECK(kEmitCompilerReadBarrier);
     if (kUseBakerReadBarrier) {
@@ -6116,6 +6245,196 @@ void CodeGeneratorARM64::GenerateReadBarrierForRootSlow(HInstruction* instructio
   __ Bind(slow_path->GetExitLabel());
 }
 
+// jiacheng start
+void CodeGeneratorARM64::GenerateJiachengBarrier(HInstruction* instruction, Location obj) {
+  SlowPathCodeARM64* slow_path = new (GetScopedAllocator()) JiachengBarrierSlowPathARM64(instruction, obj);
+  AddSlowPath(slow_path);
+
+  __ B(slow_path->GetEntryLabel());
+  __ Bind(slow_path->GetExitLabel());
+}
+
+void CodeGeneratorARM64::GenerateJiachengBarrierRaw(HInstruction* instruction, Location obj) {
+  // UseScratchRegisterScope temps(GetVIXLAssembler());
+  vixl::aarch64::Label doneLabel;
+
+  // Register temp = temps.AcquireX();
+  // CHECK(temp.GetCode() != 0);
+  std::vector<CPURegister> registersToMaybeSave;
+  registersToMaybeSave.push_back(RegisterFrom(obj, DataType::Type::kReference));
+  LocationSummary* locations = instruction->GetLocations();
+  std::vector<CPURegister> registersToSave = IdentifyRegistersToSave(registersToMaybeSave,
+                                                                     locations);
+  GenerateSaveRegisters(registersToSave);
+  DataType::Type type = DataType::Type::kReference;
+  InvokeRuntimeCallingConvention callingConvention;
+  MoveLocation(LocationFrom(callingConvention.GetRegisterAt(0)), obj, type);
+  int32_t entryPointOffset = QUICK_ENTRY_POINT(pJiachengBarrier);
+  __ Ldr(lr, MemOperand(tr, entryPointOffset));
+  __ Blr(lr);
+  GenerateRestoreRegisters(registersToSave);
+
+  __ Bind(&doneLabel);
+}
+
+std::vector<vixl::aarch64::CPURegister> CodeGeneratorARM64::IdentifyRegistersToSave(
+                                    const std::vector<vixl::aarch64::CPURegister> & registersToMaybeSave,
+                                    LocationSummary * locations) {
+  std::set<int> coreRegCodes; 
+  std::set<int> fpRegCodes;   
+
+  for (size_t i = 0; i < registersToMaybeSave.size(); i++) {
+    CPURegister reg = registersToMaybeSave[i];
+    CHECK(reg.IsRegister() || reg.IsFPRegister());
+    int artCode = helpers::ARTRegCodeFromVIXL(reg.GetCode());
+    if (reg.IsRegister() && !IsCoreCalleeSaveRegister(artCode)) {
+      coreRegCodes.insert(reg.GetCode());
+    }
+    else if (reg.IsFPRegister() && !IsFloatingPointCalleeSaveRegister(artCode)) {
+      fpRegCodes.insert(reg.GetCode());
+    }
+  }
+
+  RegisterSet * liveRegisterSet = locations->GetLiveRegisters();
+  for (size_t i = 0; i < GetNumberOfCoreRegisters(); i++) {
+    if (!IsCoreCalleeSaveRegister(i) && liveRegisterSet->ContainsCoreRegister(i)) {
+      coreRegCodes.insert(i);
+    }
+  }
+  for (size_t i = 0; i < GetNumberOfFloatingPointRegisters(); i++) {
+    if (   !IsFloatingPointCalleeSaveRegister(i)
+        && liveRegisterSet->ContainsFloatingPointRegister(i)) {
+      fpRegCodes.insert(i);
+    }
+  }
+
+  for (int i = 0; i < 8; i++) {
+    coreRegCodes.insert(i);
+  }
+  for (int i = 0; i < 8; i++) {
+    fpRegCodes.insert(i);
+  }
+
+  std::vector<CPURegister> registersToSave;
+
+  for (auto it = coreRegCodes.begin(); it != coreRegCodes.end(); it++) {
+    registersToSave.push_back(Register::GetXRegFromCode(*it));
+  }
+  for (auto it = fpRegCodes.begin(); it != fpRegCodes.end(); it++) {
+    registersToSave.push_back(VRegister::GetDRegFromCode(*it));
+  }
+  return registersToSave;
+}
+
+const int REGISTER_WIDTH = 8;
+
+int CodeGeneratorARM64::ComputeStackGrowthSize(const std::vector<vixl::aarch64::CPURegister> & registersToSave) {
+  int stackGrowthSize = 0;
+  if (registersToSave.size() > 0) {
+    stackGrowthSize = registersToSave.size() * REGISTER_WIDTH;
+    if (stackGrowthSize % 16 > 0) {
+      stackGrowthSize = stackGrowthSize + (16 - stackGrowthSize % 16);
+    }
+  }
+  return stackGrowthSize;
+}
+
+void CodeGeneratorARM64::GetTypedRegisterLists(const std::vector<vixl::aarch64::CPURegister> & registersToSave,
+                            std::vector<vixl::aarch64::Register> & coreRegisters,
+                            std::vector<vixl::aarch64::VRegister> & vRegisters) {
+  CHECK(coreRegisters.size() == 0);
+  CHECK(vRegisters.size() == 0);
+  for (size_t i = 0; i < registersToSave.size(); i++) {
+    CPURegister reg = registersToSave[i];
+    if (reg.IsRegister()) {
+      coreRegisters.push_back(Register(reg));
+    }
+    else if (reg.IsVRegister()) {
+      vRegisters.push_back(VRegister(reg));
+    }
+  }
+  CHECK(coreRegisters.size() + vRegisters.size() == registersToSave.size());
+}
+
+void CodeGeneratorARM64::GenerateSaveRegisters(const std::vector<vixl::aarch64::CPURegister> & registersToSave) {
+  int stackGrowthSize = ComputeStackGrowthSize(registersToSave);
+
+  std::vector<Register> coreRegisters;
+  std::vector<VRegister> vRegisters;
+  GetTypedRegisterLists(registersToSave, coreRegisters, vRegisters);
+
+  if (registersToSave.size() > 0) {
+    __ Sub(sp, sp, stackGrowthSize);
+    size_t i = 0; // index in current register list
+    size_t memoryOffset = 0; // current offset from SP, in bytes
+    while (i < coreRegisters.size()) {
+      if (i < coreRegisters.size() - 1) {
+        __ Stp(coreRegisters[i], coreRegisters[i + 1], MemOperand(sp, memoryOffset));
+        i += 2;
+        memoryOffset += 2 * REGISTER_WIDTH;
+      }
+      else {
+        __ Str(coreRegisters[i], MemOperand(sp, memoryOffset));
+        i++;
+        memoryOffset += REGISTER_WIDTH;
+      }
+    }
+    i = 0;
+    while (i < vRegisters.size()) {
+      if (i < vRegisters.size() - 1) {
+        __ Stp(vRegisters[i], vRegisters[i + 1], MemOperand(sp, memoryOffset));
+        i += 2;
+        memoryOffset += 2 * REGISTER_WIDTH;
+      }
+      else {
+        __ Str(vRegisters[i], MemOperand(sp, memoryOffset));
+        i++;
+        memoryOffset += REGISTER_WIDTH;
+      }
+    }
+  }
+}
+
+void CodeGeneratorARM64::GenerateRestoreRegisters(const std::vector<vixl::aarch64::CPURegister> & savedRegisters) {
+  int stackGrowthSize = ComputeStackGrowthSize(savedRegisters);
+  std::vector<Register> coreRegisters;
+  std::vector<VRegister> vRegisters;
+  GetTypedRegisterLists(savedRegisters, coreRegisters, vRegisters);
+  if (savedRegisters.size() > 0) {
+    size_t i = 0; // index in current register list
+    size_t memoryOffset = 0; // current offset from SP, in bytes
+    while (i < coreRegisters.size()) {
+      if (i < coreRegisters.size() - 1) {
+        __ Ldp(coreRegisters[i], coreRegisters[i + 1], MemOperand(sp, memoryOffset));
+        i += 2;
+        memoryOffset += 2 * REGISTER_WIDTH;
+      }
+      else {
+        __ Ldr(coreRegisters[i], MemOperand(sp, memoryOffset));
+        i++;
+        memoryOffset += REGISTER_WIDTH;
+      }
+    }
+    i = 0;
+    while (i < vRegisters.size()) {
+      if (i < vRegisters.size() - 1) {
+        __ Ldp(vRegisters[i], vRegisters[i + 1], MemOperand(sp, memoryOffset));
+        i += 2;
+        memoryOffset += 2 * REGISTER_WIDTH;
+      }
+      else {
+        __ Ldr(vRegisters[i], MemOperand(sp, memoryOffset));
+        i++;
+        memoryOffset += REGISTER_WIDTH;
+      }
+    }
+    __ Add(sp, sp, stackGrowthSize);
+  }
+}
+
+
+// jiacheng end
+
 void LocationsBuilderARM64::VisitClassTableGet(HClassTableGet* instruction) {
   LocationSummary* locations =
       new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kNoCall);
diff --git a/compiler/optimizing/code_generator_arm64.h b/compiler/optimizing/code_generator_arm64.h
index ada5742fc0..a996557bc1 100644
--- a/compiler/optimizing/code_generator_arm64.h
+++ b/compiler/optimizing/code_generator_arm64.h
@@ -765,6 +765,26 @@ class CodeGeneratorARM64 : public CodeGenerator {
   // artReadBarrierForRootSlow.
   void GenerateReadBarrierForRootSlow(HInstruction* instruction, Location out, Location root);
 
+  // jiacheng start
+  void GenerateJiachengBarrier(HInstruction* instruction, Location obj);
+
+  void GenerateJiachengBarrierRaw(HInstruction* instruction, Location obj);
+
+  std::vector<vixl::aarch64::CPURegister> IdentifyRegistersToSave(
+                                     const std::vector<vixl::aarch64::CPURegister> & registersToMaybeSave,
+                                     LocationSummary * locations);
+
+  int ComputeStackGrowthSize(const std::vector<vixl::aarch64::CPURegister> & registersToSave);
+
+  void GetTypedRegisterLists(const std::vector<vixl::aarch64::CPURegister> & registersToSave,
+                             std::vector<vixl::aarch64::Register> & coreRegisters,
+                             std::vector<vixl::aarch64::VRegister> & vRegisters);
+
+  void GenerateSaveRegisters(const std::vector<vixl::aarch64::CPURegister> & registersToSave);
+  void GenerateRestoreRegisters(const std::vector<vixl::aarch64::CPURegister> & savedRegisters);
+
+  // jiacheng end
+
   void GenerateNop() override;
 
   void GenerateImplicitNullCheck(HNullCheck* instruction) override;
diff --git a/compiler/optimizing/instruction_simplifier_shared.cc b/compiler/optimizing/instruction_simplifier_shared.cc
index 0f30f662cd..e8f4e9644d 100644
--- a/compiler/optimizing/instruction_simplifier_shared.cc
+++ b/compiler/optimizing/instruction_simplifier_shared.cc
@@ -233,6 +233,13 @@ bool TryExtractArrayAccessAddress(HInstruction* access,
                                   HInstruction* array,
                                   HInstruction* index,
                                   size_t data_offset) {
+  // jiacheng start
+  bool optimizationDisabled = true;
+  if (optimizationDisabled) {
+    return false;
+  }
+  // jiacheng end
+  
   if (index->IsConstant() ||
       (index->IsBoundsCheck() && index->AsBoundsCheck()->GetIndex()->IsConstant())) {
     // When the index is a constant all the addressing can be fitted in the
diff --git a/dex2oat/dex2oat.cc b/dex2oat/dex2oat.cc
index bd9019a81c..278523ec9a 100644
--- a/dex2oat/dex2oat.cc
+++ b/dex2oat/dex2oat.cc
@@ -2241,10 +2241,7 @@ class Dex2Oat final {
   }
 
   bool UseProfile() const {
-    // jiacheng start
-    // return profile_file_fd_ != -1 || !profile_file_.empty();
-    return false;
-    // jiacheng end
+    return profile_file_fd_ != -1 || !profile_file_.empty();
   }
 
   bool DoProfileGuidedOptimizations() const {
diff --git a/libartbase/base/macros.h b/libartbase/base/macros.h
index 323fa4e61b..82bd68bc37 100644
--- a/libartbase/base/macros.h
+++ b/libartbase/base/macros.h
@@ -67,11 +67,14 @@ template<typename T> ART_FRIEND_TEST(test_set_name, individual_test)
 #define APPEND_TOKENS_AFTER_EVAL_2(a, b) a ## b
 #define APPEND_TOKENS_AFTER_EVAL(a, b) APPEND_TOKENS_AFTER_EVAL_2(a, b)
 
-#ifndef NDEBUG
-#define ALWAYS_INLINE
-#else
+// jiacheng start
+// #ifndef NDEBUG
+// #define ALWAYS_INLINE
+// #else
+// #define ALWAYS_INLINE  __attribute__ ((always_inline))
+// #endif
 #define ALWAYS_INLINE  __attribute__ ((always_inline))
-#endif
+// jiacheng end
 
 // clang doesn't like attributes on lambda functions. It would be nice to say:
 //   #define ALWAYS_INLINE_LAMBDA ALWAYS_INLINE
diff --git a/runtime/Android.bp b/runtime/Android.bp
index 80db5b4e86..847cd4e90d 100644
--- a/runtime/Android.bp
+++ b/runtime/Android.bp
@@ -107,12 +107,13 @@ libart_cc_defaults {
         "java_frame_root_info.cc",
 // jiacheng start ------------------------------------
         "jiacheng_cheatsheet.cc",
-        "jiacheng_cold_space.cc",
         "jiacheng_hack.cc",
-        "jiacheng_region.cc",
         "jiacheng_activity_manager.cc",
         "jiacheng_utils.cc",
         "jiacheng_profiler.cc",
+        "jiacheng_swapper.cc",
+        "jiacheng_debug.cc",
+        "jiacheng_barrier.cc",
 // jiacheng end --------------------------------------
         "jdwp/jdwp_event.cc",
         "jdwp/jdwp_expand_buf.cc",
diff --git a/runtime/arch/arm/entrypoints_init_arm.cc b/runtime/arch/arm/entrypoints_init_arm.cc
index c1a03abd96..b98670a614 100644
--- a/runtime/arch/arm/entrypoints_init_arm.cc
+++ b/runtime/arch/arm/entrypoints_init_arm.cc
@@ -29,6 +29,10 @@
 #include "entrypoints/runtime_asm_entrypoints.h"
 #include "interpreter/interpreter.h"
 
+// jiacheng start
+#include "jiacheng_barrier.h"
+// jiacheng end
+
 namespace art {
 
 // Cast entrypoints.
@@ -78,6 +82,7 @@ extern "C" int __aeabi_idivmod(int32_t, int32_t);  // [DIV|REM]_INT[_2ADDR|_LIT8
 extern "C" int64_t __aeabi_ldivmod(int64_t, int64_t);
 
 void UpdateReadBarrierEntrypoints(QuickEntryPoints* qpoints, bool is_active) {
+  
   qpoints->pReadBarrierMarkReg00 = is_active ? art_quick_read_barrier_mark_reg00 : nullptr;
   qpoints->pReadBarrierMarkReg01 = is_active ? art_quick_read_barrier_mark_reg01 : nullptr;
   qpoints->pReadBarrierMarkReg02 = is_active ? art_quick_read_barrier_mark_reg02 : nullptr;
@@ -196,6 +201,10 @@ void InitEntryPoints(JniEntryPoints* jpoints, QuickEntryPoints* qpoints) {
   qpoints->pReadBarrierMarkReg29 = nullptr;
   qpoints->pReadBarrierSlow = artReadBarrierSlow;
   qpoints->pReadBarrierForRootSlow = artReadBarrierForRootSlow;
+  
+  // jiacheng start
+  qpoints->pJiachengBarrier = jiacheng::JiachengBarrier;
+  // jiacheng end
 }
 
 }  // namespace art
diff --git a/runtime/arch/arm64/entrypoints_init_arm64.cc b/runtime/arch/arm64/entrypoints_init_arm64.cc
index 22f0c28f45..5d982c534d 100644
--- a/runtime/arch/arm64/entrypoints_init_arm64.cc
+++ b/runtime/arch/arm64/entrypoints_init_arm64.cc
@@ -29,6 +29,10 @@
 #include "entrypoints/runtime_asm_entrypoints.h"
 #include "interpreter/interpreter.h"
 
+// jiacheng start
+#include "jiacheng_barrier.h"
+// jiacheng end
+
 namespace art {
 
 // Cast entrypoints.
@@ -192,6 +196,10 @@ void InitEntryPoints(JniEntryPoints* jpoints, QuickEntryPoints* qpoints) {
   UpdateReadBarrierEntrypoints(qpoints, /*is_active=*/ false);
   qpoints->pReadBarrierSlow = artReadBarrierSlow;
   qpoints->pReadBarrierForRootSlow = artReadBarrierForRootSlow;
+
+  // jiacheng start
+  qpoints->pJiachengBarrier = jiacheng::JiachengBarrier;
+  // jiacheng end
 }
 
 }  // namespace art
diff --git a/runtime/class_linker_test.cc b/runtime/class_linker_test.cc
index 1a91abe1ed..f5fe0b70a6 100644
--- a/runtime/class_linker_test.cc
+++ b/runtime/class_linker_test.cc
@@ -149,7 +149,10 @@ class ClassLinkerTest : public CommonRuntimeTest {
     EXPECT_EQ(4U, JavaLangObject->NumDirectMethods());
     EXPECT_EQ(11U, JavaLangObject->NumVirtualMethods());
     if (!kUseBrooksReadBarrier) {
-      EXPECT_EQ(2U, JavaLangObject->NumInstanceFields());
+      // jiacheng start
+      // EXPECT_EQ(2U, JavaLangObject->NumInstanceFields());
+      EXPECT_EQ(4U, JavaLangObject->NumInstanceFields());
+      // jiacheng end
     } else {
       EXPECT_EQ(4U, JavaLangObject->NumInstanceFields());
     }
@@ -157,6 +160,18 @@ class ClassLinkerTest : public CommonRuntimeTest {
                  "shadow$_klass_");
     EXPECT_STREQ(JavaLangObject->GetInstanceField(1)->GetName(),
                  "shadow$_monitor_");
+    // jiacheng start
+    EXPECT_STREQ(JavaLangObject->GetInstanceField(2)->GetName(),
+                 "shadow$_z_padding_");
+    EXPECT_STREQ(JavaLangObject->GetInstanceField(3)->GetName(),
+                 "shadow$_z_zflags0_");
+    EXPECT_STREQ(JavaLangObject->GetInstanceField(4)->GetName(),
+                 "shadow$_z_zflags1_");
+    EXPECT_STREQ(JavaLangObject->GetInstanceField(5)->GetName(),
+                 "shadow$_z_zflags2_");
+    EXPECT_STREQ(JavaLangObject->GetInstanceField(6)->GetName(),
+                 "shadow$_z_zflags3_");
+    // jiacheng end
     if (kUseBrooksReadBarrier) {
       EXPECT_STREQ(JavaLangObject->GetInstanceField(2)->GetName(),
                    "shadow$_x_rb_ptr_");
@@ -566,6 +581,13 @@ struct ObjectOffsets : public CheckOffsets<mirror::Object> {
   ObjectOffsets() : CheckOffsets<mirror::Object>(false, "Ljava/lang/Object;") {
     addOffset(OFFSETOF_MEMBER(mirror::Object, klass_), "shadow$_klass_");
     addOffset(OFFSETOF_MEMBER(mirror::Object, monitor_), "shadow$_monitor_");
+    // jiacheng start
+    addOffset(OFFSETOF_MEMBER(mirror::Object, z_padding_), "shadow$_z_padding_");
+    addOffset(OFFSETOF_MEMBER(mirror::Object, z_zflags0_), "shadow$_z_zflags0_");
+    addOffset(OFFSETOF_MEMBER(mirror::Object, z_zflags1_), "shadow$_z_zflags1_");
+    addOffset(OFFSETOF_MEMBER(mirror::Object, z_zflags2_), "shadow$_z_zflags2_");
+    addOffset(OFFSETOF_MEMBER(mirror::Object, z_zflags3_), "shadow$_z_zflags3_");
+    // jiacheng end
 #ifdef USE_BROOKS_READ_BARRIER
     addOffset(OFFSETOF_MEMBER(mirror::Object, x_rb_ptr_), "shadow$_x_rb_ptr_");
     addOffset(OFFSETOF_MEMBER(mirror::Object, x_xpadding_), "shadow$_x_xpadding_");
diff --git a/runtime/entrypoints/quick/quick_entrypoints_list.h b/runtime/entrypoints/quick/quick_entrypoints_list.h
index 42b680e05a..57b555955c 100644
--- a/runtime/entrypoints/quick/quick_entrypoints_list.h
+++ b/runtime/entrypoints/quick/quick_entrypoints_list.h
@@ -202,6 +202,9 @@
   V(ReadBarrierMarkReg29, mirror::Object*, mirror::Object*) \
   V(ReadBarrierSlow, mirror::Object*, mirror::Object*, mirror::Object*, uint32_t) \
   V(ReadBarrierForRootSlow, mirror::Object*, GcRoot<mirror::Object>*) \
+  /* jiacheng start*/ \
+  V(JiachengBarrier, void, uint64_t) \
+  /* jiacheng end */ \
 \
 
 #endif  // ART_RUNTIME_ENTRYPOINTS_QUICK_QUICK_ENTRYPOINTS_LIST_H_
diff --git a/runtime/fault_handler.cc b/runtime/fault_handler.cc
index 5c2830d96b..a9ce5ad2cd 100644
--- a/runtime/fault_handler.cc
+++ b/runtime/fault_handler.cc
@@ -32,6 +32,10 @@
 #include "thread-current-inl.h"
 #include "verify_object-inl.h"
 
+// jiacheng start
+#include "jiacheng_hack.h"
+// jiacheng end
+
 namespace art {
 // Static fault manger object accessed by signal handler.
 FaultManager fault_manager;
@@ -207,6 +211,11 @@ static std::ostream& PrintSignalInfo(std::ostream& os, siginfo_t* info) {
 }
 
 bool FaultManager::HandleFault(int sig, siginfo_t* info, void* context) {
+  // jiacheng start
+  if (jiacheng::HandleFault(sig, info, context)) {
+    return true;
+  }
+  // jiacheng end
   if (VLOG_IS_ON(signals)) {
     PrintSignalInfo(VLOG_STREAM(signals) << "Handling fault:" << "\n", info);
   }
diff --git a/runtime/gc/collector/concurrent_copying-inl.h b/runtime/gc/collector/concurrent_copying-inl.h
index ecf7caed2f..c50a1a057c 100644
--- a/runtime/gc/collector/concurrent_copying-inl.h
+++ b/runtime/gc/collector/concurrent_copying-inl.h
@@ -29,8 +29,8 @@
 #include "mirror/object-readbarrier-inl.h"
 
 // jiacheng start  
-#include "jiacheng_cold_space.h"
 #include "jiacheng_hack.h"
+#include "jiacheng_profiler.h"
 // jiacheng end
 
 namespace art {
@@ -154,33 +154,25 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
     // are consulted. If they look like gray but aren't really, the
     // read barriers slow path can trigger when it shouldn't. To guard
     // against this, return here if the CC collector isn't running.
-
-    // jiacheng start
-    jiacheng::GCMarkTrigger(from_ref);
-    // jiacheng end
     return from_ref;
   }
   DCHECK(region_space_ != nullptr) << "Read barrier slow path taken when CC isn't running?";
   // jiahceng start -------------------------------------_
-    if (jiacheng::ColdSpace::Current()->HasAddress(from_ref)) {
-      // Mark在ColdSpace中的对象，把该对象标灰
-      // bool success = from_ref->AtomicSetReadBarrierState(ReadBarrier::WhiteState(), ReadBarrier::GrayState());
-      bool success = from_ref->AtomicSetReadBarrierState(ReadBarrier::NonGrayState(), ReadBarrier::GrayState());
-      if (success) {
-        PushOntoMarkStack(self, from_ref);
-      }
-      jiacheng::GCMarkTrigger(from_ref);
-      return from_ref;
-    }  else if (region_space_->HasAddress(from_ref)) {
-  // if (region_space_->HasAddress(from_ref)) {
+    // if (jiacheng::ColdSpace::Current()->HasAddress(from_ref)) {
+    //   // Mark在ColdSpace中的对象，把该对象标灰
+    //   // bool success = from_ref->AtomicSetReadBarrierState(ReadBarrier::WhiteState(), ReadBarrier::GrayState());
+    //   bool success = from_ref->AtomicSetReadBarrierState(ReadBarrier::NonGrayState(), ReadBarrier::GrayState());
+    //   if (success) {
+    //     PushOntoMarkStack(self, from_ref);
+    //   }
+    //   return from_ref;
+    // }  else if (region_space_->HasAddress(from_ref)) {
+  if (region_space_->HasAddress(from_ref)) {
   // jiacheng end -------------------------------------
     space::RegionSpace::RegionType rtype = region_space_->GetRegionTypeUnsafe(from_ref);
     switch (rtype) {
       case space::RegionSpace::RegionType::kRegionTypeToSpace:
         // It's already marked.
-        // jiacheng start
-        jiacheng::GCMarkTrigger(from_ref);
-        // jiacheng end
         return from_ref;
       case space::RegionSpace::RegionType::kRegionTypeFromSpace: {
         mirror::Object* to_ref = GetFwdPtr(from_ref);
@@ -188,16 +180,16 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
           // It isn't marked yet. Mark it by copying it to the to-space.
           to_ref = Copy(self, from_ref, holder, offset);
         }
+        // jiacheng start
+        jiacheng::Profiler* profiler = jiacheng::Profiler::Current();
+        if (to_ref != from_ref && profiler->TestInAccessWS(from_ref)) {
+          profiler->RecordAccessWS(to_ref);
+        }
+        // jiacheng end
         // The copy should either be in a to-space region, or in the
         // non-moving space, if it could not fit in a to-space region.
-        // jiacheng start
-        // DCHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
-        //     << "from_ref=" << from_ref << " to_ref=" << to_ref;
-        DCHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref) 
-               || jiacheng::ColdSpace::Current()->HasAddress(to_ref))
+        DCHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
             << "from_ref=" << from_ref << " to_ref=" << to_ref;
-        jiacheng::GCMarkTrigger(to_ref);
-        // jiacheng end
         return to_ref;
       }
       case space::RegionSpace::RegionType::kRegionTypeUnevacFromSpace: {
@@ -205,18 +197,19 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
           if (!kFromGCThread) {
             DCHECK(IsMarkedInUnevacFromSpace(from_ref)) << "Returning unmarked object to mutator";
           }
-          // jiacheng start
-          jiacheng::GCMarkTrigger(from_ref);
-          // jiacheng end
           return from_ref;
         }
-        // jiacheng start
-        // return MarkUnevacFromSpaceRegion(self, from_ref, region_space_bitmap_);
-        mirror::Object* temp_ref = MarkUnevacFromSpaceRegion(self, from_ref, region_space_bitmap_);
-        jiacheng::GCMarkTrigger(temp_ref);
-        // jiacheng end
-        return temp_ref;
+        return MarkUnevacFromSpaceRegion(self, from_ref, region_space_bitmap_);
+      }
+      // jiacheng start
+      case space::RegionSpace::RegionType::kRegionTypeColdToSpace: {
+        // Already marked
+        return from_ref;
+      }
+      case space::RegionSpace::RegionType::kRegionTypeColdSpace: {
+        return MarkColdSpaceRegion(self, from_ref, region_space_bitmap_);
       }
+      // jiacheng end
       default:
         // The reference is in an unused region. Remove memory protection from
         // the region space and log debugging information.
@@ -228,19 +221,9 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
     }
   } else {
     if (immune_spaces_.ContainsObject(from_ref)) {
-      // jiacheng start
-      // return MarkImmuneSpace<kGrayImmuneObject>(self, from_ref);
-      mirror::Object* temp_ref = MarkImmuneSpace<kGrayImmuneObject>(self, from_ref);
-      jiacheng::GCMarkTrigger(temp_ref);
-      return temp_ref;
-      // jiacheng end
+      return MarkImmuneSpace<kGrayImmuneObject>(self, from_ref);
     } else {
-      // jiacheng start
-      // return MarkNonMoving(self, from_ref, holder, offset);
-      mirror::Object* temp_ref = MarkNonMoving(self, from_ref, holder, offset);
-      jiacheng::GCMarkTrigger(temp_ref);
-      return temp_ref;
-      // jiacheng end
+      return MarkNonMoving(self, from_ref, holder, offset);
     }
   }
 }
@@ -274,9 +257,7 @@ inline mirror::Object* ConcurrentCopying::MarkFromReadBarrier(mirror::Object* fr
 }
 
 inline mirror::Object* ConcurrentCopying::GetFwdPtr(mirror::Object* from_ref) {
-  // jiacheng start
-  // DCHECK(region_space_->IsInFromSpace(from_ref));
-  // jiacheng end
+  DCHECK(region_space_->IsInFromSpace(from_ref));
   LockWord lw = from_ref->GetLockWord(false);
   if (lw.GetState() == LockWord::kForwardingAddress) {
     mirror::Object* fwd_ptr = reinterpret_cast<mirror::Object*>(lw.ForwardingAddress());
diff --git a/runtime/gc/collector/concurrent_copying.cc b/runtime/gc/collector/concurrent_copying.cc
index 335cdc98a4..b9d5ff1824 100644
--- a/runtime/gc/collector/concurrent_copying.cc
+++ b/runtime/gc/collector/concurrent_copying.cc
@@ -48,9 +48,8 @@
 #include "well_known_classes.h"
 
 // jiacheng start
-#include "jiacheng_cold_space.h"
-#include "jiacheng_activity_manager.h"
 #include "jiacheng_profiler.h"
+#include "jiacheng_utils.h"
 #include <iostream>
 // jiacheng end
 
@@ -74,6 +73,40 @@ static constexpr size_t kSweepArrayChunkFreeSize = 1024;
 // Verify that there are no missing card marks.
 static constexpr bool kVerifyNoMissingCardMarks = kIsDebugBuild;
 
+
+// jiacheng start
+class ConcurrentCopying::RegionRememberedObjectsVisitor {
+ public:
+  explicit RegionRememberedObjectsVisitor(ConcurrentCopying* cc) : collector_(cc) {}
+
+  ALWAYS_INLINE void operator()(mirror::Object* ref) const REQUIRES_SHARED(Locks::mutator_lock_) {
+    if (ref == nullptr) {
+      return;
+    }
+    if (!collector_->TestAndSetMarkBitForRef(ref)) {
+      collector_->PushOntoLocalMarkStack(ref);
+    }
+  }
+
+ private:
+  ConcurrentCopying* const collector_;
+};
+
+class ConcurrentCopying::RegionRememberedObjectsAsRootVisitor {
+ public:
+  explicit RegionRememberedObjectsAsRootVisitor(ConcurrentCopying* cc) : collector_(cc) {}
+
+  ALWAYS_INLINE mirror::Object* operator()(mirror::Object* ref) const REQUIRES_SHARED(Locks::mutator_lock_) {
+    LOG(INFO) << "jiacheng concurrent_copying.cc 1279 ref= " << size_t(ref);
+    return collector_->MarkObject(ref);
+  }
+
+ private:
+  ConcurrentCopying* const collector_;
+};
+// jiacheng end
+
+
 ConcurrentCopying::ConcurrentCopying(Heap* heap,
                                      bool young_gen,
                                      bool use_generational_cc,
@@ -202,16 +235,10 @@ void ConcurrentCopying::RunPhases() {
   {
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
     InitializePhase();
-    // jiacheng start  -------------------
-    LOG(INFO) << "jiacheng concurrent_copying.cc 175 InitializePhase Pass" << std::flush;
-    // jiacheng end ----------------------
     // In case of forced evacuation, all regions are evacuated and hence no
     // need to compute live_bytes.
     if (use_generational_cc_ && !young_gen_ && !force_evacuate_all_) {
       MarkingPhase();
-    // jiacheng start  -------------------
-    LOG(INFO) << "jiacheng concurrent_copying.cc 195 MarkingPhase Pass" << std::flush;
-    // jiacheng end ----------------------
     }
   }
   if (kUseBakerReadBarrier && kGrayDirtyImmuneObjects) {
@@ -222,10 +249,19 @@ void ConcurrentCopying::RunPhases() {
     // the pause.
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
     GrayAllDirtyImmuneObjects();
-    // jiacheng start  -------------------
-    LOG(INFO) << "jiacheng concurrent_copying.cc 187 GrayAllDirtyImmuneObjects Pass" << std::flush;
-    // jiacheng end ----------------------
   }
+  // jiacheng start
+  {
+    LOG(INFO) << "jiacheng concurrent_copying.cc 220";
+    ReaderMutexLock mu(self, *Locks::mutator_lock_);
+    RegionRememberedObjectsAsRootVisitor root_visitor(this);
+    region_space_->VisitRememberedObjectsAsRoot(root_visitor);
+    // TODO remove
+    RegionRememberedObjectsVisitor visitor(this);
+    region_space_->VisitRememberedObjects(visitor);
+  }
+  // jiacheng end
+
   FlipThreadRoots();
   {
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
@@ -249,13 +285,7 @@ void ConcurrentCopying::RunPhases() {
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
     ReclaimPhase();
   }
-  // jiacheng start  -------------------
-  LOG(INFO) << "jiacheng concurrent_copying.cc 219 ReclaimPhase Pass" << std::flush;
-  // jiacheng end ----------------------
   FinishPhase();
-  // jiacheng start  -------------------
-  LOG(INFO) << "jiacheng concurrent_copying.cc 223 FinishPhase Pass" << std::flush;
-  // jiacheng end ----------------------
   CHECK(is_active_);
   is_active_ = false;
   thread_running_gc_ = nullptr;
@@ -1379,6 +1409,19 @@ void ConcurrentCopying::MarkingPhase() {
   }
   // Capture thread roots
   CaptureThreadRootsForMarking();
+
+  // jiacheng start
+  {
+    TimingLogger::ScopedTiming split2("VisitRegionRememberedSet", GetTimings());
+    LOG(INFO) << "jiacheng concurrent_copying.cc 1394";
+    RegionRememberedObjectsAsRootVisitor root_visitor(this);
+    region_space_->VisitRememberedObjectsAsRoot(root_visitor);
+    // TODO remove
+    RegionRememberedObjectsVisitor visitor(this);
+    region_space_->VisitRememberedObjects(visitor);
+  }
+  // jiacheng end
+
   // Process mark stack
   ProcessMarkStackForMarkingAndComputeLiveBytes();
 
@@ -1822,11 +1865,9 @@ void ConcurrentCopying::PushOntoMarkStack(Thread* const self, mirror::Object* to
         << " self->gc_marking=" << self->GetIsGcMarking()
         << " cc->is_marking=" << is_marking_;
 
-    // jiacheng start ----------------------------
-    // CHECK(self == thread_running_gc_)
-    //     << "Only GC-running thread should access the mark stack "
-    //     << "in the GC exclusive mark stack mode";
-    // jiacheng end ------------------------------
+    CHECK(self == thread_running_gc_)
+        << "Only GC-running thread should access the mark stack "
+        << "in the GC exclusive mark stack mode";
 
     // Access the GC mark stack without a lock.
     if (UNLIKELY(gc_mark_stack_->IsFull())) {
@@ -2207,18 +2248,19 @@ inline void ConcurrentCopying::ProcessMarkStackRef(mirror::Object* to_ref) {
       }
       perform_scan = true;
       break;
+    // jiacheng start
+    case space::RegionSpace::RegionType::kRegionTypeColdToSpace:
+      region_space_bitmap_->Set(to_ref);
+      perform_scan = true;
+      break;
+    case space::RegionSpace::RegionType::kRegionTypeColdSpace:
+      if(!region_space_bitmap_->Set(to_ref)) { // old word == 0
+        perform_scan = true;
+        add_to_live_bytes = true;
+      }
+      break;
+    // jiacheng end
     default:
-  // jiacheng start ---------------------------------
-  // code in android 这里不能直接用
-  // else if (jiacheng::ColdSpace::Current()->HasAddress(to_ref)) {
-  //   jiacheng::ColdSpace* cold_space = jiacheng::ColdSpace::Current();
-  //   if (!cold_space->GetMarkBitmap(to_ref)) {
-  //     cold_space->SetMarkBitmap(to_ref);
-  //     Scan(to_ref);
-  //   }
-  // }
-  // jiacheng end -----------------------------------
-
       DCHECK(!region_space_->HasAddress(to_ref)) << to_ref;
       DCHECK(!immune_spaces_.ContainsObject(to_ref));
       // Non-moving or large-object space.
@@ -2283,22 +2325,8 @@ inline void ConcurrentCopying::ProcessMarkStackRef(mirror::Object* to_ref) {
     // Leave this reference gray in the queue so that GetReferent() will trigger a read barrier. We
     
     // will change it to non-gray later in ReferenceQueue::DisableReadBarrierForReference.
-    // jiacheng start --------------------------
-    if (jiacheng::ColdSpace::Current()->HasAddress(referent)) {
-      if (kUseBakerReadBarrier) {
-        bool success = to_ref->AtomicSetReadBarrierState<std::memory_order_release>(
-            ReadBarrier::GrayState(),
-            ReadBarrier::NonGrayState());
-        DCHECK(success) << "Must succeed as we won the race.";
-      }
-    } else {
-      DCHECK(to_ref->AsReference()->GetPendingNext() != nullptr)
-          << "Left unenqueued ref gray " << to_ref;
-    }
-    // DCHECK(to_ref->AsReference()->GetPendingNext() != nullptr)
-    //     << "Left unenqueued ref gray " << to_ref;
-  // jiacheng end ----------------------------
-
+    DCHECK(to_ref->AsReference()->GetPendingNext() != nullptr)
+        << "Left unenqueued ref gray " << to_ref;
   } else {
     // We may occasionally leave a reference non-gray in the queue if its referent happens to be
     // concurrently marked after the Scan() call above has enqueued the Reference, in which case the
@@ -2419,9 +2447,7 @@ void ConcurrentCopying::CheckEmptyMarkStack() {
   } else {
     // Shared, GC-exclusive, or off.
     MutexLock mu(thread_running_gc_, mark_stack_lock_);
-    // jiacheng start -------------------------------
-    // CHECK(gc_mark_stack_->IsEmpty());
-    // jiacheng end ---------------------------------
+    CHECK(gc_mark_stack_->IsEmpty());
     CHECK(revoked_mark_stacks_.empty());
   }
 }
@@ -2826,7 +2852,21 @@ void ConcurrentCopying::AssertToSpaceInvariant(mirror::Object* obj,
           Thread::Current()->DumpJavaStack(LOG_STREAM(FATAL_WITHOUT_ABORT));
         }
         CHECK(IsMarkedInUnevacFromSpace(ref)) << ref;
-     } else {
+     } 
+     // jiacheng start
+     else if (type == RegionType::kRegionTypeColdToSpace){
+       return;
+     } else if (type == RegionType::kRegionTypeColdSpace) {
+        if (!IsMarkedInColdSpace(ref)) {
+          LOG(FATAL_WITHOUT_ABORT) << "Found unmarked reference in cold-space:";
+          region_space_->Unprotect();
+          LOG(FATAL_WITHOUT_ABORT) << DumpHeapReference(obj, offset, ref);
+          Thread::Current()->DumpJavaStack(LOG_STREAM(FATAL_WITHOUT_ABORT));
+        }
+        CHECK(IsMarkedInColdSpace(ref)) << ref;
+     }
+     // jiacheng end     
+     else {
         // Not OK: either a from-space ref or a reference in an unused region.
         if (type == RegionType::kRegionTypeFromSpace) {
           LOG(FATAL_WITHOUT_ABORT) << "Found from-space reference:";
@@ -2868,13 +2908,7 @@ void ConcurrentCopying::AssertToSpaceInvariant(mirror::Object* obj,
         LOG(FATAL) << "Invalid reference " << ref
                    << " referenced from object " << obj << " at offset " << offset;
       }
-    } 
-    // jiacheng start -------------------------
-    else if (jiacheng::ColdSpace::Current()->HasAddress(ref)) {
-      // pass
-    }
-    // jiacheng end ---------------------------
-    else {
+    } else {
       // Check to-space invariant in non-moving space.
       AssertToSpaceInvariantInNonMovingSpace(obj, ref);
     }
@@ -2937,7 +2971,20 @@ void ConcurrentCopying::AssertToSpaceInvariant(GcRootSource* gc_root_source,
           LOG(FATAL_WITHOUT_ABORT) << DumpGcRoot(ref);
         }
         CHECK(IsMarkedInUnevacFromSpace(ref)) << ref;
-      } else {
+      } 
+      // jiacheng start
+     else if (type == RegionType::kRegionTypeColdToSpace){
+       return;
+     } else if (type == RegionType::kRegionTypeColdSpace) {
+        if (!IsMarkedInColdSpace(ref)) {
+          LOG(FATAL_WITHOUT_ABORT) << "Found unmarked reference in cold-space:";
+          region_space_->Unprotect();
+          LOG(FATAL_WITHOUT_ABORT) << DumpGcRoot(ref);
+        }
+        CHECK(IsMarkedInColdSpace(ref)) << ref;
+     }
+      // jiacheng end
+      else {
         // Not OK: either a from-space ref or a reference in an unused region.
         if (type == RegionType::kRegionTypeFromSpace) {
           LOG(FATAL_WITHOUT_ABORT) << "Found from-space reference:";
@@ -3130,11 +3177,15 @@ class ConcurrentCopying::RefFieldsVisitor {
 
 template <bool kNoUnEvac>
 inline void ConcurrentCopying::Scan(mirror::Object* to_ref) {
-  // jiacheng start  -------------------------------------
-  // LOG(INFO) << "jiacheng concurrent_copying.cc 2147 Scan() to_ref= " << to_ref 
-  //           << " ColdSpace::HasAddress()= " << jiacheng::ColdSpace::Current()->HasAddress(to_ref);
-
-  // jiacheng end ----------------------------------------
+  // jiacheng start 
+  // 除了Scan还有很多其他地方对to_ref进行访问，例如检查barrier state
+  // if(region_space_->IsInColdSpace(to_ref)) {
+  //   return;
+  // }
+  if (!region_space_->IsInColdSpace(to_ref)) {
+    jiacheng::GCAccessTrigger(to_ref);
+  }
+  // jiacheng end
   // Cannot have `kNoUnEvac` when Generational CC collection is disabled.
   DCHECK(!kNoUnEvac || use_generational_cc_);
   if (kDisallowReadBarrierDuringScan && !Runtime::Current()->IsActiveTransaction()) {
@@ -3405,24 +3456,22 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
   size_t bytes_allocated = 0U;
   size_t dummy;
   bool fall_back_to_non_moving = false;
-  // jiacheng start --------------------------------
+  // jiacheng start
   // mirror::Object* to_ref = region_space_->AllocNonvirtual</*kForEvac=*/ true>(
   //     region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
   mirror::Object* to_ref = nullptr;
-  if (region_space_alloc_size <= jiacheng::ColdSpace::kRegionSize &&
-      jiacheng::Profiler::Current()->ShouldSwapOut(from_ref)) {
-    to_ref = jiacheng::ColdSpace::Current()->Alloc(region_space_alloc_size);
-    region_space_bytes_allocated = region_space_alloc_size;
-    LOG(INFO) << "jiacheng concurrent_copying.cc 3415 ColdSpace::Current()->Alloc()" 
-              << " region_space_alloc_size= " << region_space_alloc_size 
-              << " to_ref= " << to_ref
-              << " GetAllocatedObjNum()= " << jiacheng::ColdSpace::Current()->GetAllocatedObjNum();
-  }
-  if (!to_ref) {
+  if (jiacheng::Profiler::Current()->ShouldSwapOut(from_ref)) {
+    to_ref = region_space_->AllocCold(region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
+    // LOG(INFO) << "jiacheng concurrent_copying.cc 3415 region_space_->AllocCold()" 
+    //           << " region_space_alloc_size= " << region_space_alloc_size 
+    //           << " to_ref= " << to_ref
+    //           ;
+  }
+  if (to_ref == nullptr) {
     to_ref = region_space_->AllocNonvirtual</*kForEvac*/ true>(
             region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
   }
-  // jiacheng end --------------------------------
+  // jiacheng end
 
   bytes_allocated = region_space_bytes_allocated;
   if (LIKELY(to_ref != nullptr)) {
@@ -3466,14 +3515,32 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
   to_ref->SetClass(klass);
   const size_t kObjectHeaderSize = sizeof(mirror::Object);
   DCHECK_GE(obj_size, kObjectHeaderSize);
+  // jiacheng start
+  // static_assert(kObjectHeaderSize == sizeof(mirror::HeapReference<mirror::Class>) +
+  //                   sizeof(LockWord),
+  //               "Object header size does not match");
   static_assert(kObjectHeaderSize == sizeof(mirror::HeapReference<mirror::Class>) +
-                    sizeof(LockWord),
+                    sizeof(LockWord) + sizeof(uint64_t),
                 "Object header size does not match");
+  // jiacheng end
   // Memcpy can tear for words since it may do byte copy. It is only safe to do this since the
   // object in the from space is immutable other than the lock word. b/31423258
   memcpy(reinterpret_cast<uint8_t*>(to_ref) + kObjectHeaderSize,
          reinterpret_cast<const uint8_t*>(from_ref) + kObjectHeaderSize,
          obj_size - kObjectHeaderSize);
+  // jiacheng start
+  // if (jiacheng::IsWhiteApp()) {
+  //   LOG(INFO) << "jiacheng ConcurrentCopying::Copy()"
+  //             << " from_ref= " << reinterpret_cast<size_t>(from_ref)
+  //             << " to_ref= " << reinterpret_cast<size_t>(to_ref);
+  // }
+  jiacheng::GCAccessTrigger(to_ref);
+  jiacheng::GCAccessTrigger(from_ref);
+  // jiacheng end
+
+  // jiacheng debug start
+  CHECK(region_space_->IsInFromSpace(from_ref)) << (region_space_->GetRegionType(from_ref)) << (region_space_->GetRegionType(to_ref));
+  // jiacheng debug end
 
   // Attempt to install the forward pointer. This is in a loop as the
   // lock word atomic write can fail.
@@ -3486,13 +3553,8 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
       // look like a valid but dead (dummy) object and keep it for
       // future reuse.
       FillWithDummyObject(self, to_ref, bytes_allocated);
-      // jiacheng start  -----------------------------------
-      if (jiacheng::ColdSpace::Current()->HasAddress(to_ref)) {
-        /* Don't do any thing */
-      }
-      else if (!fall_back_to_non_moving) {
-      // if (!fall_back_to_non_moving) {
-      // jiacheng end -----------------------------------
+
+      if (!fall_back_to_non_moving) {
         DCHECK(region_space_->IsInToSpace(to_ref));
         if (bytes_allocated > space::RegionSpace::kRegionSize) {
           // Free the large alloc.
@@ -3518,14 +3580,12 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
       to_ref = reinterpret_cast<mirror::Object*>(old_lock_word.ForwardingAddress());
       CHECK(to_ref != nullptr);
       CHECK_NE(to_ref, lost_fwd_ptr);
-
-      // jiacheng start ----------------------------------- 增加对ColdSpace的判断
+      // jiacheng start
       // CHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
       //     << "to_ref=" << to_ref << " " << heap_->DumpSpaces();
-      CHECK(region_space_->IsInToSpace(to_ref) || jiacheng::ColdSpace::Current()->HasAddress(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
+      CHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref) || region_space_->IsInColdToSpace(to_ref))
           << "to_ref=" << to_ref << " " << heap_->DumpSpaces();
-      // jiacheng end -----------------------------------
-      
+      // jiacheng end
       CHECK_NE(to_ref->GetLockWord(false).GetState(), LockWord::kForwardingAddress);
       return to_ref;
     }
@@ -3559,14 +3619,7 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
         bytes_moved_.fetch_add(bytes_allocated, std::memory_order_relaxed);
       }
 
-      // jiacheng start  --------------------------------
-      if (jiacheng::ColdSpace::Current()->HasAddress(to_ref)) {
-        // pass
-        // LOG(INFO) << "jiacheng concurrent_copying.cc 2516";
-      } else if (LIKELY(!fall_back_to_non_moving)) {
-      // if (LIKELY(!fall_back_to_non_moving)) {
-      // jiacheng end  --------------------------------
-
+      if (LIKELY(!fall_back_to_non_moving)) {
         DCHECK(region_space_->IsInToSpace(to_ref));
       } else {
         DCHECK(heap_->non_moving_space_->HasAddress(to_ref));
@@ -3605,15 +3658,9 @@ mirror::Object* ConcurrentCopying::IsMarked(mirror::Object* from_ref) {
   if (rtype == space::RegionSpace::RegionType::kRegionTypeFromSpace) {
     to_ref = GetFwdPtr(from_ref);
 
-    // jiacheng start ------------------------------------
-    // DCHECK(to_ref == nullptr || region_space_->IsInToSpace(to_ref) ||
-    //        heap_->non_moving_space_->HasAddress(to_ref))
-    //     << "from_ref=" << from_ref << " to_ref=" << to_ref;
     DCHECK(to_ref == nullptr || region_space_->IsInToSpace(to_ref) ||
-           heap_->non_moving_space_->HasAddress(to_ref) || 
-           jiacheng::ColdSpace::Current()->HasAddress(to_ref))
+           heap_->non_moving_space_->HasAddress(to_ref))
         << "from_ref=" << from_ref << " to_ref=" << to_ref;
-    // jiacheng end  -------------------------------------
     
   } else if (rtype == space::RegionSpace::RegionType::kRegionTypeUnevacFromSpace) {
     if (IsMarkedInUnevacFromSpace(from_ref)) {
@@ -3621,7 +3668,19 @@ mirror::Object* ConcurrentCopying::IsMarked(mirror::Object* from_ref) {
     } else {
       to_ref = nullptr;
     }
-  } else {
+  } 
+  // jiacheng start
+  else if (rtype == space::RegionSpace::RegionType::kRegionTypeColdToSpace){
+    return from_ref;
+  } else if (rtype == space::RegionSpace::RegionType::kRegionTypeColdSpace) {
+    if (IsMarkedInColdSpace(from_ref)) {
+      to_ref = from_ref;
+    } else {
+      to_ref = nullptr;
+    }
+  }
+  // jiacheng end
+  else {
     // At this point, `from_ref` should not be in the region space
     // (i.e. within an "unused" region).
     DCHECK(!region_space_->HasAddress(from_ref)) << from_ref;
@@ -3901,6 +3960,34 @@ void ConcurrentCopying::DumpPerformanceInfo(std::ostream& os) {
      << ")\n";
 }
 
+// jiacheng start
+mirror::Object* ConcurrentCopying::MarkColdSpaceRegion(Thread* const self, 
+                                                       mirror::Object* ref, 
+                                                       accounting::SpaceBitmap<kObjectAlignment>* bitmap) {
+  if (bitmap->Test(ref)) {
+    return ref;
+  }
+  bool success = ref->AtomicSetReadBarrierState(/* expected_rb_state= */ ReadBarrier::NonGrayState(),
+                                             /* rb_state= */ ReadBarrier::GrayState());
+  if (success) {
+    DCHECK_EQ(ref->GetReadBarrierState(), ReadBarrier::GrayState());
+    PushOntoMarkStack(self, ref);
+  }
+  return ref;
+}
+
+bool ConcurrentCopying::IsMarkedInColdSpace(mirror::Object* from_ref) {
+  DCHECK(region_space_->IsInColdSpace(from_ref));
+  if (from_ref->GetReadBarrierStateAcquire() == ReadBarrier::GrayState()) {
+    return true;
+  } else if (done_scanning_.load(std::memory_order_acquire)) {
+    return region_space_bitmap_->Test(from_ref);
+  }
+  return false;
+}
+
+// jiacheng end
+
 }  // namespace collector
 }  // namespace gc
 }  // namespace art
diff --git a/runtime/gc/collector/concurrent_copying.h b/runtime/gc/collector/concurrent_copying.h
index 2e5752b91e..8e369e960d 100644
--- a/runtime/gc/collector/concurrent_copying.h
+++ b/runtime/gc/collector/concurrent_copying.h
@@ -235,6 +235,10 @@ class ConcurrentCopying : public GarbageCollector {
       REQUIRES(!mark_stack_lock_, !skipped_blocks_lock_, !immune_gray_stack_lock_);
   bool IsMarkedInUnevacFromSpace(mirror::Object* from_ref)
       REQUIRES_SHARED(Locks::mutator_lock_);
+  // jiacheng start
+  bool IsMarkedInColdSpace(mirror::Object* from_ref)
+      REQUIRES_SHARED(Locks::mutator_lock_);
+  // jiacheng end
   bool IsMarkedInNonMovingSpace(mirror::Object* from_ref)
       REQUIRES_SHARED(Locks::mutator_lock_);
   bool IsNullOrMarkedHeapReference(mirror::HeapReference<mirror::Object>* field,
@@ -298,6 +302,13 @@ class ConcurrentCopying : public GarbageCollector {
       accounting::SpaceBitmap<kObjectAlignment>* bitmap)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!mark_stack_lock_, !skipped_blocks_lock_);
+// jiacheng start
+  mirror::Object* MarkColdSpaceRegion(Thread* const self,
+      mirror::Object* from_ref,
+      accounting::SpaceBitmap<kObjectAlignment>* bitmap)
+      REQUIRES_SHARED(Locks::mutator_lock_)
+      REQUIRES(!mark_stack_lock_, !skipped_blocks_lock_);
+// jiacheng end
   template<bool kGrayImmuneObject>
   ALWAYS_INLINE mirror::Object* MarkImmuneSpace(Thread* const self,
                                                 mirror::Object* from_ref)
@@ -483,6 +494,10 @@ class ConcurrentCopying : public GarbageCollector {
   class VerifyNoFromSpaceRefsVisitor;
   class VerifyNoMissingCardMarkVisitor;
   class ImmuneSpaceCaptureRefsVisitor;
+  // jiacheng start
+  class RegionRememberedObjectsVisitor;
+  class RegionRememberedObjectsAsRootVisitor;
+  // jiacheng end
   template <bool kAtomicTestAndSet = false> class CaptureRootsForMarkingVisitor;
   class CaptureThreadRootsForMarkingAndCheckpoint;
   template <bool kHandleInterRegionRefs> class ComputeLiveBytesAndMarkRefFieldsVisitor;
diff --git a/runtime/gc/heap.cc b/runtime/gc/heap.cc
index ee8e46beea..aee8c26560 100644
--- a/runtime/gc/heap.cc
+++ b/runtime/gc/heap.cc
@@ -93,6 +93,10 @@
 #include "verify_object-inl.h"
 #include "well_known_classes.h"
 
+// jiacheng start
+#include "jiacheng_hack.h"
+// jiacheng end
+
 namespace art {
 
 namespace gc {
@@ -725,53 +729,19 @@ void Heap::JiachengDebug() {
   // 用于显示Heap当前的信息
   Thread* self = Thread::Current();
   (void)self;
-
-  // 查看vector<> continuous_spaces_
-  {
-    ReaderMutexLock mu(self, *Locks::mutator_lock_);
-    for (size_t i = 0; i < continuous_spaces_.size(); ++i) {
-      space::ContinuousSpace* s = continuous_spaces_[i];
-      LOG(INFO) << "jiacheng heap.cc 732"
-                << " continuous_spaces_[" << i << "]" 
-                << " GetType= " << s->GetType()
-                << " ADDR= " << size_t(s)
-                ;
-    }
-
-    // 查看vector<> discontinuous_spaces_
-    for (size_t i = 0; i < discontinuous_spaces_.size(); ++i) {
-      space::DiscontinuousSpace* s = discontinuous_spaces_[i];
-      LOG(INFO) << "jiacheng heap.cc 732"
-                << " discontinuous_spaces_[" << i << "]" 
-                << " GetType= " << s->GetType()
-                << " ADDR= " << size_t(s)
-                ;
-    }
-  }
-
-  // 查看vector<> alloc_spaces_
-  for (size_t i = 0; i < alloc_spaces_.size(); ++i) {
-    space::AllocSpace* s = alloc_spaces_[i];
+  
+  MutexLock mu(self, *gc_complete_lock_);
+  LOG(INFO) << "jiacheng heap.cc 732"
+            << " last_gc_type_= " << last_gc_type_
+            << " next_gc_type_= " << next_gc_type_
+            << " current_allocator_= " << current_allocator_
+            << " current_non_moving_allocator_= " << current_non_moving_allocator_
+            ;
+  for (size_t i = 0; i < gc_plan_.size(); ++i) {
     LOG(INFO) << "jiacheng heap.cc 732"
-              << " alloc_spaces_[" << i << "]" 
-              << " ADDR= " << size_t(s)
+              << " gc_plan_[" << i << "]= " << gc_plan_[i]
               ;
   }
-
-  // 查看Heap中的Space变量
-  LOG(INFO) << "jiacheng heap.cc 732"
-            << " non_moving_space_.ADDR= " << size_t(non_moving_space_)
-            << " rosalloc_space_.ADDR= " << size_t(rosalloc_space_)
-            << " dlmalloc_space_.ADDR= " << size_t(dlmalloc_space_)
-            << " main_space_.ADDR= " << size_t(main_space_)
-            << " large_object_space_.ADDR= " << size_t(large_object_space_)
-            ;
-
-  // 其他信息
-  LOG(INFO) << "jiacheng heap.cc 732"
-            << "kDefaultLargeObjectSpaceType= " << (kDefaultLargeObjectSpaceType == space::LargeObjectSpaceType::kFreeList) ? "kFreeList" : "kMap"
-            ;
-
 }
 // jiacheng end
 
@@ -1027,6 +997,10 @@ void Heap::ThreadFlipEnd(Thread* self) {
 }
 
 void Heap::UpdateProcessState(ProcessState old_process_state, ProcessState new_process_state) {
+  // jiacheng start
+  jiacheng::UpdataAppState(old_process_state, new_process_state);
+  // jiacheng end
+  
   if (old_process_state != new_process_state) {
     const bool jank_perceptible = new_process_state == kProcessStateJankPerceptible;
     for (size_t i = 1; i <= kCollectorTransitionStressIterations; ++i) {
@@ -2884,6 +2858,9 @@ void Heap::LogGC(GcCause gc_cause, collector::GarbageCollector* collector) {
       log_gc = log_gc || pause >= long_pause_log_threshold_;
     }
   }
+  // jiacheng start
+  log_gc = true;
+  // jiacheng end
   if (log_gc) {
     const size_t percent_free = GetPercentFree();
     const size_t current_heap_size = GetBytesAllocated();
diff --git a/runtime/gc/heap.h b/runtime/gc/heap.h
index 4f266fcd5e..d7a3400637 100644
--- a/runtime/gc/heap.h
+++ b/runtime/gc/heap.h
@@ -570,6 +570,12 @@ class Heap {
     return region_space_;
   }
 
+  // jiacheng start
+  space::ZygoteSpace* GetZygoteSpace() const {
+    return zygote_space_;
+  }
+  // jiacheng end
+
   // Implements java.lang.Runtime.maxMemory, returning the maximum amount of memory a program can
   // consume. For a regular VM this would relate to the -Xmx option and would return -1 if no Xmx
   // were specified. Android apps start with a growth limit (small heap size) which is
diff --git a/runtime/gc/space/image_space.cc b/runtime/gc/space/image_space.cc
index 3e3d199d7b..659b0c8103 100644
--- a/runtime/gc/space/image_space.cc
+++ b/runtime/gc/space/image_space.cc
@@ -1419,7 +1419,6 @@ class ImageSpace::BootImageLoader {
                       /*out*/std::string* error_msg) REQUIRES_SHARED(Locks::mutator_lock_) {
     TimingLogger logger(__PRETTY_FUNCTION__, /*precise=*/ true, VLOG_IS_ON(image));
     std::string filename = GetSystemImageFilename(image_location_.c_str(), image_isa_);
-
     if (!LoadFromFile(filename,
                       validate_oat_file,
                       extra_reservation_size,
@@ -1429,7 +1428,6 @@ class ImageSpace::BootImageLoader {
                       error_msg)) {
       return false;
     }
-
     if (VLOG_IS_ON(image)) {
       LOG(INFO) << "ImageSpace::BootImageLoader::LoadFromSystem exiting "
           << boot_image_spaces->front();
@@ -1498,7 +1496,6 @@ class ImageSpace::BootImageLoader {
                                 error_msg)) {
       return false;
     }
-
     ArrayRef<const std::string> provided_locations(boot_class_path_locations_.data(),
                                                    system_hdr.GetComponentCount());
     std::vector<std::string> locations =
@@ -1537,7 +1534,6 @@ class ImageSpace::BootImageLoader {
     if (!CheckReservationExhausted(image_reservation, error_msg)) {
       return false;
     }
-
     MaybeRelocateSpaces(spaces, logger);
     boot_image_spaces->swap(spaces);
     *extra_reservation = std::move(local_extra_reservation);
@@ -1576,13 +1572,13 @@ class ImageSpace::BootImageLoader {
     PatchRelocateVisitor patch_object_visitor(relocate_visitor, relocate_visitor);
 
     mirror::Class* dcheck_class_class = nullptr;  // Used only for a DCHECK().
+
     for (const std::unique_ptr<ImageSpace>& space : spaces) {
       // First patch the image header. The `diff` is OK for patching 32-bit fields but
       // the 64-bit method fields in the ImageHeader may need a negative `delta`.
       reinterpret_cast<ImageHeader*>(space->Begin())->RelocateImage(
           (reinterpret_cast32<uint32_t>(space->Begin()) >= -diff)  // Would `begin+diff` overflow?
               ? -static_cast<int64_t>(-diff) : static_cast<int64_t>(diff));
-
       // Patch fields and methods.
       const ImageHeader& image_header = space->GetImageHeader();
       image_header.VisitPackedArtFields([&](ArtField& field) REQUIRES_SHARED(Locks::mutator_lock_) {
@@ -1614,7 +1610,6 @@ class ImageSpace::BootImageLoader {
           patch_object_visitor.template PatchGcRoot</*kMayBeNull=*/ false>(&slot);
         }
       }
-
       // Patch the class table and classes, so that we can traverse class hierarchy to
       // determine the types of other objects when we visit them later.
       if (image_header.GetClassTableSection().Size() != 0u) {
@@ -1661,7 +1656,6 @@ class ImageSpace::BootImageLoader {
         }
       }
     }
-
     // Patch class roots now, so that we can recognize mirror::Method and mirror::Constructor.
     ObjPtr<mirror::Class> method_class;
     ObjPtr<mirror::Class> constructor_class;
@@ -1683,7 +1677,6 @@ class ImageSpace::BootImageLoader {
       method_class = GetClassRoot<mirror::Method, kWithoutReadBarrier>(class_roots);
       constructor_class = GetClassRoot<mirror::Constructor, kWithoutReadBarrier>(class_roots);
     }
-
     for (size_t s = 0u, size = spaces.size(); s != size; ++s) {
       const ImageSpace* space = spaces[s].get();
       const ImageHeader& image_header = space->GetImageHeader();
@@ -1730,7 +1723,6 @@ class ImageSpace::BootImageLoader {
       DCHECK_EQ(diff, 0u);
       return;
     }
-
     PointerSize pointer_size = first_space_header.GetPointerSize();
     if (pointer_size == PointerSize::k64) {
       DoRelocateSpaces<PointerSize::k64>(spaces, diff);
diff --git a/runtime/gc/space/region_space-inl.h b/runtime/gc/space/region_space-inl.h
index 86a0a6e418..215458b1a0 100644
--- a/runtime/gc/space/region_space-inl.h
+++ b/runtime/gc/space/region_space-inl.h
@@ -151,6 +151,18 @@ inline uint64_t RegionSpace::GetBytesAllocatedInternal() {
           bytes += r->BytesAllocated();
         }
         break;
+      // jiacheng start
+      case RegionType::kRegionTypeColdToSpace:
+        if (r->IsInColdToSpace()) {
+          bytes += r->BytesAllocated();
+        }
+        break;
+      case RegionType::kRegionTypeColdSpace:
+        if (r->IsInToSpace()) {
+          bytes += r->BytesAllocated();
+        }
+        break;
+      // jiacheng end
       default:
         LOG(FATAL) << "Unexpected space type : " << kRegionType;
     }
@@ -186,6 +198,18 @@ inline uint64_t RegionSpace::GetObjectsAllocatedInternal() {
           bytes += r->ObjectsAllocated();
         }
         break;
+      // jiacheng start
+      case RegionType::kRegionTypeColdToSpace:
+        if (r->IsInColdToSpace()) {
+          bytes += r->ObjectsAllocated();
+        }
+        break;
+      case RegionType::kRegionTypeColdSpace:
+        if (r->IsInToSpace()) {
+          bytes += r->ObjectsAllocated();
+        }
+        break;
+      // jiacheng end
       default:
         LOG(FATAL) << "Unexpected space type : " << kRegionType;
     }
diff --git a/runtime/gc/space/region_space.cc b/runtime/gc/space/region_space.cc
index 36a9d0a672..181da36282 100644
--- a/runtime/gc/space/region_space.cc
+++ b/runtime/gc/space/region_space.cc
@@ -24,6 +24,12 @@
 #include "mirror/object-inl.h"
 #include "thread_list.h"
 
+// jiacheng start
+#include "mirror/object-refvisitor-inl.h"
+#include "jiacheng_utils.h"
+#include <sstream>
+// jiacheng end
+
 namespace art {
 namespace gc {
 namespace space {
@@ -47,12 +53,6 @@ static constexpr uint32_t kPoisonDeadObject = 0xBADDB01D;  // "BADDROID"
 // Whether we check a region's live bytes count against the region bitmap.
 static constexpr bool kCheckLiveBytesAgainstRegionBitmap = kIsDebugBuild;
 
-// jiacheng start
-void RegionSpace::JiachengDebug() const {
-  
-}
-// jiacheng end
-
 MemMap RegionSpace::CreateMemMap(const std::string& name,
                                  size_t capacity,
                                  uint8_t* requested_begin) {
@@ -122,7 +122,11 @@ RegionSpace::RegionSpace(const std::string& name, MemMap&& mem_map, bool use_gen
       non_free_region_index_limit_(0U),
       current_region_(&full_region_),
       evac_region_(nullptr),
-      cyclic_alloc_region_index_(0U) {
+      // jiacheng start
+      // cyclic_alloc_region_index_(0U) {
+      cyclic_alloc_region_index_(0U),
+      current_cold_region_(nullptr) {
+      // jiacheng end
   CHECK_ALIGNED(mem_map_.Size(), kRegionSize);
   CHECK_ALIGNED(mem_map_.Begin(), kRegionSize);
   DCHECK_GT(num_regions_, 0U);
@@ -335,6 +339,14 @@ void RegionSpace::ZeroLiveBytesForLargeObject(mirror::Object* obj) {
 void RegionSpace::SetFromSpace(accounting::ReadBarrierTable* rb_table,
                                EvacMode evac_mode,
                                bool clear_live_bytes) {
+  // jiacheng start
+  if (jiacheng::IsWhiteApp()) {
+    LOG(INFO) << "jiacheng region_space.cc 343 RegionSpace::SetFromSpace()"
+              << " evac_mode= " << evac_mode
+              << " clear_live_bytes= " << clear_live_bytes;
+  }
+  // jiacheng end
+  
   // Live bytes are only preserved (i.e. not cleared) during sticky-bit CC collections.
   DCHECK(use_generational_cc_ || clear_live_bytes);
   ++time_;
@@ -357,15 +369,39 @@ void RegionSpace::SetFromSpace(accounting::ReadBarrierTable* rb_table,
     RegionState state = r->State();
     RegionType type = r->Type();
     if (!r->IsFree()) {
-      DCHECK(r->IsInToSpace());
+      // jiacheng start
+      // DCHECK(r->IsInToSpace());
+      CHECK(r->IsInToSpace() || r->IsInColdToSpace());
+      // jiacheng end
       if (LIKELY(num_expected_large_tails == 0U)) {
-        DCHECK((state == RegionState::kRegionStateAllocated ||
+        // jiacheng start
+        // DCHECK((state == RegionState::kRegionStateAllocated ||
+        //         state == RegionState::kRegionStateLarge) &&
+        //        type == RegionType::kRegionTypeToSpace);
+        CHECK((state == RegionState::kRegionStateAllocated ||
                 state == RegionState::kRegionStateLarge) &&
-               type == RegionType::kRegionTypeToSpace);
+               type == RegionType::kRegionTypeToSpace || type == RegionType::kRegionTypeColdToSpace);
+        // jiacheng end
         bool should_evacuate = r->ShouldBeEvacuated(evac_mode);
         bool is_newly_allocated = r->IsNewlyAllocated();
-        if (should_evacuate) {
+        // jiacheng start
+        bool should_cold = (type == RegionType::kRegionTypeColdToSpace);
+        // if (should_evacuate) {
+        if (should_cold) {
+          r->SetAsColdSpace();
+        } else if (should_evacuate) {
+        // jiacheng end
           r->SetAsFromSpace();
+
+          // jiacheng start
+          if (jiacheng::IsWhiteApp()) {
+            LOG(INFO) << "jiacheng region_space.cc 393 RegionSpace::SetFromSpace() SetAsFromSpace()"
+                      << " r->IsNewlyAllocated()= " << r->IsNewlyAllocated()
+                      << " evac_mode= " << evac_mode
+                      << " region_index= " << r->Idx();
+          }
+          // jiacheng end
+
           DCHECK(r->IsInFromSpace());
         } else {
           r->SetAsUnevacFromSpace(clear_live_bytes);
@@ -411,6 +447,9 @@ void RegionSpace::SetFromSpace(accounting::ReadBarrierTable* rb_table,
   DCHECK_EQ(num_expected_large_tails, 0U);
   current_region_ = &full_region_;
   evac_region_ = &full_region_;
+  // jiacheng start
+  current_cold_region_ = &full_region_;
+  // jiacheng end
 }
 
 static void ZeroAndProtectRegion(uint8_t* begin, uint8_t* end) {
@@ -557,11 +596,19 @@ void RegionSpace::ClearFromSpace(/* out */ uint64_t* cleared_bytes,
         size_t regions_to_clear_bitmap = 1;
         while (i + regions_to_clear_bitmap < num_regions_) {
           Region* const cur = &regions_[i + regions_to_clear_bitmap];
-          if (!cur->AllAllocatedBytesAreLive()) {
-            DCHECK(!cur->IsLargeTail());
+          // jiacheng start
+          // if (!cur->AllAllocatedBytesAreLive()) {
+          //   DCHECK(!cur->IsLargeTail());
+          //   break;
+          // }
+          // CHECK(cur->IsInUnevacFromSpace());
+
+          if (!cur->AllAllocatedBytesAreLive() || cur->IsInColdSpace() || cur->IsInColdToSpace()) {
+            DCHECK(!cur->IsLargeTail()) << (cur->Type());
             break;
           }
-          CHECK(cur->IsInUnevacFromSpace());
+          CHECK(cur->IsInUnevacFromSpace()) << (cur->Type());
+          // jiacheng end
           cur->SetUnevacFromSpaceAsToSpace();
           ++regions_to_clear_bitmap;
         }
@@ -618,6 +665,33 @@ void RegionSpace::ClearFromSpace(/* out */ uint64_t* cleared_bytes,
         }
       }
     }
+    // jiacheng start
+    else if (r->IsInColdSpace()) {
+      // if (r->LiveBytes() == 0) {
+      //   DCHECK(!r->IsLargeTail());
+      //   *cleared_bytes += r->BytesAllocated();
+      //   *cleared_objects += r->ObjectsAllocated();
+      //   r->Clear(/*zero_and_release_pages=*/false);
+      //   size_t free_regions = 1;
+      //   // Also release RAM for large tails.
+      //   while (i + free_regions < num_regions_ && regions_[i + free_regions].IsLargeTail()) {
+      //     regions_[i + free_regions].Clear(/*zero_and_release_pages=*/false);
+      //     ++free_regions;
+      //   }
+      //   num_non_free_regions_ -= free_regions;
+      //   // When clear_bitmap is true, this clearing of bitmap is taken care in
+      //   // clear_region().
+      //   if (!clear_bitmap) {
+      //     GetLiveBitmap()->ClearRange(
+      //         reinterpret_cast<mirror::Object*>(r->Begin()),
+      //         reinterpret_cast<mirror::Object*>(r->Begin() + free_regions * kRegionSize));
+      //   }
+      //   continue;
+      // }
+      r->SetColdSpaceAsColdToSpace();
+      // r->SetColdSpaceAsToSpace();
+    }
+    // jiacheng end
     // Note r != last_checked_region if r->IsInUnevacFromSpace() was true above.
     Region* last_checked_region = &regions_[i];
     if (!last_checked_region->IsFree()) {
@@ -630,6 +704,9 @@ void RegionSpace::ClearFromSpace(/* out */ uint64_t* cleared_bytes,
   evac_region_ = nullptr;
   num_non_free_regions_ += num_evac_regions_;
   num_evac_regions_ = 0;
+  // jiacheng start
+  current_cold_region_ = nullptr;
+  // jiacheng end
 }
 
 void RegionSpace::CheckLiveBytesAgainstRegionBitmap(Region* r) {
@@ -771,6 +848,9 @@ void RegionSpace::Clear() {
   DCHECK_EQ(num_non_free_regions_, 0u);
   current_region_ = &full_region_;
   evac_region_ = &full_region_;
+  // jiacheng start
+  current_cold_region_ = &full_region_;
+  // jiacheng end
 }
 
 void RegionSpace::Protect() {
@@ -969,6 +1049,15 @@ size_t RegionSpace::AllocationSizeNonvirtual(mirror::Object* obj, size_t* usable
 }
 
 void RegionSpace::Region::Clear(bool zero_and_release_pages) {
+  // jiacheng start
+  if (jiacheng::IsWhiteApp()) {
+    LOG(INFO) << "jiacheng region_space.cc 1047 Region::Clear()"
+              << " zero_and_release_pages= " << zero_and_release_pages
+              << " region_index= " << idx_
+              << " region_type= " << type_;
+  }
+  // jiacheng end
+
   top_.store(begin_, std::memory_order_relaxed);
   state_ = RegionState::kRegionStateFree;
   type_ = RegionType::kRegionTypeNone;
@@ -981,6 +1070,10 @@ void RegionSpace::Region::Clear(bool zero_and_release_pages) {
   is_newly_allocated_ = false;
   is_a_tlab_ = false;
   thread_ = nullptr;
+
+  // jiacheng start
+  remembered_set_.clear();
+  // jiacheng end
 }
 
 RegionSpace::Region* RegionSpace::AllocateRegion(bool for_evac) {
@@ -1014,6 +1107,13 @@ RegionSpace::Region* RegionSpace::AllocateRegion(bool for_evac) {
         // following the one that was just allocated.
         cyclic_alloc_region_index_ = (region_index + 1) % num_regions_;
       }
+      // jiacheng start
+      if (jiacheng::IsWhiteApp()) {
+        LOG(INFO) << "jiacheng region_space.cc 1083 RegionSpace::AllocateRegion() "
+                  << " for_evac= " << for_evac
+                  << " region_index= " << region_index;
+      }
+      // jiacheng end
       return r;
     }
   }
@@ -1045,6 +1145,320 @@ void RegionSpace::Region::UnfreeLargeTail(RegionSpace* region_space, uint32_t al
   state_ = RegionState::kRegionStateLargeTail;
 }
 
+// jiacheng start
+
+class ColdRefVisitor {
+ public:
+  explicit ColdRefVisitor(RegionSpace::Region* region): region_(region) {}
+
+  void operator()(mirror::Object* obj, MemberOffset offset, bool is_static ATTRIBUTE_UNUSED) const 
+    REQUIRES_SHARED(Locks::mutator_lock_)
+    REQUIRES_SHARED(Locks::heap_bitmap_lock_) ALWAYS_INLINE{
+    mirror::Object* ref = obj->GetFieldObject<mirror::Object, kVerifyNone, kWithoutReadBarrier, false>(offset);
+    if (!region_->Contains(ref)) {
+      region_->AddRememberedSet(reinterpret_cast<uint8_t*>(ref));
+    }
+  }
+
+  void operator()(ObjPtr<mirror::Class> klass, ObjPtr<mirror::Reference> obj) const
+      REQUIRES_SHARED(Locks::mutator_lock_) ALWAYS_INLINE {
+    CHECK(klass->IsTypeOfReferenceClass());
+    mirror::Object* ref = obj->GetReferent();
+    if (!region_->Contains(ref)) {
+      region_->AddRememberedSet(reinterpret_cast<uint8_t*>(ref));
+    }
+  }
+
+  void VisitRootIfNonNull(mirror::CompressedReference<mirror::Object>* root) const
+      ALWAYS_INLINE
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    if (!root->IsNull()) {
+      VisitRoot(root);
+    }
+  }
+
+  void VisitRoot(mirror::CompressedReference<mirror::Object>* root) const
+      ALWAYS_INLINE
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    mirror::Object* ref = root->AsMirrorPtr();
+    if (!region_->Contains(ref)) {
+      region_->AddRememberedSet(reinterpret_cast<uint8_t*>(ref));
+    }
+  }
+
+ private:
+  RegionSpace::Region* region_;
+};
+
+class ColdWriteBackRefVisitor {
+ public:
+  explicit ColdWriteBackRefVisitor(RegionSpace::Region* region): region_(region) {}
+
+  void operator()(mirror::Object* obj, MemberOffset offset, bool is_static ATTRIBUTE_UNUSED) const 
+    REQUIRES_SHARED(Locks::mutator_lock_)
+    REQUIRES_SHARED(Locks::heap_bitmap_lock_) ALWAYS_INLINE {
+    mirror::Object* ref = obj->GetFieldObject<mirror::Object, kVerifyNone, kWithoutReadBarrier, false>(offset);
+    mirror::Object* value = reinterpret_cast<mirror::Object*>(region_->GetRememberedSetValue(reinterpret_cast<uint8_t*>(ref)));
+    if (ref != value) {
+      obj->SetFieldObject<false>(offset, value);
+    }
+  }
+
+  void operator()(ObjPtr<mirror::Class> klass, ObjPtr<mirror::Reference> obj) const
+      REQUIRES_SHARED(Locks::mutator_lock_) ALWAYS_INLINE {
+    CHECK(klass->IsTypeOfReferenceClass());
+    mirror::Object* ref = obj->GetReferent();
+    mirror::Object* value = reinterpret_cast<mirror::Object*>(region_->GetRememberedSetValue(reinterpret_cast<uint8_t*>(ref)));
+    if (ref != value) {
+      LOG(INFO) << "jiacheng region_space.cc 1172 ref != value";
+      // obj->SetFieldObject<false>(offset, value);
+    }
+  }
+
+  void VisitRootIfNonNull(mirror::CompressedReference<mirror::Object>* root) const
+      ALWAYS_INLINE
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    if (!root->IsNull()) {
+      VisitRoot(root);
+    }
+  }
+
+  void VisitRoot(mirror::CompressedReference<mirror::Object>* root) const
+      ALWAYS_INLINE
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    mirror::Object* ref = root->AsMirrorPtr();
+    mirror::Object* value = reinterpret_cast<mirror::Object*>(region_->GetRememberedSetValue(reinterpret_cast<uint8_t*>(ref)));
+    if (ref != value) {
+      LOG(INFO) << "jiacheng region_space.cc 1191 ref != value";
+      // obj->SetFieldObject<false>(offset, value);
+    }
+  }
+
+ private:
+  RegionSpace::Region* region_;
+};
+
+void RegionSpace::Region::InitRememberedSet() {
+  remembered_set_.clear();
+  if (IsFree()) {
+    return;
+  }
+  CHECK(!IsLarge() && !IsLargeTail());
+  ColdRefVisitor ref_visitor(this);
+  auto obj_visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_) {
+    obj->VisitReferences<true, kVerifyNone, kWithoutReadBarrier>(ref_visitor, ref_visitor);
+  };
+  space::RegionSpace* region_space = art::Runtime::Current()->GetHeap()->GetRegionSpace();
+  region_space->WalkNonLargeRegion(obj_visitor, this);
+
+}
+
+
+void RegionSpace::Region::WriteBackRememberedSet() {
+  remembered_set_.clear();
+  if (IsFree()) {
+    return;
+  }
+  CHECK(!IsLarge() && !IsLargeTail());
+  ColdWriteBackRefVisitor ref_visitor(this);
+  auto obj_visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_) {
+    obj->VisitReferences<true, kVerifyNone, kWithoutReadBarrier>(ref_visitor, ref_visitor);
+  };
+  space::RegionSpace* region_space = art::Runtime::Current()->GetHeap()->GetRegionSpace();
+  region_space->WalkNonLargeRegion(obj_visitor, this);
+}
+
+
+void RegionSpace::Region::AddRememberedSet(uint8_t* ref) {
+  remembered_set_[ref] = ref;
+}
+
+uint8_t* RegionSpace::Region::GetRememberedSetValue(uint8_t* ref) {
+  auto it = remembered_set_.find(ref);
+  if (it == remembered_set_.end()) {
+    return nullptr;
+  }
+  return it->second;
+}
+
+std::map<uint8_t*, uint8_t*>* RegionSpace::Region::GetRememberedSet() {
+  return &remembered_set_;
+}
+
+
+void RegionSpace::Region::UnfreeCold(RegionSpace* region_space, uint32_t alloc_time) {
+  DCHECK(IsFree());
+  alloc_time_ = alloc_time;
+  region_space->AdjustNonFreeRegionLimit(idx_);
+  type_ = RegionType::kRegionTypeColdToSpace;
+  if (kProtectClearedRegions) {
+    CheckedCall(mprotect, __FUNCTION__, Begin(), kRegionSize, PROT_READ | PROT_WRITE);
+  }
+  state_ = RegionState::kRegionStateAllocated;
+}
+
+void RegionSpace::JiachengDebug() {
+  MutexLock mu(Thread::Current(), region_lock_);
+  for (size_t i = 0; i < std::min(num_regions_, non_free_region_index_limit_); ++i) {
+    Region* r = &regions_[i];
+    std::map<uint8_t*, uint8_t*>* remembered_set = r->GetRememberedSet();
+
+    std::stringstream ss;
+    ss << "jiacheng region_space.cc 60 JiachengDebug() ";
+    ss <<  " remembered_set.size()= " << remembered_set->size() << ' ';
+    // for (auto it : *remembered_set) {
+    //   ss << " key= " << it.first << " value= " << it.second;
+    // }
+    r->Dump(ss);
+    LOG(INFO) << ss.str();
+  }
+}
+
+uint32_t RegionSpace::SwapOutCold() {
+  LOG(INFO) << "jiacheng region_space.cc 1283 RegionSpace::SwapOutCold()";
+  uint64_t num_regions = 0;
+  uint8_t* begin, * end;
+  size_t swap_out_length;
+  MutexLock mu(Thread::Current(), region_lock_);
+  for (size_t i = 0; i < std::min(num_regions_, non_free_region_index_limit_); ++i) {
+    Region* r = &regions_[i];
+    if (r->IsInColdToSpace()) {
+      begin = r->Begin();
+      end = r->Top();
+      // end = r->End();
+      swap_out_length = std::distance(begin, end);
+      jiacheng::SwapOutRange(begin, swap_out_length);
+      // 防止重新换入
+      CheckedCall(mprotect, __FUNCTION__, begin, swap_out_length, PROT_NONE);
+      ++num_regions;
+    }
+  }
+  return num_regions * kRegionSize;
+}
+
+void RegionSpace::HandleFault(mirror::Object* ref) {
+  Region* r = RefToRegionUnlocked(ref);
+  uint8_t* begin = r->Begin();
+  // uint8_t* end = r->Top();
+  uint8_t* end = r->End();
+  size_t length = std::distance(begin, end);
+  // CheckedCall(mprotect, __FUNCTION__, begin, length, PROT_READ | PROT_WRITE);
+  if (mprotect(begin, length, PROT_READ | PROT_WRITE) == 0) {
+    LOG(INFO) << "jiacheng region_space.cc 1324 HandleFault() set PROT_READ | PROT_WRITE"
+              << " ref= " << ref
+              << " begin= " << reinterpret_cast<mirror::Object*>(begin)
+              << " end= " << reinterpret_cast<mirror::Object*>(end)
+              << " length= " << length
+              << " Success!"
+              ;
+
+  } else {
+    LOG(INFO) << "jiacheng region_space.cc 1324 HandleFault() set PROT_READ | PROT_WRITE"
+              << " ref= " << ref
+              << " begin= " << reinterpret_cast<mirror::Object*>(begin)
+              << " end= " << reinterpret_cast<mirror::Object*>(end)
+              << " length= " << length
+              << " errno= " << errno
+              << " fail!"
+              ;
+  }
+
+
+}
+
+
+RegionSpace::Region* RegionSpace::AllocateColdRegion() {
+  for (size_t i = 0; i < num_regions_; ++i) {
+    // When using the cyclic region allocation strategy, try to
+    // allocate a region starting from the last cyclic allocated
+    // region marker. Otherwise, try to allocate a region starting
+    // from the beginning of the region space.
+    size_t region_index = kCyclicRegionAllocation
+        ? ((cyclic_alloc_region_index_ + i) % num_regions_)
+        : i;
+    Region* r = &regions_[region_index];
+    if (r->IsFree()) {
+      r->UnfreeCold(this, time_);
+      ++num_non_free_regions_;
+      if (kCyclicRegionAllocation) {
+        // Move the cyclic allocation region marker to the region
+        // following the one that was just allocated.
+        cyclic_alloc_region_index_ = (region_index + 1) % num_regions_;
+      }
+      LOG(INFO) << "jiacheng region_space.cc 1322 RegionSpace::AllocateColdRegion() region_index= " << region_index;
+      return r;
+    }
+  }
+  return nullptr;
+}
+
+
+mirror::Object* RegionSpace::AllocCold(size_t num_bytes,
+                          /* out */ size_t* bytes_allocated,
+                          /* out */ size_t* usable_size,
+                          /* out */ size_t* bytes_tl_bulk_allocated) {
+  DCHECK_ALIGNED(num_bytes, kAlignment);
+  mirror::Object* obj = nullptr;
+  if (LIKELY(num_bytes <= kRegionSize)) {
+    obj = current_cold_region_->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
+    if (LIKELY(obj != nullptr)) {
+      return obj;
+    }
+    MutexLock mu(Thread::Current(), region_lock_);
+    obj = current_cold_region_->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
+    if (LIKELY(obj != nullptr)) {
+      return obj;
+    }
+    Region* r = AllocateColdRegion();
+    if (LIKELY(r != nullptr)) {
+      obj = r->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
+      CHECK(obj != nullptr);
+      current_cold_region_ = r;
+      return obj;
+    }
+  } else {
+    obj = AllocLargeCold(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
+  }
+  return obj;
+}
+
+mirror::Object* RegionSpace::AllocLargeCold(size_t num_bytes,
+                                /* out */ size_t* bytes_allocated,
+                                /* out */ size_t* usable_size,
+                                /* out */ size_t* bytes_tl_bulk_allocated) {
+  (void)num_bytes;
+  (void)bytes_allocated;
+  (void)usable_size;
+  (void)bytes_tl_bulk_allocated;
+  return nullptr;
+}
+
+void RegionSpace::InitColdToRegionRememberedSet() {
+  MutexLock mu(Thread::Current(), region_lock_);
+  for (size_t i = 0; i < std::min(num_regions_, non_free_region_index_limit_); ++i) {
+    Region* r = &regions_[i];
+    if (!r->IsInColdToSpace()) {
+      continue;
+    }
+    r->InitRememberedSet();
+  }
+}
+
+void RegionSpace::WriteBackRegionRememberedSet() {
+  MutexLock mu(Thread::Current(), region_lock_);
+  // FIFO because of kCyclicRegionAllocation
+  for (size_t i = 0; i < std::min(num_regions_, non_free_region_index_limit_); ++i) {
+    Region* r = &regions_[i];
+    if (!r->IsInColdToSpace()) {
+      continue;
+    }
+    r->WriteBackRememberedSet();
+    break;
+  }
+}
+
+// jiacheng end
+
 }  // namespace space
 }  // namespace gc
 }  // namespace art
diff --git a/runtime/gc/space/region_space.h b/runtime/gc/space/region_space.h
index 90cde6dd71..13ed05d927 100644
--- a/runtime/gc/space/region_space.h
+++ b/runtime/gc/space/region_space.h
@@ -153,6 +153,10 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
     kRegionTypeFromSpace,        // From-space. To be evacuated.
     kRegionTypeUnevacFromSpace,  // Unevacuated from-space. Not to be evacuated.
     kRegionTypeToSpace,          // To-space.
+    // jiacheng start
+    kRegionTypeColdSpace,
+    kRegionTypeColdToSpace,
+    // jiacheng end
     kRegionTypeNone,             // None.
   };
 
@@ -369,13 +373,12 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
     return time_;
   }
 
-  // jiacheng start
-  void JiachengDebug() const;
-  // jiacheng end
-
  private:
   RegionSpace(const std::string& name, MemMap&& mem_map, bool use_generational_cc);
 
+// jiacheng start
+  public:
+// jiacheng end
   class Region {
    public:
     Region()
@@ -390,7 +393,11 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
           is_newly_allocated_(false),
           is_a_tlab_(false),
           state_(RegionState::kRegionStateAllocated),
-          type_(RegionType::kRegionTypeToSpace) {}
+          // jiacheng start
+          // type_(RegionType::kRegionTypeToSpace) {}
+          type_(RegionType::kRegionTypeToSpace),
+          remembered_set_() {}
+          // jiacheng end
 
     void Init(size_t idx, uint8_t* begin, uint8_t* end) {
       idx_ = idx;
@@ -407,6 +414,9 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
       thread_ = nullptr;
       DCHECK_LT(begin, end);
       DCHECK_EQ(static_cast<size_t>(end - begin), kRegionSize);
+      // jiacheng start
+      remembered_set_.clear();
+      // jiacheng end
     }
 
     RegionState State() const {
@@ -423,6 +433,24 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
                                         /* out */ size_t* bytes_allocated,
                                         /* out */ size_t* usable_size,
                                         /* out */ size_t* bytes_tl_bulk_allocated);
+    // jiacheng start
+    void InitRememberedSet();
+
+    void WriteBackRememberedSet();
+
+    void AddRememberedSet(uint8_t* ref);
+
+    uint8_t* GetRememberedSetValue(uint8_t* ref);
+
+    std::map<uint8_t*, uint8_t*>* GetRememberedSet();
+
+    template <typename Visitor>
+    void VisitRegionRememberedObjects(const Visitor& visitor) REQUIRES_SHARED(Locks::mutator_lock_) {
+      for (auto& x : remembered_set_) {
+        visitor(reinterpret_cast<mirror::Object*>(x.second));
+      }
+    }
+    // jiacheng end
 
     bool IsFree() const {
       bool is_free = (state_ == RegionState::kRegionStateFree);
@@ -438,6 +466,11 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
     void Unfree(RegionSpace* region_space, uint32_t alloc_time)
         REQUIRES(region_space->region_lock_);
 
+    // jiacheng start
+    void UnfreeCold(RegionSpace* region_space, uint32_t alloc_time)
+        REQUIRES(region_space->region_lock_);
+    // jiacheng end
+
     // Given a free region, declare it non-free (allocated) and large.
     void UnfreeLarge(RegionSpace* region_space, uint32_t alloc_time)
         REQUIRES(region_space->region_lock_);
@@ -504,6 +537,16 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
       return type_ == RegionType::kRegionTypeUnevacFromSpace;
     }
 
+    // jiacheng start
+    bool IsInColdSpace() const {
+      return type_ == RegionType::kRegionTypeColdSpace;
+    }
+
+    bool IsInColdToSpace() const {
+      return type_ == RegionType::kRegionTypeColdToSpace;
+    }
+    // jiacheng end
+
     bool IsInNoSpace() const {
       return type_ == RegionType::kRegionTypeNone;
     }
@@ -542,6 +585,27 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
       type_ = RegionType::kRegionTypeToSpace;
     }
 
+    // jiacheng start
+    void SetAsColdSpace() {
+      is_newly_allocated_ = false;
+      type_ = RegionType::kRegionTypeColdSpace;
+    }
+
+    void SetAsColdToSpace() {
+      type_ = RegionType::kRegionTypeColdToSpace;
+    }
+
+    void SetColdSpaceAsColdToSpace() {
+      DCHECK(!IsFree() && IsInColdSpace());
+      type_ = RegionType::kRegionTypeColdToSpace;
+    }
+
+    void SetColdSpaceAsToSpace() {
+      DCHECK(!IsFree() && IsInColdSpace());
+      type_ = RegionType::kRegionTypeToSpace;
+    }
+    // jiacheng end
+
     // Return whether this region should be evacuated. Used by RegionSpace::SetFromSpace.
     ALWAYS_INLINE bool ShouldBeEvacuated(EvacMode evac_mode);
 
@@ -623,9 +687,17 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
     RegionState state_;                 // The region state (see RegionState).
     RegionType type_;                   // The region type (see RegionType).
 
+    // jiacheng start
+    std::map<uint8_t*, uint8_t*> remembered_set_;  // TODO: Change to java object so as to process in GC process easily
+    // jiacheng end
+
     friend class RegionSpace;
   };
 
+  // jiacheng start
+  private:
+  // jiacheng end
+
   template<bool kToSpaceOnly, typename Visitor>
   ALWAYS_INLINE void WalkInternal(Visitor&& visitor) NO_THREAD_SAFETY_ANALYSIS;
 
@@ -723,6 +795,82 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
   // objects earlier in debug mode.
   void PoisonDeadObjectsInUnevacuatedRegion(Region* r);
 
+  // jiacheng start
+public:
+  bool IsInColdSpace(mirror::Object* ref) {
+    if (HasAddress(ref)) {
+      Region* r = RefToRegionUnlocked(ref);
+      return r->IsInColdSpace();
+    }
+    return false;
+  }
+
+  bool IsInColdToSpace(mirror::Object* ref) {
+    if (HasAddress(ref)) {
+      Region* r = RefToRegionUnlocked(ref);
+      return r->IsInColdToSpace();
+    }
+    return false;
+  }
+
+  void JiachengDebug() REQUIRES(!region_lock_);
+
+  uint32_t SwapOutCold() REQUIRES(!region_lock_);
+
+  void HandleFault(mirror::Object* ref) REQUIRES(!region_lock_);
+
+  Region* AllocateColdRegion() REQUIRES(region_lock_);
+
+  mirror::Object* AllocCold(size_t num_bytes,
+                            /* out */ size_t* bytes_allocated,
+                            /* out */ size_t* usable_size,
+                            /* out */ size_t* bytes_tl_bulk_allocated) REQUIRES(!region_lock_);
+
+  mirror::Object* AllocLargeCold(size_t num_bytes,
+                                /* out */ size_t* bytes_allocated,
+                                /* out */ size_t* usable_size,
+                                /* out */ size_t* bytes_tl_bulk_allocated) REQUIRES(!region_lock_);
+
+  void InitColdToRegionRememberedSet() REQUIRES(!region_lock_);
+
+  void WriteBackRegionRememberedSet() REQUIRES(!region_lock_);
+
+  template<typename Visitor>
+  void VisitRememberedObjectsAsRoot(Visitor& visitor) REQUIRES(!region_lock_) REQUIRES_SHARED(Locks::mutator_lock_) {
+    Thread* self = Thread::Current();
+    LOG(INFO) << "jiacheng region_space.h 839 VisitRememberedObjectsAsRoot() ";
+    MutexLock mu(self, region_lock_);
+    for (size_t i = 0; i < std::min(num_regions_, non_free_region_index_limit_); ++i) {
+      Region* r = &regions_[i];
+      if (!r->IsInColdSpace()) {
+        continue;
+      }
+      std::map<uint8_t*, uint8_t*>* remembered_set = r->GetRememberedSet();
+      for (auto& it : *remembered_set) {
+        uint8_t** ref = &(it.second);
+        *ref = reinterpret_cast<uint8_t*>(visitor(reinterpret_cast<mirror::Object*>(*ref)));
+      }
+      LOG(INFO) << "jiacheng region_space.h 850 i= " << i;
+    }
+  }
+
+  template<typename Visitor>
+  void VisitRememberedObjects(Visitor& visitor) REQUIRES(!region_lock_) REQUIRES_SHARED(Locks::mutator_lock_) {
+    Thread* self = Thread::Current();
+    LOG(INFO) << "jiacheng region_space.h 858 VisitRememberedObjects() ";
+    MutexLock mu(self, region_lock_);
+    for (size_t i = 0; i < std::min(num_regions_, non_free_region_index_limit_); ++i) {
+      Region* r = &regions_[i];
+      if (!r->IsInColdSpace()) {
+        continue;
+      }
+      r->VisitRegionRememberedObjects(visitor);
+      LOG(INFO) << "jiacheng region_space.h 866 i= " << i;
+    }
+  }
+private:
+  // jiacheng end
+
   Mutex region_lock_ DEFAULT_MUTEX_ACQUIRED_AFTER;
 
   // Cached version of Heap::use_generational_cc_.
@@ -762,6 +910,10 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
   // Mark bitmap used by the GC.
   std::unique_ptr<accounting::ContinuousSpaceBitmap> mark_bitmap_;
 
+  // jiacheng start
+  Region* current_cold_region_;
+  // jiacheng end
+
   DISALLOW_COPY_AND_ASSIGN(RegionSpace);
 };
 
diff --git a/runtime/interpreter/interpreter.cc b/runtime/interpreter/interpreter.cc
index db116f5a63..137a0cbe9c 100644
--- a/runtime/interpreter/interpreter.cc
+++ b/runtime/interpreter/interpreter.cc
@@ -241,7 +241,10 @@ enum InterpreterImplKind {
 #if ART_USE_CXX_INTERPRETER
 static constexpr InterpreterImplKind kInterpreterImplKind = kSwitchImplKind;
 #else
-static constexpr InterpreterImplKind kInterpreterImplKind = kMterpImplKind;
+// jiacheng start
+// static constexpr InterpreterImplKind kInterpreterImplKind = kMterpImplKind;
+static constexpr InterpreterImplKind kInterpreterImplKind = kSwitchImplKind;
+// jiacheng end
 #endif
 
 static inline JValue Execute(
diff --git a/runtime/jiacheng_activity_manager.h b/runtime/jiacheng_activity_manager.h
index d548b8af0d..e16197cc85 100644
--- a/runtime/jiacheng_activity_manager.h
+++ b/runtime/jiacheng_activity_manager.h
@@ -1,9 +1,8 @@
-#ifndef JIACHENG_ACTIVITY_MANAGER_H_
-#define JIACHENG_ACTIVITY_MANAGER_H_
+#ifndef ART_RUNTIME_JIACHENG_ACTIVITY_MANAGER_H_
+#define ART_RUNTIME_JIACHENG_ACTIVITY_MANAGER_H_
 
 #include <set>
 #include <map>
-#include <atomic>
 
 #include "base/mutex.h"
 
diff --git a/runtime/jiacheng_barrier.cc b/runtime/jiacheng_barrier.cc
new file mode 100644
index 0000000000..4f518bbb6d
--- /dev/null
+++ b/runtime/jiacheng_barrier.cc
@@ -0,0 +1,42 @@
+#include "jiacheng_barrier.h"
+#include "jiacheng_profiler.h"
+#include "jiacheng_utils.h"
+
+#include "mirror/object.h"
+
+namespace art {
+namespace jiacheng {
+
+
+void JiachengBarrier(uint64_t obj) {
+    if (!obj) {
+        return;
+    }
+    if (!IsWhiteApp()) {
+        return;
+    }
+    Profiler* profiler = Profiler::Current();
+    if (profiler->GetPerceptibleFlag()) {
+        return;
+    }
+
+    // jiacheng debug start
+
+    // static size_t cnt = 0;
+    // cnt += 1;
+    // if (cnt % 100 == 0) {
+    //     LOG(INFO) << "jiacheng JiachengBarrier() " << "obj= " << obj;
+    //     cnt = 0;
+    // }
+
+    // jiacheng debug end
+    
+    if (!profiler->GetDuringGcFlag()) {
+        profiler->RecordAccessWS(reinterpret_cast<mirror::Object *>(obj));
+    } else {
+        // profiler->RecordGcWS(reinterpret_cast<mirror::Object *>(obj));
+    }
+}
+
+}
+}
\ No newline at end of file
diff --git a/runtime/jiacheng_barrier.h b/runtime/jiacheng_barrier.h
new file mode 100644
index 0000000000..5cbf1a372d
--- /dev/null
+++ b/runtime/jiacheng_barrier.h
@@ -0,0 +1,16 @@
+#ifndef ART_RUNTIME_JIACHENG_BARRIER_H_
+#define ART_RUNTIME_JIACHENG_BARRIER_H_
+
+#include "base/mutex.h"
+
+namespace art {
+namespace jiacheng {
+
+// void JiachengBarrier(uint64_t obj) REQUIRES_SHARED(Locks::mutator_lock_);
+void JiachengBarrier(uint64_t obj);
+
+
+} // namespace jiacheng
+} // namespace art
+
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_bloom_filter.h b/runtime/jiacheng_bloom_filter.h
new file mode 100644
index 0000000000..eade861eae
--- /dev/null
+++ b/runtime/jiacheng_bloom_filter.h
@@ -0,0 +1,133 @@
+#ifndef ART_RUNTIME_JIACHENG_BLOOM_FILTER_H_
+#define ART_RUNTIME_JIACHENG_BLOOM_FILTER_H_
+
+/*
+* Code inspired by:
+* https://github.com/jvirkki/libbloom/blob/master/bloom.c
+*/
+
+#include <cinttypes>
+#include <cmath>
+#include <cstddef>
+#include <cstdlib>
+#include <cassert>
+
+namespace art{
+namespace jiacheng {
+
+class BloomFilter {
+public:
+    /*
+    * BloomFilter: initialize a bloom filter.
+    *
+    * Parameters:
+    *   entries: The expected number of elements that will be added
+    *   fp_rate: The desired upper bound on the false positive rate
+    */
+    BloomFilter(uint64_t entries, double fp_rate):hash_() {
+        assert(fp_rate < 1 && fp_rate > 0);
+
+        double num, denom, bpe, dentries;
+        num = std::log(fp_rate);
+        denom = 0.480453013918201; // ln(2)^2
+        bpe = -(num / denom);
+
+        dentries = (double)entries;
+        bits_ = (uint_fast32_t)(dentries * bpe);
+
+        if (bits_ % 8) {
+            byte_size_ = (bits_ / 8) + 1;
+        } else {
+            byte_size_ = bits_ / 8;
+        }
+        hash_num_ = (uint_fast16_t)std::ceil(0.693147180559945 * bpe); // ln(2)
+        bf_ = (uint8_t*)calloc(byte_size_, sizeof(uint8_t));
+        assert(bf_ != NULL);
+    }
+
+    ~BloomFilter() {
+        free(bf_);
+    }
+
+    /*
+    * Add: add an item to a bloom filter.
+    *
+    * Parameters:
+    *   element: the data that should be added
+    *
+    * Returns:
+    *    false - element was not present and was added
+    *    true - element (or a collision) had already been added previously
+    */
+    bool Add(uint64_t element) {
+        uint64_t hits = 0;
+
+        uint32_t a = hash_(element);
+        uint32_t b = hash_(a);
+        uint32_t x;
+
+        for (uint32_t i = 0; i < hash_num_; i++) {
+            x = (a + i * b) % bits_;
+    #define THREAD_SAFE true
+    #ifdef THREAD_SAFE
+            if (__sync_fetch_and_or(bf_ + (x >> 3), (uint8_t)(1 << (x & 7)))) {
+                hits++;
+            }
+    #else
+            if (*(bf_ + (x >> 3)) & (1 << (x & 7))) {
+                hits++;
+            }
+            *(bf_ + (x >> 3)) |= (1 << (x & 7));
+    #endif
+        }
+
+        if (hits == hash_num_) {
+            return true;
+        }
+        return false;
+    }
+
+    /*
+    * Check: check if an item is in the bloom filter.
+    *
+    * Parameters:
+    *   element: the data that should be checked
+    *
+    * Returns:
+    *    false - element is not present
+    *    true - element is present (or a collision)
+    */
+    bool Check(uint64_t element) {
+        uint64_t hits = 0;
+        uint32_t x;
+
+        uint32_t a = hash_(element);
+        uint32_t b = hash_(a);
+        for (uint32_t i = 0; i < hash_num_; i++) {
+            x = (a + i * b) % bits_;
+            if (*(bf_ + (x >> 3)) & (1 << (x & 7))) {
+                hits++;
+            } else {
+                return false;
+            }
+        }
+        return hits == hash_num_;
+    }
+
+    void Clear() {
+        std::memset(bf_, 0, byte_size_);
+    }
+
+
+private:
+    std::hash<uint64_t> hash_;
+    uint32_t byte_size_;
+    uint_fast32_t bits_;        // Number of bits in the bloom filter buffer
+    uint_fast16_t hash_num_;    // Number of hashes used per element added
+    uint8_t *bf_;               // Location of the underlying bit field
+};
+
+} // namespace jiacheng
+} // namespace art
+
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_cheatsheet.cc b/runtime/jiacheng_cheatsheet.cc
index eb0d51034d..0bcf1547ac 100644
--- a/runtime/jiacheng_cheatsheet.cc
+++ b/runtime/jiacheng_cheatsheet.cc
@@ -1,26 +1,26 @@
-#include "jiacheng_cheatsheet.h"
+// #include "jiacheng_cheatsheet.h"
 
 
-namespace art {
-namespace jiacheng {
+// namespace art {
+// namespace jiacheng {
 
 
-void CheatSheet::AddRememberedSet(uint8_t *obj) {
-    remembered_set_.insert(obj);
-}
+// void CheatSheet::AddRememberedSet(uint8_t *obj) {
+//     remembered_set_.insert(obj);
+// }
 
-void CheatSheet::AddColdSet(uint8_t *obj) {
-    cold_set_.insert(obj);
-}
+// void CheatSheet::AddColdSet(uint8_t *obj) {
+//     cold_set_.insert(obj);
+// }
 
-bool CheatSheet::InRememberedSet(uint8_t *obj) {
-    return remembered_set_.find(obj) != remembered_set_.end();
-}
+// bool CheatSheet::InRememberedSet(uint8_t *obj) {
+//     return remembered_set_.find(obj) != remembered_set_.end();
+// }
 
-bool CheatSheet::InColdSet(uint8_t *obj) {
-    return cold_set_.find(obj) != cold_set_.end();
-}
+// bool CheatSheet::InColdSet(uint8_t *obj) {
+//     return cold_set_.find(obj) != cold_set_.end();
+// }
 
 
-}
-}
\ No newline at end of file
+// }
+// }
\ No newline at end of file
diff --git a/runtime/jiacheng_cheatsheet.h b/runtime/jiacheng_cheatsheet.h
index 7ce875dbb9..9df19d195c 100644
--- a/runtime/jiacheng_cheatsheet.h
+++ b/runtime/jiacheng_cheatsheet.h
@@ -1,28 +1,26 @@
-#ifndef JIACHENG_CHEATSHEET_H_
-#define JIACHENG_CHEATSHEET_H_
+// #ifndef ART_RUNTIME_JIACHENG_CHEATSHEET_H_
+// #define ART_RUNTIME_JIACHENG_CHEATSHEET_H_
 
-#include <set>
+// #include <set>
 
-namespace art {
-namespace jiacheng {
+// namespace art {
+// namespace jiacheng {
 
-class CheatSheet {
-public:
-    CheatSheet();
-    ~CheatSheet();
+// class CheatSheet {
+// public:
+//     CheatSheet();
+//     ~CheatSheet();
 
-    void AddRememberedSet(uint8_t *obj);
-    void AddColdSet(uint8_t *obj);
+//     void AddRememberedSet(uint8_t *obj);
+//     void AddColdSet(uint8_t *obj);
 
-    bool InRememberedSet(uint8_t *obj);
-    bool InColdSet(uint8_t * obj);
+//     bool InRememberedSet(uint8_t *obj);
+//     bool InColdSet(uint8_t * obj);
 
-    std::set<uint8_t*> remembered_set_;
-    std::set<uint8_t*> cold_set_;
-    std::set<uint8_t*> hot_set_;
-};
+//     std::map<uint8_t*, uint32_t> remembered_set_;
+// };
 
-}
-}
+// }
+// }
 
-#endif
\ No newline at end of file
+// #endif
\ No newline at end of file
diff --git a/runtime/jiacheng_cold_space.cc b/runtime/jiacheng_cold_space.cc
deleted file mode 100644
index c26a6bf6b7..0000000000
--- a/runtime/jiacheng_cold_space.cc
+++ /dev/null
@@ -1,171 +0,0 @@
-#include <fstream>
-#include <thread>
-#include <chrono>
-#include <atomic>
-#include <sys/mman.h>
-
-#include "base/mem_map.h"
-#include "gc/space/region_space.h"
-#include "base/mutex.h"
-#include "thread_list.h"
-#include "thread-current-inl.h"
-
-#include "jiacheng_hack.h"
-#include "jiacheng_cold_space.h"
-#include "jiacheng_region.h"
-
-
-namespace art{
-namespace jiacheng {
-
-Mutex ColdSpace::singleton_lock_("Cold Space Singleton Lock", kLoggingLock);
-
-ColdSpace* ColdSpace::cold_space_ = nullptr;
-
-ColdSpace::ColdSpace(MemMap* mem_map):
-    region_lock_("Cold Space Lock", kLoggingLock),
-    mem_map_(mem_map),
-    begin_(mem_map->Begin()),
-    end_(mem_map->End()),
-    num_regions_(mem_map->Size() / kRegionSize),
-    top_region_idx_(0U),
-    current_region_(nullptr),
-    madvice_top_region_idx_(0),
-    allocated_obj_num_(0),
-    mark_bitmap_(),
-    remembered_set_(),
-    remembered_root_stack_() {
-    
-    regions_.reset(new Region[num_regions_]);
-    uint8_t* region_addr = mem_map->Begin();
-    for (size_t i = 0; i < num_regions_; ++i, region_addr += kRegionSize) {
-        regions_[i].Init(i, region_addr, region_addr + kRegionSize);
-    }
-    current_region_ = &regions_[top_region_idx_++];
-
-}
-
-ColdSpace::~ColdSpace() {}
-
-ColdSpace* ColdSpace::Current() {
-    if (cold_space_ == nullptr) {
-        Thread* self = Thread::Current();
-        singleton_lock_.ExclusiveLock(self);
-        if (cold_space_ == nullptr) {
-            cold_space_ = Create();
-        }
-        singleton_lock_.ExclusiveUnlock(self);
-    }
-    return cold_space_;
-}
-
-
-ColdSpace* ColdSpace::Create() {
-    std::string error_msg;
-    MemMap mem_map = MemMap::MapAnonymous("Cold Space",
-                                            nullptr,
-                                            kCapacitySize + kRegionSize,
-                                            PROT_READ | PROT_WRITE,
-                                            true,
-                                            false,
-                                            nullptr,
-                                            &error_msg);
-
-    // if (!mem_map) {
-    //     LOG(INFO) << "jiacheng jiacheng_cold_space.cc 75 mem_map=nullptr error_msg= " << error_msg; 
-    // }
-    return new ColdSpace(&mem_map);
-}
-
-void ColdSpace::JiachengDebug() {
-    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "mem_map_= " << size_t(mem_map_); 
-    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "num_regions_= " << num_regions_; 
-    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "top_region_idx_= " << top_region_idx_; 
-    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "current_region_= " << current_region_; 
-    LOG(INFO) << "jiacheng jiacheng_cold_space.cc 62 " << "allocated_obj_num_= " << allocated_obj_num_.load(); 
-}
-
-
-mirror::Object* ColdSpace::Alloc(size_t num_bytes) {
-    num_bytes = RoundUp(num_bytes, kAlignment);
-    mirror::Object* obj;
-    obj = current_region_->Alloc(num_bytes);
-    if (obj != nullptr) {
-        allocated_obj_num_.fetch_add(1);
-        return obj;
-    }
-    Region* r = AllocateRegion();
-    if (r == nullptr) {
-        LOG(INFO) << "jiacheng jiacheng_cold_space.cc 83 AllocateRegion() ColdSpace已满!";
-        return nullptr;
-    }
-    current_region_ = r;
-    obj = current_region_->Alloc(num_bytes);
-    if (obj != nullptr) {
-        allocated_obj_num_.fetch_add(1);
-    }
-    return obj;
-}
-
-Region* ColdSpace::AllocateRegion() {
-    if (top_region_idx_ >= num_regions_) {
-        return nullptr;
-    }
-    return &regions_[top_region_idx_++];
-}
-
-void ColdSpace::SwapOut() {
-    // if (madvice_top_region_idx_ < top_region_idx_ - 1) { // 把Current之前的Region进行Swap
-    //     uint8_t* begin = regions_[madvice_top_region_idx_].Begin();
-    //     uint8_t* end = regions_[top_region_idx_ - 2].End();
-    //     LOG(INFO) << "jiacheng jiacheng_cold_space.cc 111 begin= " << size_t(begin) << " end= " << size_t(end) 
-    //               << " madvice_top_region_idx_= " << madvice_top_region_idx_
-    //               << " top_region_idx_= " << top_region_idx_;
-    //     madvise(begin, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(begin) - 1, 233);
-    //     madvice_top_region_idx_ = top_region_idx_ - 1;
-    // }
-    if (0 < top_region_idx_ - 1) { // 把Current之前的Region进行Swap
-        uint8_t* begin = regions_[0].Begin();
-        uint8_t* end = regions_[top_region_idx_ - 2].End();
-        LOG(INFO) << "jiacheng jiacheng_cold_space.cc 111 begin= " << size_t(begin) << " end= " << size_t(end) 
-                  << " madvice_top_region_idx_= " << madvice_top_region_idx_
-                  << " top_region_idx_= " << top_region_idx_;
-        madvise(begin, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(begin) - 1, 233);
-        // madvice_top_region_idx_ = top_region_idx_ - 1;
-    }
-}
-
-bool ColdSpace::HasAddress(mirror::Object* obj) const {
-    const uint8_t* byte_ptr = reinterpret_cast<const uint8_t*>(obj);
-    return byte_ptr >= Begin() && byte_ptr < End();
-}
-
-bool ColdSpace::GetMarkBitmap(mirror::Object* to_ref) {
-    return mark_bitmap_.find(to_ref) != remembered_set_.end();
-}
-
-void ColdSpace::SetMarkBitmap(mirror::Object* to_ref) {
-    mark_bitmap_.insert(to_ref);
-}
-
-void ColdSpace::ResetMarkBitmap() {
-    mark_bitmap_.clear();
-}
-
-void ColdSpace::AddRememberedSet(mirror::Object* obj) {
-    remembered_set_.insert(obj);
-}
-
-// 把Obj对象中包含的所有引用加入的根集
-void ColdSpace::AddRememberedRootSet(mirror::Object* obj) {
-    remembered_root_stack_.push_back(obj);
-}
-
-// 得到GC之前的根集合
-std::vector<mirror::Object*>* ColdSpace::GetRememberedRootStack() {
-    return &(remembered_root_stack_);
-}
-
-
-} // namespace jiacheng
-} // namespace art
diff --git a/runtime/jiacheng_cold_space.h b/runtime/jiacheng_cold_space.h
deleted file mode 100644
index 46e8242bcb..0000000000
--- a/runtime/jiacheng_cold_space.h
+++ /dev/null
@@ -1,103 +0,0 @@
-#ifndef JIACHENG_COLD_SPACE_H_
-#define JIACHENG_COLD_SPACE_H_
-
-#include <atomic>
-#include "base/mutex.h"
-
-namespace art{
-
-namespace mirror {
-class Object;
-}  // namespace mirror
-
-class MemMap;
-
-// ------------ START -------------
-namespace jiacheng {
-
-class Region;
-
-class ColdSpace {
-public: 
-  ColdSpace(MemMap* mem_map);
-  ~ColdSpace();
-
-  static Mutex singleton_lock_;
-  static ColdSpace* cold_space_; 
-
-  static ColdSpace* Create();
-  static ColdSpace* Current();
-
-  void JiachengDebug();
-
-  mirror::Object* Alloc(size_t num_bytes);
-
-  Region* AllocateRegion();
-
-  void SwapOut();
-
-  bool HasAddress(mirror::Object* obj) const;
-
-  bool GetMarkBitmap(mirror::Object* to_ref);
-
-  void SetMarkBitmap(mirror::Object* to_ref);
-
-  void ResetMarkBitmap();
-
-  void AddRememberedSet(mirror::Object* obj);
-
-  void AddRememberedRootSet(mirror::Object* obj);
-
-  std::vector<mirror::Object*>* GetRememberedRootStack();
-
-  uint8_t* Begin() const {
-    return begin_;
-  }
-
-  uint8_t* End() const {
-    return end_;
-  }
-
-  size_t GetAllocatedObjNum() const {
-    return allocated_obj_num_.load();
-  }
-
-
-  // ---------------- 变量开始 ----------------------
-  // Object alignment within the space.
-  static constexpr size_t kAlignment = kObjectAlignment;
-  // The region size.
-  static constexpr size_t kRegionSize = 4 * KB;
-  // The capacity size.
-  static constexpr size_t kCapacitySize = kRegionSize * 1024 * 100; // 400MB
-
-  Mutex region_lock_;
-
-  MemMap* mem_map_;
-
-  uint8_t* begin_;
-  uint8_t* end_;
-
-  std::unique_ptr<Region[]> regions_;
-
-  size_t num_regions_;             
-
-  size_t top_region_idx_;
-
-  Region* current_region_;         
-
-  size_t madvice_top_region_idx_;
-
-  std::atomic<size_t> allocated_obj_num_;
-
-  std::set<mirror::Object*> mark_bitmap_;
-
-  std::set<mirror::Object*> remembered_set_;
-
-  std::vector<mirror::Object*> remembered_root_stack_;
-};
-
-
-} // namespace jiacheng
-} // namespace art
-#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_debug.cc b/runtime/jiacheng_debug.cc
new file mode 100644
index 0000000000..9b699efcd7
--- /dev/null
+++ b/runtime/jiacheng_debug.cc
@@ -0,0 +1,472 @@
+#include <chrono>
+#include <atomic>
+#include <thread>
+#include <random>
+#include <sstream>
+#include <fstream>
+
+#include <unistd.h>
+#include <sys/syscall.h>
+
+#include "gc/accounting/card_table.h"
+#include "gc/heap.h"
+#include "gc/space/space-inl.h"
+#include "gc/heap-visit-objects-inl.h"
+#include "gc/space/zygote_space.h"
+#include "gc/space/bump_pointer_space-inl.h"
+#include "gc/space/bump_pointer_space-walk-inl.h"
+#include "gc/space/dlmalloc_space-inl.h"
+#include "gc/space/image_space.h"
+#include "gc/space/large_object_space.h"
+#include "gc/space/malloc_space.h"
+#include "gc/space/region_space-inl.h"
+#include "gc/space/rosalloc_space-inl.h"
+#include "mirror/class-inl.h"
+#include "obj_ptr-inl.h"
+#include "scoped_thread_state_change-inl.h"
+#include "thread_list.h"
+#include "gc/accounting/mod_union_table-inl.h"
+#include "gc/accounting/remembered_set.h"
+#include "base/mutex.h"
+#include "read_barrier_config.h"
+
+#include "jiacheng_debug.h"
+#include "jiacheng_utils.h"
+
+namespace art {
+namespace jiacheng {
+
+static Mutex working_set_lock("Profiler Singleton Lock", kLoggingLock);
+static std::set<mirror::Object*> working_set;
+static std::set<size_t> page_working_set;
+static size_t all_object_size;
+
+void RecordWorkingSet(mirror::Object* obj) {
+    Thread* self = Thread::Current();
+    working_set_lock.ExclusiveLock(self);
+    if (working_set.find(obj) == working_set.end()) {
+        size_t object_size = 0;
+        {
+            ReaderMutexLock mu(self, *Locks::mutator_lock_); 
+            object_size = obj->SizeOf();
+        }
+        all_object_size += object_size;
+        size_t begin_addr = reinterpret_cast<size_t>(obj);
+        size_t end_addr = begin_addr + object_size;
+        while (begin_addr < end_addr) {
+            page_working_set.insert(begin_addr >> 12);
+            begin_addr += 1 << 12;
+        }
+        working_set.insert(obj);
+    }
+    
+    working_set_lock.ExclusiveUnlock(self);
+}
+
+void ClearAndPrintWorkingSet() {
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    size_t total_memory = heap->GetTotalMemory();
+    size_t total_active_page = 0;
+    size_t total_active_object = 0;
+    Thread* self = Thread::Current();
+
+    working_set_lock.ExclusiveLock(self);
+    total_active_page = page_working_set.size() << 12;
+    total_active_object = all_object_size;
+    working_set.clear();
+    page_working_set.clear();
+    all_object_size = 0;
+    working_set_lock.ExclusiveUnlock(self);
+
+    LOG(INFO) << "jiacheng jiacheng_debug.cc 78 ClearAndPrintWorkingSet()"
+              << " active_object= " << total_active_object
+              << " active_page= " << total_active_page
+              << " total_memory= " << total_memory
+              << std::flush;
+}
+
+
+typedef void(*WalkCallback)(void *start, void *end, size_t num_bytes, void* callback_arg);
+
+// 对ColdSpace中的Region进行Swap
+void SwapOutAll() {
+    // 对所有Space中的对象进行Swap
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    Thread* self = Thread::Current();
+    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
+    {
+        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
+        continues_spaces = &(heap->GetContinuousSpaces());
+    }
+    for (auto space : *continues_spaces) {
+        CurrentThreadSleepSecond(1);
+        SwapOutSpace(space);
+    }
+    const std::vector<gc::space::DiscontinuousSpace*>& discontinues_spaces = heap->GetDiscontinuousSpaces();
+    for (auto space : discontinues_spaces) {
+        CurrentThreadSleepSecond(1);
+        SwapOutSpace(space);
+    }    
+
+    // 不直接使用SwapOutSpace()函数对所有Space中的对象进行Swap
+    // LOG(INFO) << "jiacheng jiacheng_hack.cc 180 SwapOut()";
+    // ColdSpace* cold_space = ColdSpace::Current();
+    // cold_space->SwapOut();
+}
+
+
+void SwapOutSpace(gc::space::Space* space) {
+    Thread* self = Thread::Current();
+    gc::space::SpaceType space_type = space->GetType();
+    
+    WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* ) {
+        // if (start != end && ActivityManager::Current()->ShouldSwapOut(reinterpret_cast<mirror::Object*>(start))) {
+        if (start != end) {
+            LOG(INFO) << "jiacheng_hack.cc 143 ShouldSwapOut() obj= " << size_t(start) << " size= " << size_t(end) - size_t(start);
+            madvise(start, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start), 233);
+        }
+    };    
+    auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_){
+        // if (obj && ActivityManager::Current()->ShouldSwapOut(obj)) {
+        if (obj) {
+            LOG(INFO) << "jiacheng_hack.cc 150 ShouldSwapOut() obj= " << size_t(obj) << " size= " << obj->SizeOf();
+            madvise(static_cast<void *>(obj), obj->SizeOf(), 233);
+        }
+    };
+    switch (space_type) {
+        case gc::space::kSpaceTypeImageSpace: {
+            // gc::space::ImageSpace* this_space = space->AsImageSpace();
+            break;
+        }
+        case gc::space::kSpaceTypeMallocSpace: {
+            gc::space::MallocSpace* this_space = space->AsMallocSpace();
+            this_space->Walk(walk_callback, nullptr);
+            break;
+        }
+        case gc::space::kSpaceTypeZygoteSpace: {
+            // gc::space::ZygoteSpace* this_space = space->AsZygoteSpace();
+            break;
+        }
+        case gc::space::kSpaceTypeBumpPointerSpace: {
+            gc::space::BumpPointerSpace* this_space = space->AsBumpPointerSpace();
+            { 
+                WriterMutexLock mu(self, *Locks::mutator_lock_);  
+                this_space -> Walk(visitor);
+            }
+            break;
+        }
+        case gc::space::kSpaceTypeLargeObjectSpace: {
+            gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
+            this_space->Walk(walk_callback, nullptr);
+            break;
+        }
+        case gc::space::kSpaceTypeRegionSpace: {
+            gc::space::RegionSpace* this_space = space->AsRegionSpace();   
+            {
+                WriterMutexLock mu(self, *Locks::mutator_lock_);  
+                this_space -> Walk(visitor);
+            }
+            break;
+        }
+        default:
+            LOG(INFO) << "jiacheng " << "jiacheng_hack.cc 100. Can not find space.";
+    }
+}
+
+
+/* ------------------- debug --------------------- */
+
+// 查看Object在哪个Space里面
+std::string GetSpaceFromObject(mirror::Object* obj) {
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    if (!heap) {
+        return "no_heap";
+    }
+    gc::space::RegionSpace* region_space = heap->GetRegionSpace();
+    gc::space::LargeObjectSpace* large_object_space = heap->GetLargeObjectsSpace();
+    gc::space::MallocSpace* non_moving_space = heap->GetNonMovingSpace();
+    gc::space::ZygoteSpace* zygote_space = heap->GetZygoteSpace();
+    const std::vector<gc::space::ImageSpace*>& boot_image_spaces = heap->GetBootImageSpaces();
+    
+    if (region_space && region_space->Contains(obj)) {
+        return "region_space";
+    } else if (non_moving_space && non_moving_space->Contains(obj)) {
+        return "non_moving_space";
+    } else if (large_object_space && large_object_space->Contains(obj)) {
+        return "large_object_space";
+    } else if (zygote_space && zygote_space->Contains(obj)) {
+        return "zygote_space";
+    } 
+    for (gc::space::ImageSpace* space : boot_image_spaces) {
+        if (space->Contains(obj)) {
+            return "boot_image_spaces";
+        }
+    }
+
+    Thread* self = Thread::Current();
+    {
+        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
+        const std::vector<gc::space::ContinuousSpace*>& continues_spaces = heap->GetContinuousSpaces();
+        for (size_t i = 0; i < continues_spaces.size(); ++i) {
+            gc::space::ContinuousSpace* space = continues_spaces[i];
+            if (space->Contains(obj)) {
+                return "continues_spaces-" + std::to_string(i) + "-" + space->GetName();
+            }
+        }
+    }
+
+    return "other_space";
+}
+
+class ObjectInfo {
+public:
+    ObjectInfo(size_t object_address, size_t object_size, std::string&& space)
+        : object_address_(object_address), object_size_(object_size), space_(space) {}
+
+    std::string ToString() const {
+        std::ostringstream string_stream;
+        string_stream << "address= " << object_address_
+                      << " size= " << object_size_
+                      << " space= " << space_;
+        return string_stream.str();
+    }
+
+private:
+    size_t object_address_;
+    size_t object_size_;
+    std::string space_;
+};
+
+void PrintRegionSpaceInformation(uint32_t info_key) {
+    Thread* self = Thread::Current();
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    gc::space::RegionSpace* region_space = heap->GetRegionSpace();
+    std::vector<ObjectInfo> object_infomations;
+    auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_) {
+        if (obj != nullptr) {
+            size_t object_address, object_size;
+            object_address = reinterpret_cast<size_t>(obj);
+            object_size = obj->SizeOf();
+            std::string space = "region_space";
+            object_infomations.emplace_back(ObjectInfo(object_address, object_size, std::move(space)));
+        }
+    }; 
+    {
+        WriterMutexLock mu(self, *Locks::mutator_lock_);  
+        region_space -> Walk(visitor);
+    }
+    for (const auto& info : object_infomations) {
+        LOG(INFO) << "jiacheng jiacheng_utils.cc 269 "
+                  << " key= " << info_key 
+                  << " info= " << info.ToString();
+    }
+}
+
+void PrintLargeObjectSpaceInformation(uint32_t info_key) {
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    gc::space::LargeObjectSpace* large_object_space = heap->GetLargeObjectsSpace();
+    // std::vector<ObjectInfo> object_infomations;
+    WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* info_key) {
+        if (start != end) {
+            size_t object_address, object_size;
+            object_address = reinterpret_cast<size_t>(start);
+            object_size = size_t(end) - size_t(start);
+            std::string space = "large_object_space";
+            ObjectInfo info(object_address, object_size, std::move(space));
+            // object_infomations.emplace_back(ObjectInfo(object_address, object_size, std::move(space)));
+            LOG(INFO) << "jiacheng jiacheng_utils.cc 269 "
+                        << " key= " << *((uint32_t *)(info_key))
+                        << " info= " << info.ToString();
+        }
+    }; 
+    large_object_space->Walk(walk_callback, &info_key);
+    // for (const auto& info : object_infomations) {
+
+    // }
+}
+
+void PrintNonMovingSpaceInformation(uint32_t info_key) {
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    gc::space::MallocSpace* non_moving_space = heap->GetNonMovingSpace();
+    // std::vector<ObjectInfo> object_infomations;
+    WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* info_key) {
+        if (start != end) {
+            size_t object_address, object_size;
+            object_address = reinterpret_cast<size_t>(start);
+            object_size = size_t(end) - size_t(start);
+            std::string space = "non_moving_space";
+            ObjectInfo info(object_address, object_size, std::move(space));
+            // object_infomations.emplace_back(ObjectInfo(object_address, object_size, std::move(space)));
+            LOG(INFO) << "jiacheng jiacheng_utils.cc 269 "
+                        << " key= " << *((uint32_t *)(info_key))
+                        << " info= " << info.ToString();
+        }
+    }; 
+    non_moving_space->Walk(walk_callback, &info_key);
+    // for (const auto& info : object_infomations) {
+    //     LOG(INFO) << "jiacheng jiacheng_utils.cc 269 "
+    //               << " key= " << info_key 
+    //               << " info= " << info.ToString();
+    // }
+}
+
+void PrintHeapObjectInformation() {
+    // std::vector<ObjectInfo> object_infomations;
+
+    // gc::Heap* heap = Runtime::Current()->GetHeap();
+    // Thread* self = Thread::Current();
+    // {
+    //     auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_) {
+    //         if (obj != nullptr) {
+    //             size_t object_address, object_size;
+    //             object_address = reinterpret_cast<size_t>(obj);
+    //             object_size = obj->SizeOf();
+    //             std::string space = GetSpaceFromObject(obj);
+    //             object_infomations.emplace_back(ObjectInfo(object_address, object_size, std::move(space)));
+    //         }
+    //     };        
+    //     ScopedObjectAccess soa(self);
+    //     heap->VisitObjects(visitor);
+    // }
+    // uint32_t key = GenerateRandomKey();
+    // for (const auto& info : object_infomations) {
+    //     LOG(INFO) << "jiacheng jiacheng_utils.cc 269 "
+    //               << " key= " << key 
+    //               << " info= " << info.ToString();
+    // }
+    uint32_t key = GenerateRandomKey();
+    PrintLargeObjectSpaceInformation(key);
+    PrintRegionSpaceInformation(key);
+    PrintNonMovingSpaceInformation(key);
+
+}
+
+void VisitMemMap(const MemMap* mem_map) {
+    LOG(INFO) << "jiacheng VisitMemMap ";
+    LOG(INFO) << (*mem_map);
+    uint8_t* begin = mem_map->Begin();
+    uint8_t* end = mem_map->End();
+    void* base_begin = mem_map->BaseBegin();
+    void* base_end = mem_map->BaseEnd();
+    LOG(INFO) << "begin= " << reinterpret_cast<size_t>(begin) << ' '
+              << "end= " << reinterpret_cast<size_t>(end) << ' '
+              << "base_begin= " << reinterpret_cast<size_t>(base_begin) << ' '
+              << "base_end= " << reinterpret_cast<size_t>(base_end);
+    // print every byte
+    // for(uint8_t* p = begin; p != end; ++p) {
+    //     LOG(INFO) << static_cast<int>(*p);
+    // }
+
+}
+
+template<size_t kAlignment>
+void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* ) {
+}
+
+void VisitHeapBitmap(const gc::accounting::HeapBitmap* ) {
+}
+
+void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set) {
+    LOG(INFO) << "jiacheng VisitRememberedSet ";
+    auto table = const_cast<gc::accounting::RememberedSet*>(remembered_set);
+    {
+        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
+        table->Dump(LOG_STREAM(INFO));
+    }
+
+}
+
+void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table) {
+    LOG(INFO) << "jiacheng VisitModUnionTableToZygoteAllocspace ";
+    auto table = const_cast<gc::accounting::ModUnionTableToZygoteAllocspace*>(static_cast<const gc::accounting::ModUnionTableToZygoteAllocspace*>(mod_union_table));
+    {
+        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
+        table->Dump(LOG_STREAM(INFO));
+    }
+}
+
+void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table) {
+    LOG(INFO) << "jiacheng VisitModUnionTableCardCache ";
+    auto table = const_cast<gc::accounting::ModUnionTableCardCache*>(static_cast<const gc::accounting::ModUnionTableCardCache*>(mod_union_table));
+    {
+        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
+        table->Dump(LOG_STREAM(INFO));
+    }
+}
+
+void VisitCardTable(const gc::accounting::CardTable* card_table) {
+    (void)card_table;
+    LOG(INFO) << "jiacheng VisitCardTable ";
+    // MemMap* mem_map = &(card_table->mem_map_);
+    // uint8_t* const biased_begin = card_table->biased_begin_;
+    // const size_t offset = card_table->offset_;
+
+    // VisitMemMap(mem_map);
+    // LOG(INFO) << "biased_begin= " << reinterpret_cast<size_t>(biased_begin);
+    // LOG(INFO) << "offset= " << offset;
+}
+
+void DebugPrintModUnionAndRememberSet() {
+    if (Runtime::Current()->IsZygote()) {
+        return;
+    }
+    if (!Runtime::Current()->InJankPerceptibleProcessState()) {
+      LOG(INFO) << "jiacheng " << "InJankPerceptibleProcessState" ;
+      return;
+    }
+    // if (jiacheng::CheckHot()) {
+    //   LOG(INFO) << "jiacheng " << "CheckHot";
+    //   return;
+    // }  
+
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+
+    Thread* self = Thread::Current();
+    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
+    {
+        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
+        continues_spaces = &(heap->GetContinuousSpaces());
+    }
+    for (auto space : *continues_spaces) {
+        LOG(INFO) << space->GetName();
+        gc::space::SpaceType space_type = space->GetType();
+        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
+        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
+        if (mod_union_table) {
+            LOG(INFO) << "jiacheng mod_union_table";
+            if (space_type == gc::space::kSpaceTypeZygoteSpace) {
+                VisitModUnionTableCardCache(mod_union_table);
+            } else if (space_type == gc::space::kSpaceTypeImageSpace) {
+                VisitModUnionTableToZygoteAllocspace(mod_union_table);
+            }
+        } 
+        if (remembered_set) {
+            LOG(INFO) << "jiacheng remembered_set";
+            VisitRememberedSet(remembered_set);
+        }
+        if (mod_union_table == nullptr && remembered_set == nullptr) {
+            LOG(INFO) << "nullptr";
+        }
+    }
+    const std::vector<gc::space::DiscontinuousSpace*>* discontinues_spaces = &(heap->GetDiscontinuousSpaces());
+    for (auto space : *discontinues_spaces) {
+        LOG(INFO) << space->GetName();
+        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
+        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
+        if (mod_union_table) {
+            LOG(INFO) << "jiacheng mod_union_table";
+        } 
+        if (remembered_set) {
+            LOG(INFO) << "jiacheng remembered_set";
+        }
+        if (mod_union_table == nullptr && remembered_set == nullptr) {
+            LOG(INFO) << "nullptr";
+        }
+    }
+}
+
+
+
+
+}
+}
\ No newline at end of file
diff --git a/runtime/jiacheng_debug.h b/runtime/jiacheng_debug.h
new file mode 100644
index 0000000000..67f2cb8d75
--- /dev/null
+++ b/runtime/jiacheng_debug.h
@@ -0,0 +1,63 @@
+#ifndef ART_RUNTIME_JIACHENG_DEBUG_H_
+#define ART_RUNTIME_JIACHENG_DEBUG_H_
+
+namespace art {
+
+namespace gc {
+namespace space {
+    class Space;
+} // namespace space
+namespace accounting {
+    template <size_t kAlignment> class SpaceBitmap;
+    class HeapBitmap;
+    class RememberedSet;
+    class ModUnionTable;
+    class CardTable;
+} // namespace accounting
+} // namespace gc
+
+namespace mirror {
+    class Object;
+} // namespace mirror
+
+class MemMap;
+
+namespace jiacheng {
+
+void RecordWorkingSet(mirror::Object* obj);
+
+void ClearAndPrintWorkingSet();
+
+void SwapOutAll();
+
+void SwapOutSpace(gc::space::Space* space);
+
+/* ------------------- debug --------------------- */
+
+std::string GetSpaceFromObject(mirror::Object* obj);
+
+void PrintHeapObjectInformation();
+
+void VisitMemMap(const MemMap* mem_map);
+
+template<size_t kAlignment>
+void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* );
+
+void VisitHeapBitmap(const gc::accounting::HeapBitmap* );
+
+void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set);
+
+void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table);
+
+void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table);
+
+void VisitCardTable(const gc::accounting::CardTable* card_table);
+
+void DebugPrintModUnionAndRememberSet();
+
+
+} // namespace jiacheng
+} // namespace art
+
+
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_hack.cc b/runtime/jiacheng_hack.cc
index 5ed1982c64..1a573d317b 100644
--- a/runtime/jiacheng_hack.cc
+++ b/runtime/jiacheng_hack.cc
@@ -1,96 +1,66 @@
-#include <fstream>
-#include <thread>
-#include <chrono>
-#include <atomic>
 #include <string>
-#include <sys/mman.h>
 
+#include "runtime.h"
+#include "gc/heap.h"
+#include "gc/space/region_space.h"
+#include "gc/collector/garbage_collector.h"
+#include "base/utils.h"
+
+#include <sys/mman.h>
 
 #include "jiacheng_hack.h"
-#include "jiacheng_cold_space.h"
 #include "jiacheng_activity_manager.h"
 #include "jiacheng_utils.h"
 #include "jiacheng_profiler.h"
+#include "jiacheng_swapper.h"
+
 
-#include "gc/accounting/card_table.h"
-#include "gc/space/space-inl.h"
-#include "gc/heap.h"
-#include "gc/space/zygote_space.h"
-#include "gc/space/bump_pointer_space-inl.h"
-#include "gc/space/bump_pointer_space-walk-inl.h"
-#include "gc/space/dlmalloc_space-inl.h"
-#include "gc/space/image_space.h"
-#include "gc/space/large_object_space.h"
-#include "gc/space/malloc_space.h"
-#include "gc/space/region_space-inl.h"
-#include "gc/space/rosalloc_space-inl.h"
-#include "mirror/class-inl.h"
-#include "obj_ptr-inl.h"
-#include "scoped_thread_state_change-inl.h"
-#include "thread_list.h"
-#include "gc/accounting/mod_union_table-inl.h"
-#include "gc/accounting/remembered_set.h"
-#include "base/mutex.h"
 
-#include "read_barrier_config.h"
 
 namespace art{
 namespace jiacheng {
 
 typedef void(*WalkCallback)(void *start, void *end, size_t num_bytes, void* callback_arg);
 
+bool HandleFault(int sig, siginfo_t* info, void* context) {
+    (void)context;
+    if (!IsWhiteApp()) {
+        return false;
+    }
+    LOG(INFO) << " jiacheng fault_handler.cc HandleFault()" 
+            << " sig= " << sig
+            << " info->si_addr= " << reinterpret_cast<mirror::Object*>(info->si_addr)
+            << " info->si_signo= " << info->si_signo
+            << " info->si_errno= " << info->si_errno
+            << " info->si_code= " << info->si_code
+            ;
+    mirror::Object *ref = reinterpret_cast<mirror::Object *>(info->si_addr);
+
+    gc::space::RegionSpace* region_space = Runtime::Current()->GetHeap()->GetRegionSpace();
+    if (region_space->HasAddress(ref)) {
+        region_space->HandleFault(ref);
+        return true;
+    } else {
+        return false;
+    }
+}
+
 // 在App启动的main函数中调用该函数
 void OnAppStart() {
-    Runtime* runtime = Runtime::Current();
-    const std::string& process_package_name = runtime->GetProcessPackageName();
-
-    LOG(INFO) << "jiacheng jiacheng_hack.cc 53" 
-              << " OnAppStart()"
-              << " process_package_name= " << process_package_name
-              ;
-    // 在APP启动时，异步调用
-    auto func = [&]()->void {
-        // ActivityManager* activity_manager = ActivityManager::Current();
-        for (;;) {
-            // if (!activity_manager->GetInGC()) {
-            //     SwapOut();
-            //     LOG(INFO) << "jiacheng jiacheng_hack.cc 144 执行换出!";
-            // }
-
-            gc::Heap* heap = runtime->GetHeap();
-            heap->JiachengDebug();
-
-            CurrentThreadSleepNano(1000000000);
-            CurrentThreadSleepNano(1000000000);
-            CurrentThreadSleepNano(1000000000);
-            CurrentThreadSleepNano(1000000000);
-            CurrentThreadSleepNano(1000000000);
-
-            CurrentThreadSleepNano(1000000000);
-            CurrentThreadSleepNano(1000000000);
-            CurrentThreadSleepNano(1000000000);
-            CurrentThreadSleepNano(1000000000);
-            CurrentThreadSleepNano(1000000000);
-        }
-    };
-    std::thread on_app_start_thread(func);
-    on_app_start_thread.detach();
+    if (!IsWhiteApp()) {
+        return;
+    }
+    LOG(INFO) << "jiacheng jiacheng_hack.cc OnAppStart()"
+              << " package_name= " << GetCurrentPackageName();
+    Profiler* profiler = Profiler::Current();
+    profiler->SetStartTime(art::NanoTime());
+    (void)profiler;
+    
+    Swapper* swapper = Swapper::Current();
+    (void)swapper;
 }
 
-/* 
- * AMS通过在系统启动的时候注册的service调用该函数
- * enum ActivityState {
- *     INITIALIZING, 0
- *     RESUMED, 1
- *     PAUSING, 2
- *     PAUSED, 3 
- *     STOPPING, 4
- *     STOPPED, 5
- *     FINISHING, 6
- *     DESTROYING, 7
- *     DESTROYED 8
- *}
- */
+// AMS通过在系统启动的时候注册的service调用该函数
 void UpdateActivityState(const char* package_name, const char* activity_name, int state) { 
     (void)package_name;
     std::string name(activity_name);
@@ -98,212 +68,99 @@ void UpdateActivityState(const char* package_name, const char* activity_name, in
 }
 
 
-/*
- * 每次GC开始的时候，调用该方法
- */
-void BeforeGarbageCollectorRun(const gc::collector::GarbageCollector* collector) {
-    LOG(INFO) << "jiacheng" << " BeforeGarbageCollectorRun" 
-              << " NanoTime= " << NanoTime()
-              << " GarbageCollector.GetName()= " << collector->GetName()
-              << " GetGcType()= " << collector->GetGcType();
-
-    // ActivityManager* activity_manager = ActivityManager::Current();
-    // (void)activity_manager;
-
-    // Profiler* profiler = Profiler::Current();
-    // profiler->SetDuringGcFlag();
-    // profiler->JiachengDebug();
-    // profiler->ClearReadWorkingSet();
-    // profiler->ClearGcWorkingSet();
-
-}
+void UpdataAppState(ProcessState old_process_state, ProcessState new_process_state) {
+    if (!IsWhiteApp()) {
+        return;
+    }
+    Profiler* profiler = Profiler::Current();
+    uint64_t start_time = profiler->GetStartTime();
+    if (start_time == 0 || art::NanoTime() - start_time < 1000000000) {
+        return;
+    }
 
-/*
- * 每次GC结束的时候，调用该方法
- */
-void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector) {
-    // ActivityManager* activity_manager = ActivityManager::Current();
-    // Debug();
-    // SwapOut();
-    // activity_manager->ForgetWorkingSet();
-    // ColdSpace::Current()->ResetMarkBitmap();
-    const gc::collector::Iteration* iteration = collector->GetCurrentIteration();
-    
-    LOG(INFO) << "jiacheng" << " AfterGarbageCollectorRun" 
-              << " NanoTime= " << NanoTime()
-              << " GcCause= " << iteration->GetGcCause()
-              << " GetGcType= " << collector->GetGcType();
+    std::string package_name = GetCurrentPackageName();
+    LOG(INFO) << "jiacheng jiacheng_hack.cc 111 UpdataAppState() "
+              << " package_name= " << package_name 
+              << " old_process_state= " << old_process_state
+              << " new_process_state= " << new_process_state
+              ;
 
-    // Profiler* profiler = Profiler::Current();
-    // profiler->ClearDuringGcFlag();
-    // profiler->IncreaseGcNumber();
-    // profiler->InitColdSet();
-    // profiler->JiachengDebug();
+    if (new_process_state == kProcessStateJankImperceptible) {
+        profiler->ClearPerceptibleFlag();
+    } else {
+        profiler->SetPerceptibleFlag();
+    }
 
-    // profiler->ClearReadWorkingSet();
-    // profiler->ClearGcWorkingSet();
 }
 
-/*
- * 每次发生读屏障的时候，调用该方法
- */
-
-void ReadBarrierTrigger(mirror::Object* obj) {
-    (void)obj;
-    if (Runtime::Current()->IsZygote()) {
+// 每次GC开始的时候，调用该方法
+void BeforeGarbageCollectorRun(const gc::collector::GarbageCollector* collector) {
+    if (!IsWhiteApp()) {
         return;
     }
-    // if (!Runtime::Current()->InJankPerceptibleProcessState()) {
-    //     return;
-    // }
-
-    // com.jiacheng.activitylifecycletest = 34
-    // com.taobao.taobao = 17
-    // const std::string& package_name = Runtime::Current()->GetProcessPackageName();
-    // if (!(package_name.length() == 17 && package_name[4] == 't')) { 
-    //     return;
-    // }
+    LOG(INFO) << "jiacheng jiacheng_hack.cc 89 BeforeGarbageCollectorRun()" 
+              << " NanoTime= " << NanoTime()
+              << " GarbageCollector.GetName()= " << collector->GetName()
+              << " GetGcType()= " << collector->GetGcType();
 
     Profiler* profiler = Profiler::Current();
-    (void)profiler;
-
-    // profiler->RecordReadWorkingSet(obj);
-    // ActivityManager::Current()->RecordWS(obj);
-
+    profiler->SetDuringGcFlag();
 }
 
-void GCMarkTrigger(mirror::Object* obj) {
-    (void)obj;
-    if (Runtime::Current()->IsZygote()) {
+// 每次GC结束的时候，调用该方法
+void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector) {
+    if (!IsWhiteApp()) {
         return;
     }
-    // if (!Runtime::Current()->InJankPerceptibleProcessState()) {
-    //     return;
-    // }
+    const gc::collector::Iteration* iteration = collector->GetCurrentIteration();
     
-    // com.jiacheng.activitylifecycletest = 34
-    // com.taobao.taobao = 17
-    // const std::string& package_name = Runtime::Current()->GetProcessPackageName();
-    // if (!(package_name.length() == 17 && package_name[4] == 't')) { 
-    //     return;
-    // }
+    LOG(INFO) << "jiacheng jiacheng_hack.cc 106 AfterGarbageCollectorRun()" 
+              << " NanoTime= " << NanoTime()
+              << " GcCause= " << iteration->GetGcCause()
+              << " GetGcType= " << collector->GetGcType();
 
     Profiler* profiler = Profiler::Current();
-    (void)profiler;
-
-    // profiler->RecordGcWorkingSet(obj);
-}
+    profiler->IncreaseGcNumber();
+    profiler->ClearDuringGcFlag();
+    
+    profiler->JiachengDebug();
 
-void Debug() {
-    ColdSpace::Current()->JiachengDebug();
-    ActivityManager::Current()->JiachengDebug();
+    // profiler->ClearAccessWS();
+    profiler->ClearGcWS();
 
-    Runtime* runtime = Runtime::Current();
-    gc::Heap* heap = runtime->GetHeap();
 
-    heap->JiachengDebug();
+    Runtime::Current()->GetHeap()->GetRegionSpace()->InitColdToRegionRememberedSet();
+    // jiacheng debug start
+    Runtime::Current()->GetHeap()->GetRegionSpace()->JiachengDebug();
+    // jiacheng debug end
 }
 
-// 对ColdSpace中的Region进行Swap
-void SwapOut() {
-    if (Runtime::Current()->IsZygote()) {
+// GC访问内存的时候，调用该方法
+// 1. Copy过程的from_ref和to_ref
+// 2. Scan过程
+void GCAccessTrigger(mirror::Object* obj) {
+    if (!obj) {
         return;
     }
-    // if (activity_set.size() < 2 || GC_time.load() < 10) {
-    //     return;
-    // }
-    if (Runtime::Current()->InJankPerceptibleProcessState()) {
+    if (!IsWhiteApp()) {
         return;
     }
-    // com.jiacheng.activitylifecycletest = 34
-    // com.taobao.taobao = 17
-    // const std::string& package_name = Runtime::Current()->GetProcessPackageName();
-    // if (!(package_name.length() == 17 && package_name[4] == 't')) { 
-    //     return;
-    // }
+    Profiler* profiler = Profiler::Current();
+    profiler->RecordGcWS(obj);
+}
 
-    // 对所有Space中的对象进行Swap
-    gc::Heap* heap = Runtime::Current()->GetHeap();
-    Thread* self = Thread::Current();
-    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
-    {
-        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
-        continues_spaces = &(heap->GetContinuousSpaces());
-    }
-    for (auto space : *continues_spaces) {
-        LOG(INFO) << "jiacheng_hack.cc 185 SwapOut() continues_spaces " << space->GetName();
-        madvise(space->Begin(), space->Size(), 233);
-        // SwapOutSpace(space);
-    }
-    const std::vector<gc::space::DiscontinuousSpace*>& discontinues_spaces = heap->GetDiscontinuousSpaces();
-    for (auto space : discontinues_spaces) {
-        SwapOutSpace(space);
-    }    
+void JiachengDebug() {
+    // ActivityManager::Current()->JiachengDebug();
+    LOG(INFO) << "jiacheng jiacheng_hack.cc 177 Debug() "
+              << "CodeGeneratorARM64::MarkGCCard()";
+    // Runtime* runtime = Runtime::Current();
+    // gc::Heap* heap = runtime->GetHeap();
 
-    // 不直接使用SwapOutSpace()函数对所有Space中的对象进行Swap
-    // LOG(INFO) << "jiacheng jiacheng_hack.cc 180 SwapOut()";
-    // ColdSpace* cold_space = ColdSpace::Current();
-    // cold_space->SwapOut();
+
+    // heap->JiachengDebug();
 }
 
 
-void SwapOutSpace(gc::space::Space* space) {
-    Thread* self = Thread::Current();
-    gc::space::SpaceType space_type = space->GetType();
-    
-    WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* ) {
-        // if (start != end && ActivityManager::Current()->ShouldSwapOut(reinterpret_cast<mirror::Object*>(start))) {
-        if (start != end) {
-            LOG(INFO) << "jiacheng_hack.cc 143 ShouldSwapOut() obj= " << size_t(start) << " size= " << size_t(end) - size_t(start);
-            madvise(start, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start), 233);
-        }
-    };    
-    auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_){
-        // if (obj && ActivityManager::Current()->ShouldSwapOut(obj)) {
-        if (obj) {
-            LOG(INFO) << "jiacheng_hack.cc 150 ShouldSwapOut() obj= " << size_t(obj) << " size= " << obj->SizeOf();
-            madvise(static_cast<void *>(obj), obj->SizeOf(), 233);
-        }
-    };
-    switch (space_type) {
-        case gc::space::kSpaceTypeImageSpace: {
-            // gc::space::ImageSpace* this_space = space->AsImageSpace();
-            break;
-        }
-        case gc::space::kSpaceTypeMallocSpace: {
-            gc::space::MallocSpace* this_space = space->AsMallocSpace();
-            this_space->Walk(walk_callback, nullptr);
-            break;
-        }
-        case gc::space::kSpaceTypeZygoteSpace: {
-            // gc::space::ZygoteSpace* this_space = space->AsZygoteSpace();
-            break;
-        }
-        case gc::space::kSpaceTypeBumpPointerSpace: {
-            gc::space::BumpPointerSpace* this_space = space->AsBumpPointerSpace();
-            { 
-                WriterMutexLock mu(self, *Locks::mutator_lock_);  
-                this_space -> Walk(visitor);
-            }
-            break;
-        }
-        case gc::space::kSpaceTypeLargeObjectSpace: {
-            gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
-            this_space->Walk(walk_callback, nullptr);
-            break;
-        }
-        case gc::space::kSpaceTypeRegionSpace: {
-            gc::space::RegionSpace* this_space = space->AsRegionSpace();   
-            {
-                WriterMutexLock mu(self, *Locks::mutator_lock_);  
-                this_space -> Walk(visitor);
-            }
-            break;
-        }
-        default:
-            LOG(INFO) << "jiacheng " << "jiacheng_hack.cc 100. Can not find space.";
-    }
-}
 
 } // namespace jiacheng
 } // namespace art
diff --git a/runtime/jiacheng_hack.h b/runtime/jiacheng_hack.h
index 7737067873..fbe645e66e 100644
--- a/runtime/jiacheng_hack.h
+++ b/runtime/jiacheng_hack.h
@@ -1,70 +1,38 @@
-#ifndef JIACHENG_HACK_H_
-#define JIACHENG_HACK_H_
+#ifndef ART_RUNTIME_JIACHENG_HACK_H_
+#define ART_RUNTIME_JIACHENG_HACK_H_
 
-#include <set>
+#include "process_state.h"
+#include "signal.h"
 
 namespace art{
 
 namespace gc {
-namespace accounting {
-template<size_t kAlignment> class SpaceBitmap;
-class HeapBitmap;
-class RememberedSet;
-class ModUnionTable;
-class CardTable;
-} // namespace accounting
-
-namespace space {
-class Space;
-class ImageSpace;
-class MallocSpace;
-class ZygoteSpace;
-class BumpPointerSpace;
-class LargeObjectSpace;
-class RegionSpace;
-} // namespace space
-
 namespace collector {
 class GarbageCollector;
 } // namespace collector
-
-class Heap;
-
 } // namespace gc
 
 namespace mirror {
-class Class;
 class Object;
-template<class T> class ObjectArray;
-}  // namespace mirror
-
-class Thread;
-class MemMap;
-class MemberOffset;
+} // namespace mirror
 
 namespace jiacheng {
 
-// ---------------- 前端事件 --------------
+bool HandleFault(int sig, siginfo_t* info, void* context);
+
 void OnAppStart();
 
 void UpdateActivityState(const char* package_name, const char* activity_name, int state);
 
-// ---------------- ART事件 --------------
+void UpdataAppState(ProcessState old_process_state, ProcessState new_process_state);
+
 void BeforeGarbageCollectorRun(const gc::collector::GarbageCollector* collector);
 
 void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector);
 
-void ReadBarrierTrigger(mirror::Object* obj);
-
-void GCMarkTrigger(mirror::Object* obj);
-
-// ---------------- 内部调用 --------------
-void Debug();
-
-void SwapOut();
-
-void SwapOutSpace(gc::space::Space* space);
+void GCAccessTrigger(mirror::Object* obj);
 
+void JiachengDebug();
 
 } // namespace jiacheng
 } // namespace art
diff --git a/runtime/jiacheng_profiler.cc b/runtime/jiacheng_profiler.cc
index cddaa2e394..42c2c6cdae 100644
--- a/runtime/jiacheng_profiler.cc
+++ b/runtime/jiacheng_profiler.cc
@@ -1,13 +1,35 @@
 #include "jiacheng_profiler.h"
+#include "jiacheng_utils.h"
+#include "jiacheng_debug.h"
 
 #include "thread-inl.h"
 
 namespace art {
 namespace jiacheng {
 
+
 Mutex Profiler::singleton_lock_("Profiler Singleton Lock", kLoggingLock);
 Profiler* Profiler::instance_(nullptr); 
 
+Profiler::Profiler():
+    access_bloom_filter_(1000000, 1e-4),
+    read_working_set_(),
+    read_working_set_lock_("read_working_set_lock", kJiachengWorkingSetLock),
+    access_working_set_size_(0),
+    gc_bloom_filter_(1000000, 1e-4),
+    gc_working_set_(),
+    gc_working_set_lock_("gc_working_set_lock", kJiachengWorkingSetLock),
+    gc_working_set_size_(0),
+    cold_set_(),
+    cold_set_lock_("cold_set_lock", kJiachengColdSpaceLock),
+    during_gc_flag_(false),
+    perceptible_flag_(true),
+    gc_number_(0),
+    start_time_(0) {
+}
+
+Profiler::~Profiler() = default;
+
 Profiler* Profiler::Create() {
     Profiler* it = new Profiler();
     return it;
@@ -25,70 +47,72 @@ Profiler* Profiler::Current() {
     return instance_;
 }
 
-Profiler::Profiler():
-    read_working_set_(),
-    read_working_set_lock_("read_working_set_lock", kJiachengWorkingSetLock),
-    gc_working_set_(),
-    gc_working_set_lock_("gc_working_set_lock", kJiachengWorkingSetLock),
-    cold_set_(),
-    cold_set_lock_("cold_set_lock", kJiachengColdSpaceLock),
-    during_gc_flag_(false),
-    gc_number_(0) {
-}
-
-Profiler::~Profiler() = default;
-
 void Profiler::JiachengDebug() {
-    Thread* self = Thread::Current();
-
-    gc_working_set_lock_.ExclusiveLock(self);
-    size_t gc_working_set_size = gc_working_set_.size();
-    gc_working_set_lock_.ExclusiveUnlock(self);
-
-    read_working_set_lock_.ExclusiveLock(self);
-    size_t read_working_set_size = read_working_set_.size();
-    read_working_set_lock_.ExclusiveUnlock(self);
-
-    cold_set_lock_.ExclusiveLock(self);
-    size_t cold_set_size = cold_set_.size();
-    cold_set_lock_.ExclusiveUnlock(self);
-
     LOG(INFO) << "jiacheng jiacheng_profiler.cc 39" 
-              << " gc_working_set_.size()= " << gc_working_set_size
-              << " read_working_set_.size()= " << read_working_set_size
-              << " cold_set_.size()= " << cold_set_size
+              << " access_working_set_size= " << access_working_set_size_.load()
+              << " gc_working_set_size_= " << gc_working_set_size_.load()
               << " during_gc_flag_= " << during_gc_flag_.load()
+              << " perceptible_flag_= " << perceptible_flag_.load()
               << " gc_number_= " << gc_number_.load()
+              << std::flush
               ;
 }
 
+void Profiler::RecordAccessWS(mirror::Object* obj) {
+    // Thread* self = Thread::Current();
+    // read_working_set_lock_.ExclusiveLock(self);
+    // read_working_set_.insert(obj);
+    // read_working_set_lock_.ExclusiveUnlock(self);
 
-void Profiler::RecordReadWorkingSet(mirror::Object* obj) {
-    Thread* self = Thread::Current();
-    read_working_set_lock_.ExclusiveLock(self);
-    read_working_set_.insert(obj);
-    read_working_set_lock_.ExclusiveUnlock(self);
+    if (!access_bloom_filter_.Add(reinterpret_cast<uint64_t>(obj))) {
+        access_working_set_size_.fetch_add(1);
+    }
 }
 
-void Profiler::ClearReadWorkingSet() {
-    Thread* self = Thread::Current();
-    read_working_set_lock_.ExclusiveLock(self);
-    read_working_set_.clear();
-    read_working_set_lock_.ExclusiveUnlock(self);
+void Profiler::ClearAccessWS() {
+    // Thread* self = Thread::Current();
+    // read_working_set_lock_.ExclusiveLock(self);
+    // read_working_set_.clear();
+    // read_working_set_lock_.ExclusiveUnlock(self);
+
+    access_bloom_filter_.Clear();
+    access_working_set_size_.store(0);
 }
 
-void Profiler::RecordGcWorkingSet(mirror::Object* obj) {
-    Thread* self = Thread::Current();
-    gc_working_set_lock_.ExclusiveLock(self);
-    gc_working_set_.insert(obj);
-    gc_working_set_lock_.ExclusiveUnlock(self);
+bool Profiler::TestInAccessWS(mirror::Object* obj) {
+    // Thread* self = Thread::Current();
+    // read_working_set_lock_.ExclusiveLock(self);
+    // bool result = (read_working_set_.find(obj) != read_working_set_.end());
+    // read_working_set_lock_.ExclusiveUnlock(self);
+    return access_bloom_filter_.Check(reinterpret_cast<uint64_t>(obj));
 }
 
-void Profiler::ClearGcWorkingSet() {
-    Thread* self = Thread::Current();
-    gc_working_set_lock_.ExclusiveLock(self);
-    gc_working_set_.clear();
-    gc_working_set_lock_.ExclusiveUnlock(self);
+
+void Profiler::RecordGcWS(mirror::Object* obj) {
+    // Thread* self = Thread::Current();
+    // gc_working_set_lock_.ExclusiveLock(self);
+    // gc_working_set_.insert(obj);
+    // gc_working_set_lock_.ExclusiveUnlock(self);
+    if (!gc_bloom_filter_.Add(reinterpret_cast<uint64_t>(obj))) {
+        gc_working_set_size_.fetch_add(1);
+    }
+}
+
+void Profiler::ClearGcWS() {
+    // Thread* self = Thread::Current();
+    // gc_working_set_lock_.ExclusiveLock(self);
+    // gc_working_set_.clear();
+    // gc_working_set_lock_.ExclusiveUnlock(self);
+    gc_bloom_filter_.Clear();
+    gc_working_set_size_.store(0);
+}
+
+bool Profiler::TestInGcWS(mirror::Object* obj) {
+    // Thread* self = Thread::Current();
+    // gc_working_set_lock_.ExclusiveLock(self);
+    // bool result = (gc_working_set_.find(obj) != gc_working_set_.end());
+    // gc_working_set_lock_.ExclusiveUnlock(self);
+    return gc_bloom_filter_.Check(reinterpret_cast<uint64_t>(obj));
 }
 
 void Profiler::SetDuringGcFlag() {
@@ -99,8 +123,35 @@ void Profiler::ClearDuringGcFlag() {
     during_gc_flag_.store(0);
 }
 
-bool Profiler::GetDuringGcFlag() {
-    return during_gc_flag_.load();
+// bool Profiler::GetDuringGcFlag() {
+//     return during_gc_flag_.load();
+// }
+
+void Profiler::SetPerceptibleFlag() {
+    perceptible_flag_.store(1);
+}
+
+void Profiler::ClearPerceptibleFlag() {
+    perceptible_flag_.store(0);
+}
+
+bool Profiler::GetPerceptibleFlag() {
+    return perceptible_flag_.load();
+}
+
+bool Profiler::ShouldSwapOut(mirror::Object* obj) {
+    // jiacheng debug start
+    if(!IsWhiteApp()) {
+        return false;
+    }
+    if (GetPerceptibleFlag()) {
+        return false;
+    }
+    return !TestInAccessWS(obj);
+
+    // (void)obj;
+    // return false;
+    // jiacheng debug end
 }
 
 void Profiler::IncreaseGcNumber() {
@@ -111,38 +162,14 @@ uint32_t Profiler::GetGcNumber() {
     return gc_number_.load();
 }
 
-void Profiler::InitColdSet() {
-    Thread* self = Thread::Current();
-    cold_set_lock_.ExclusiveLock(self);
-    cold_set_.clear();
 
-    // GC工作集 - Read工作集
-    gc_working_set_lock_.ExclusiveLock(self);
-    for (mirror::Object* obj : gc_working_set_) {
-        cold_set_.insert(obj);
-    }
-    gc_working_set_lock_.ExclusiveUnlock(self);
-
-    read_working_set_lock_.ExclusiveLock(self);
-    for (mirror::Object* obj : read_working_set_) {
-        cold_set_.erase(obj);
-    }
-    read_working_set_lock_.ExclusiveUnlock(self);
-    
-    cold_set_lock_.ExclusiveUnlock(self);
+void Profiler::SetStartTime(uint64_t start_time) {
+    start_time_.store(start_time);
 }
 
-bool Profiler::ShouldSwapOut(mirror::Object* obj) {
-    (void)obj;
-    // Thread* self = Thread::Current();
-    // cold_set_lock_.ExclusiveLock(self);
-    // bool res = cold_set_.find(obj) != cold_set_.end();
-    // cold_set_lock_.ExclusiveUnlock(self);
-    // return res;
-    return false;
+uint64_t Profiler::GetStartTime() {
+    return start_time_.load();
 }
-
-
  
 } // namespace jiacheng
 } // namespace art
\ No newline at end of file
diff --git a/runtime/jiacheng_profiler.h b/runtime/jiacheng_profiler.h
index 44076311df..500cbd55c7 100644
--- a/runtime/jiacheng_profiler.h
+++ b/runtime/jiacheng_profiler.h
@@ -7,6 +7,8 @@
 
 #include "base/mutex.h"
 
+#include "jiacheng_bloom_filter.h"
+
 namespace art {
 
 namespace mirror {
@@ -21,6 +23,7 @@ public:
     static Profiler* instance_; 
 
     static Profiler* Create();
+
     static Profiler* Current();
 
     Profiler();
@@ -28,36 +31,47 @@ public:
 
     void JiachengDebug();
 
-    void RecordReadWorkingSet(mirror::Object* obj);
-
-    void ClearReadWorkingSet();
-
-    void RecordGcWorkingSet(mirror::Object* obj);
+    // Mutator的工作集估计
+    void RecordAccessWS(mirror::Object* obj);
+    void ClearAccessWS();
+    bool TestInAccessWS(mirror::Object* obj);
 
-    void ClearGcWorkingSet();
+    // GC的工作集估计
+    void RecordGcWS(mirror::Object* obj);
+    void ClearGcWS();
+    bool TestInGcWS(mirror::Object* obj);
 
     void SetDuringGcFlag();
-
     void ClearDuringGcFlag();
 
-    bool GetDuringGcFlag();
+    bool GetDuringGcFlag() {
+        return during_gc_flag_.load();
+    }
 
-    void IncreaseGcNumber();
+    void SetPerceptibleFlag();
+    void ClearPerceptibleFlag();
+    bool GetPerceptibleFlag();
 
-    uint32_t GetGcNumber();
+    bool ShouldSwapOut(mirror::Object* obj);
 
-    void InitColdSet();
+    void IncreaseGcNumber();
+    uint32_t GetGcNumber();
 
-    bool ShouldSwapOut(mirror::Object* obj);
+    void SetStartTime(uint64_t start_time);
+    uint64_t GetStartTime();
 
 private:
-    // Mutator的Read Working Set
+    // Mutator的Working Set
+    BloomFilter access_bloom_filter_;
     std::set<mirror::Object*> read_working_set_;
     Mutex read_working_set_lock_;
+    std::atomic<uint32_t> access_working_set_size_;
 
-    // GC的Read Working Set
+    // GC的Working Set
+    BloomFilter gc_bloom_filter_;
     std::set<mirror::Object*> gc_working_set_;
     Mutex gc_working_set_lock_;
+    std::atomic<uint32_t> gc_working_set_size_;
 
     // 需要换出去的对象集合Cold Set
     std::set<mirror::Object*> cold_set_;
@@ -66,8 +80,15 @@ private:
     // 每次GC开始的时候设置为true, GC结束的时候设置为false
     std::atomic<bool> during_gc_flag_;
 
+    // APP当前在前台还是后台
+    std::atomic<bool> perceptible_flag_;
+
     // 历史GC发生的总次数
     std::atomic<uint32_t> gc_number_;
+
+    std::atomic<uint64_t> start_time_;
+
+
 };
 
 }
diff --git a/runtime/jiacheng_region.cc b/runtime/jiacheng_region.cc
deleted file mode 100644
index fd954565e8..0000000000
--- a/runtime/jiacheng_region.cc
+++ /dev/null
@@ -1,41 +0,0 @@
-#include "jiacheng_region.h"
-
-namespace art {
-namespace jiacheng {
-
-Region::Region():idx_(-1),begin_(nullptr),top_(nullptr),end_(nullptr) {
-}
-
-Region::~Region() {}
-
-void Region::Init(size_t idx, uint8_t* begin, uint8_t* end) {
-    idx_ = idx;
-    begin_ = begin;
-    top_.store(begin);
-    end_ = end;
-}
-
-mirror::Object* Region::Alloc(size_t num_bytes) {
-    uint8_t* old_top;
-    uint8_t* new_top;
-
-    old_top = top_.load();
-    new_top = old_top + num_bytes;
-    if (new_top > end_) {
-        return nullptr;
-    }
-    top_.store(new_top);
-    return reinterpret_cast<mirror::Object*>(old_top);
-}
-
-void Region::Clear() {
-    top_.store(begin_);
-}
-
-bool Region::IsFree() const {
-    return top_.load() == begin_;
-}
-
-
-} // namespace jiacheng
-} // namespace art
\ No newline at end of file
diff --git a/runtime/jiacheng_region.h b/runtime/jiacheng_region.h
deleted file mode 100644
index fedfb28994..0000000000
--- a/runtime/jiacheng_region.h
+++ /dev/null
@@ -1,59 +0,0 @@
-#ifndef JIACHENG_REGION_H_
-#define JIACHENG_REGION_H_
-
-#include <atomic>
-
-namespace art{
-namespace mirror {
-    class Object;
-}
-
-// ------------ START -------------
-namespace jiacheng {
-
-class Region {
-public:
-    Region();
-    ~Region();
-
-    void Init(size_t idx, uint8_t* begin, uint8_t* end);
-
-    mirror::Object* Alloc(size_t num_bytes);
-
-    void Clear();
-
-    bool IsFree() const;
-
-    size_t Idx() const {
-        return idx_;
-    }
-
-    uint8_t* Begin() const {
-        return begin_;
-    }
-
-    uint8_t* Top() const {
-        return top_.load();
-    }
-
-    uint8_t* End() const {
-        return end_;
-    }
-
-    bool Contains(mirror::Object* ref) const {
-        return begin_ <= reinterpret_cast<uint8_t*>(ref) && reinterpret_cast<uint8_t*>(ref) < end_;
-    }
-
-// ---------------- 变量开始 ----------------------
-
-    size_t idx_;                        // 该Region在ColdSpace中的索引
-    uint8_t* begin_;                    // 这个Region的起始地址
-    std::atomic<uint8_t*> top_;         // Allocation的位置
-    uint8_t* end_;                      // 这个Region的结束地址
-
-};
-
-
-} // namespace jiacheng
-} // namespace art
-#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_swapper.cc b/runtime/jiacheng_swapper.cc
new file mode 100644
index 0000000000..9755a4688c
--- /dev/null
+++ b/runtime/jiacheng_swapper.cc
@@ -0,0 +1,187 @@
+#include "jiacheng_swapper.h"
+
+#include "jiacheng_profiler.h"
+#include "jiacheng_utils.h"
+#include "jiacheng_debug.h"
+
+#include "thread-inl.h"
+#include "runtime.h"
+#include "gc/heap.h"
+#include "gc/space/space-inl.h"
+#include "gc/space/region_space.h"
+#include "gc/space/image_space.h"
+#include "gc/space/malloc_space.h"
+#include "gc/space/zygote_space.h"
+#include "gc/space/bump_pointer_space.h"
+#include "gc/space/large_object_space.h"
+
+namespace art {
+namespace jiacheng {
+
+typedef void(*WalkCallback)(void *start, void *end, size_t num_bytes, void* callback_arg);
+
+Mutex Swapper::singleton_lock_("Swapper Singleton Lock", kLoggingLock);;
+Swapper* Swapper::instance_(nullptr); 
+
+Swapper* Swapper::Create() {
+    Swapper* it = new Swapper();
+    it->Start();
+    return it;
+}
+
+Swapper* Swapper::Current() {
+    if (instance_ == nullptr) {
+        Thread* self = Thread::Current();
+        singleton_lock_.ExclusiveLock(self);
+        if (instance_ == nullptr) {
+            instance_ = Create();
+        }
+        singleton_lock_.ExclusiveUnlock(self);
+    }
+    return instance_;
+}
+
+Swapper::Swapper():swap_thread_(nullptr) {}
+
+Swapper::~Swapper() = default;
+
+
+void Swapper::Run() {
+    Profiler* profiler = Profiler::Current();
+    bool gc_flag, perceptible_flag;
+    while (true) {
+        CurrentThreadSleepSecond(30);
+        gc_flag = profiler->GetDuringGcFlag();
+        perceptible_flag = profiler->GetPerceptibleFlag();
+        LOG(INFO) << "jiacheng jiacheng_swapper.cc 43 Run() swapper thread" 
+                  << " gc_flag= " << gc_flag
+                  << " perceptible_flag= " << perceptible_flag
+                  ;
+        if (!gc_flag && !perceptible_flag) {
+            // jiacheng debug start
+            // SwapOutHeap();
+            // jiacheng debug end
+        }
+        profiler->JiachengDebug();
+        profiler->ClearAccessWS();
+
+        // jiacheng debug start
+        // ClearAndPrintWorkingSet();
+        // jiacheng debug end
+    }
+}
+
+void Swapper::Start() {
+    swap_thread_ = new std::thread(&Swapper::Run, this);
+    swap_thread_->detach();
+}
+
+void Swapper::SwapOutHeap() {
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    Thread* self = Thread::Current();
+    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
+    {
+        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
+        continues_spaces = &(heap->GetContinuousSpaces());
+    }
+    for (gc::space::ContinuousSpace* space : *continues_spaces) {
+        switch (space->GetType()) {
+            case gc::space::kSpaceTypeImageSpace: {
+                gc::space::ImageSpace* this_space = space->AsImageSpace();
+                SwapOutImageSpace(this_space);
+                break;
+            }
+            case gc::space::kSpaceTypeMallocSpace: {
+                gc::space::MallocSpace* this_space = space->AsMallocSpace();
+                SwapOutMallocSpace(this_space);
+                break;
+            }
+            case gc::space::kSpaceTypeZygoteSpace: {
+                gc::space::ZygoteSpace* this_space = space->AsZygoteSpace();
+                SwapOutZygoteSpace(this_space);
+                break;
+            }
+            case gc::space::kSpaceTypeBumpPointerSpace: {
+                gc::space::BumpPointerSpace* this_space = space->AsBumpPointerSpace();
+                SwapOutBumpPointerSpace(this_space);
+                break;
+            }
+            case gc::space::kSpaceTypeLargeObjectSpace: {
+                gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
+                SwapOutLargeObjectSpace(this_space);
+                break;
+            }
+            case gc::space::kSpaceTypeRegionSpace: {
+                gc::space::RegionSpace* this_space = space->AsRegionSpace();   
+                SwapOutRegionSpace(this_space);
+                break;
+            }
+            default: {
+                UNIMPLEMENTED(FATAL) << "Invalid ContinuousSpace !" << *space;
+            }
+        }
+    }
+    const std::vector<gc::space::DiscontinuousSpace*>& discontinues_spaces = heap->GetDiscontinuousSpaces();
+    for (gc::space::DiscontinuousSpace* space : discontinues_spaces) {
+        if(space->IsLargeObjectSpace()) {
+            gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
+            SwapOutLargeObjectSpace(this_space);
+        } else {
+            UNIMPLEMENTED(FATAL) << "Invalid DiscontinuousSpace !" << *space;
+        }
+    }     
+}
+
+void Swapper::SwapOutImageSpace(gc::space::ImageSpace* space) {
+    // LOG(INFO) << "jiacheng jiacheng_swapper.cc 144 SwapOutImageSpace()";
+    (void)space;
+}
+
+void Swapper::SwapOutMallocSpace(gc::space::MallocSpace* space) {
+    (void)space;
+    CHECK(space == Runtime::Current()->GetHeap()->GetNonMovingSpace());
+    LOG(INFO) << "jiacheng jiacheng_swapper.cc 144 SwapOutMallocSpace()";
+    // madvise(space->Begin(), space->Size(), 233);
+    WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* ) {
+        if (start != end) {
+            jiacheng::SwapOutRange(start, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start));
+        }
+    };
+    space->Walk(walk_callback, nullptr);
+}
+
+void Swapper::SwapOutZygoteSpace(gc::space::ZygoteSpace* space) {
+    (void)space;
+    // LOG(INFO) << "jiacheng jiacheng_swapper.cc 144 SwapOutZygoteSpace()";
+    // jiacheng::SwapOutRange(space->Begin(), space->Size());
+}
+
+void Swapper::SwapOutBumpPointerSpace(gc::space::BumpPointerSpace* space ATTRIBUTE_UNUSED) {
+    UNIMPLEMENTED(FATAL);
+}
+
+void Swapper::SwapOutLargeObjectSpace(gc::space::LargeObjectSpace* space) {
+    (void)space;
+    LOG(INFO) << "jiacheng jiacheng_swapper.cc 144 SwapOutLargeObjectSpace()";
+    WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* ) {
+        if (start != end) {
+            // LOG(INFO) << "jiacheng SwapOutLargeObjectSpace() obj= " << size_t(start) << " size= " << size_t(end) - size_t(start);
+            jiacheng::SwapOutRange(start, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start));
+        }
+    };
+    space->Walk(walk_callback, nullptr);
+}
+
+void Swapper::SwapOutRegionSpace(gc::space::RegionSpace* space) {
+    (void)space;
+    LOG(INFO) << "jiacheng jiacheng_swapper.cc 144 SwapOutRegionSpace()";
+    space->SwapOutCold();
+}
+
+
+void Swapper::JiachengDebug() {
+
+}
+
+} // namespace jiacheng
+} // namespace art
diff --git a/runtime/jiacheng_swapper.h b/runtime/jiacheng_swapper.h
new file mode 100644
index 0000000000..b0c88c8067
--- /dev/null
+++ b/runtime/jiacheng_swapper.h
@@ -0,0 +1,61 @@
+#ifndef ART_RUNTIME_JIACHENG_SWAPPER_H_
+#define ART_RUNTIME_JIACHENG_SWAPPER_H_
+
+#include <atomic>
+#include <thread>
+
+#include "base/mutex.h"
+
+namespace art {
+namespace gc {
+namespace space {
+    class ImageSpace;
+    class MallocSpace;
+    class ZygoteSpace;
+    class BumpPointerSpace;
+    class LargeObjectSpace;
+    class RegionSpace;
+}
+}
+
+namespace jiacheng {
+
+class Swapper {
+public:
+    static Mutex singleton_lock_;
+    static Swapper* instance_; 
+
+    static Swapper* Create();
+    static Swapper* Current();
+
+    Swapper();
+    ~Swapper();
+
+    void Start();
+
+    void SwapOutHeap();
+
+    void SwapOutImageSpace(gc::space::ImageSpace* space);
+
+    void SwapOutMallocSpace(gc::space::MallocSpace* space);
+
+    void SwapOutZygoteSpace(gc::space::ZygoteSpace* space);
+
+    void SwapOutBumpPointerSpace(gc::space::BumpPointerSpace* space);
+
+    void SwapOutLargeObjectSpace(gc::space::LargeObjectSpace* space);
+
+    void SwapOutRegionSpace(gc::space::RegionSpace* space);
+
+    void JiachengDebug();
+
+private:
+    [[noreturn]] void Run();
+
+    std::thread* swap_thread_;
+};
+
+} // namespace jiacheng
+} // namespace art
+
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_utils.cc b/runtime/jiacheng_utils.cc
index 796f8293ed..adcde4f3ab 100644
--- a/runtime/jiacheng_utils.cc
+++ b/runtime/jiacheng_utils.cc
@@ -1,46 +1,37 @@
 #include <chrono>
 #include <atomic>
+#include <set>
 #include <thread>
+#include <random>
+#include <fstream>
 
-#include "jiacheng_utils.h"
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/syscall.h>
 
-#include "gc/accounting/card_table.h"
-#include "gc/space/space-inl.h"
-#include "gc/heap.h"
-#include "gc/space/zygote_space.h"
-#include "gc/space/bump_pointer_space-inl.h"
-#include "gc/space/bump_pointer_space-walk-inl.h"
-#include "gc/space/dlmalloc_space-inl.h"
-#include "gc/space/image_space.h"
-#include "gc/space/large_object_space.h"
-#include "gc/space/malloc_space.h"
-#include "gc/space/region_space-inl.h"
-#include "gc/space/rosalloc_space-inl.h"
-#include "mirror/class-inl.h"
-#include "obj_ptr-inl.h"
-#include "scoped_thread_state_change-inl.h"
-#include "thread_list.h"
-#include "gc/accounting/mod_union_table-inl.h"
-#include "gc/accounting/remembered_set.h"
-#include "base/mutex.h"
-#include "read_barrier_config.h"
+#include "base/time_utils.h"
+#include "runtime.h"
 
+#include "jiacheng_utils.h"
+#include "jiacheng_profiler.h"
 
 namespace art {
 namespace jiacheng {
 
-typedef void(*WalkCallback)(void *start, void *end, size_t num_bytes, void* callback_arg);
-    
-void CurrentThreadSleepNano(const unsigned long n) {
+void CurrentThreadSleepNanoSecond(const unsigned long n) {
     std::this_thread::sleep_for(std::chrono::nanoseconds(n));
 }
 
+void CurrentThreadSleepSecond(const unsigned long n) {
+    std::this_thread::sleep_for(std::chrono::seconds(n));
+}
+
 // 防止某个操作过于频繁
-bool CheckHot() {
+bool CheckHot(uint64_t nano) {
     static std::atomic<uint64_t> last_time(0);
     uint64_t get_last_time = last_time.load();
     uint64_t this_time = art::NanoTime();
-    if (this_time - get_last_time < 5000000000) {
+    if (this_time - get_last_time < nano) {
         return true;
     } else {
         last_time.store(this_time);
@@ -48,216 +39,102 @@ bool CheckHot() {
     }
 }
 
-/* ------------------- debug --------------------- */
-
-void VisitSpace(gc::space::Space* space) {
-    gc::space::SpaceType space_type = space->GetType();
-    Thread* self = Thread::Current();
-    WalkCallback walk_callback = [](void *start, void *end, size_t num_bytes, void* ) {
-        LOG(INFO) << "jiacheng " << "start= " << start << ' ' << "end= " << end << ' ' << "num_bytes= " << num_bytes;
-    };    
-    auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_){
-        if (!obj) {
-            LOG(INFO) << "jiacheng Object=Null";
-            return; 
-        }
-        LOG(INFO) << "jiacheng Object= " << obj << " Size= " << obj->SizeOf() << " Type= " << obj->PrettyTypeOf();
-    };
-    switch (space_type) {
-        case gc::space::kSpaceTypeImageSpace: {
-            LOG(INFO) << "jiacheng VisitSpace " << "ImageSpace: ";
-            gc::space::ImageSpace* this_space = space->AsImageSpace();
-            this_space->Dump(LOG_STREAM(INFO));
-            break;
-        }
-        case gc::space::kSpaceTypeMallocSpace: {
-            LOG(INFO) << "jiacheng VisitSpace " << "MallocSpace: ";
-            gc::space::MallocSpace* this_space = space->AsMallocSpace();
-            this_space->Dump(LOG_STREAM(INFO));
-            this_space->Walk(walk_callback, nullptr);
-            break;
-        }
-        case gc::space::kSpaceTypeZygoteSpace: {
-            LOG(INFO) << "jiacheng VisitSpace " << "ZygoteSpace: ";
-            gc::space::ZygoteSpace* this_space = space->AsZygoteSpace();
-            this_space->Dump(LOG_STREAM(INFO));
-            break;
-        }
-        case gc::space::kSpaceTypeBumpPointerSpace: {
-            LOG(INFO) << "jiacheng VisitSpace " << "BumpPointerSpace: ";
-            gc::space::BumpPointerSpace* this_space = space->AsBumpPointerSpace();
-            this_space->Dump(LOG_STREAM(INFO));
-            {
-                ReaderMutexLock mu(self, *Locks::mutator_lock_);   
-                this_space->Walk(visitor);
-            }
-            break;
-        }
-        case gc::space::kSpaceTypeLargeObjectSpace: {
-            LOG(INFO) << "jiacheng VisitSpace " << "LargeObjectSpace: ";
-            gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
-            this_space->Dump(LOG_STREAM(INFO));
-            this_space->Walk(walk_callback, nullptr);
-            break;
-        }
-        case gc::space::kSpaceTypeRegionSpace: {
-            LOG(INFO) << "jiacheng VisitSpace " << "RegionSpace: ";
-            gc::space::RegionSpace* this_space = space->AsRegionSpace();   
-            this_space->Dump(LOG_STREAM(INFO));
-            {
-                WriterMutexLock mu(self, *Locks::mutator_lock_);           
-                this_space->Walk(visitor);
-            }
-            break;
-        }
-        default:
-            LOG(INFO) << "jiacheng " << "jiacheng_hack.cc 100. Can not find space.";
-    }
-}
-
-void VisitHeap(const gc::Heap* heap) {
-    Thread* self = Thread::Current();
-    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
-    {
-        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
-        continues_spaces = &(heap->GetContinuousSpaces());
-    }
-    for (auto space : *continues_spaces) {
-        VisitSpace(space);
-    }
-    const std::vector<gc::space::DiscontinuousSpace*>& discontinues_spaces = heap->GetDiscontinuousSpaces();
-    for (auto space : discontinues_spaces) {
-        VisitSpace(space);
-    }    
-}
-
-
-void VisitMemMap(const MemMap* mem_map) {
-    LOG(INFO) << "jiacheng VisitMemMap ";
-    LOG(INFO) << (*mem_map);
-    uint8_t* begin = mem_map->Begin();
-    uint8_t* end = mem_map->End();
-    void* base_begin = mem_map->BaseBegin();
-    void* base_end = mem_map->BaseEnd();
-    LOG(INFO) << "begin= " << reinterpret_cast<size_t>(begin) << ' '
-              << "end= " << reinterpret_cast<size_t>(end) << ' '
-              << "base_begin= " << reinterpret_cast<size_t>(base_begin) << ' '
-              << "base_end= " << reinterpret_cast<size_t>(base_end);
-    // print every byte
-    // for(uint8_t* p = begin; p != end; ++p) {
-    //     LOG(INFO) << static_cast<int>(*p);
-    // }
-
-}
-
-template<size_t kAlignment>
-void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* ) {
-}
-
-void VisitHeapBitmap(const gc::accounting::HeapBitmap* ) {
+uint32_t GenerateRandomKey() {
+    static std::random_device rd; // obtain a random number from hardware
+    static std::mt19937 gen(rd()); // seed the generator
+    static std::uniform_int_distribution<> distr(0, 1000000000); // define the range
+    return distr(gen);
 }
 
-void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set) {
-    LOG(INFO) << "jiacheng VisitRememberedSet ";
-    auto table = const_cast<gc::accounting::RememberedSet*>(remembered_set);
-    {
-        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
-        table->Dump(LOG_STREAM(INFO));
+// 需要测试的APP: Twitter, Facebook, Youtube, Tiktok, Amazon Shopping,
+//             Google Map, Chrome, Firefox, Angry Bird, Candy Crush Saga
+bool IsWhiteApp() {
+    static std::atomic<int> white(0);
+    static std::set<std::string> white_app_set{
+        "com.twitter.android", 
+        "com.facebook.katana", 
+        "com.google.android.youtube", 
+        "com.zhiliaoapp.musically",
+        "com.amazon.mShop.android.shopping",
+        "com.google.android.apps.maps",
+        "com.android.chrome",
+        "org.mozilla.firefox",
+        "com.rovio.angrybirds",
+        "com.king.candycrushsaga",
+
+        "com.taobao.taobao", 
+        "edu.washington.cs.nl35.memorywaster", 
+        "com.jiacheng.activitylifecycletest",
+
+        "edu.washington.cs.nl35.memorywaster1",
+        "edu.washington.cs.nl35.memorywaster2",
+        "edu.washington.cs.nl35.memorywaster3",
+        "edu.washington.cs.nl35.memorywaster4",
+        "edu.washington.cs.nl35.memorywaster5",
+        "edu.washington.cs.nl35.memorywaster6",
+        "edu.washington.cs.nl35.memorywaster7",
+        "edu.washington.cs.nl35.memorywaster8",
+        "edu.washington.cs.nl35.memorywaster9",
+        "edu.washington.cs.nl35.memorywaster10",
+        "edu.washington.cs.nl35.memorywaster11",
+        "edu.washington.cs.nl35.memorywaster12",
+        "edu.washington.cs.nl35.memorywaster13",
+        "edu.washington.cs.nl35.memorywaster14",
+        "edu.washington.cs.nl35.memorywaster15",
+        "edu.washington.cs.nl35.memorywaster16",
+        "edu.washington.cs.nl35.memorywaster17",
+        "edu.washington.cs.nl35.memorywaster18",
+        "edu.washington.cs.nl35.memorywaster19",
+        "edu.washington.cs.nl35.memorywaster20",
+        "edu.washington.cs.nl35.memorywaster21",
+        "edu.washington.cs.nl35.memorywaster22",
+        "edu.washington.cs.nl35.memorywaster23",
+        "edu.washington.cs.nl35.memorywaster24",
+        "edu.washington.cs.nl35.memorywaster25",
+        "edu.washington.cs.nl35.memorywaster26",
+        "edu.washington.cs.nl35.memorywaster27",
+        "edu.washington.cs.nl35.memorywaster28",
+        "edu.washington.cs.nl35.memorywaster29",
+        "edu.washington.cs.nl35.memorywaster30"
+    };
+    Runtime* runtime = Runtime::Current();
+    if (runtime == nullptr || runtime->IsZygote()) { 
+        return false;
     }
-
-}
-
-void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table) {
-    LOG(INFO) << "jiacheng VisitModUnionTableToZygoteAllocspace ";
-    auto table = const_cast<gc::accounting::ModUnionTableToZygoteAllocspace*>(static_cast<const gc::accounting::ModUnionTableToZygoteAllocspace*>(mod_union_table));
-    {
-        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
-        table->Dump(LOG_STREAM(INFO));
+    if (white.load() == 0) {
+        std::string package_name = GetCurrentPackageName();
+        if (white_app_set.find(package_name) != white_app_set.end()) {
+            white.store(1);
+        } else if ("" != package_name && "zygote" != package_name && "zygote64" != package_name) {
+            white.store(-1);
+        }
     }
+    return white.load() == 1;
 }
 
-void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table) {
-    LOG(INFO) << "jiacheng VisitModUnionTableCardCache ";
-    auto table = const_cast<gc::accounting::ModUnionTableCardCache*>(static_cast<const gc::accounting::ModUnionTableCardCache*>(mod_union_table));
-    {
-        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
-        table->Dump(LOG_STREAM(INFO));
-    }
+void PrintKernel(const std::string& info) {
+    const char *c_info = info.c_str();
+    syscall(435, c_info, info.size() + 1); // SYS_jiacheng_printk = 435
 }
 
-void VisitCardTable(const gc::accounting::CardTable* card_table) {
-    (void)card_table;
-    LOG(INFO) << "jiacheng VisitCardTable ";
-    // MemMap* mem_map = &(card_table->mem_map_);
-    // uint8_t* const biased_begin = card_table->biased_begin_;
-    // const size_t offset = card_table->offset_;
-
-    // VisitMemMap(mem_map);
-    // LOG(INFO) << "biased_begin= " << reinterpret_cast<size_t>(biased_begin);
-    // LOG(INFO) << "offset= " << offset;
+std::string GetCurrentPackageName() {
+    std::ifstream cmdlineFile("/proc/self/cmdline");
+    std::string cmdline;
+    getline(cmdlineFile, cmdline);
+    cmdlineFile.close();
+    return cmdline.substr(0, cmdline.find((char)0));
 }
 
-void DebugPrintModUnionAndRememberSet() {
-    if (Runtime::Current()->IsZygote()) {
-        return;
-    }
-    if (!Runtime::Current()->InJankPerceptibleProcessState()) {
-      LOG(INFO) << "jiacheng " << "InJankPerceptibleProcessState" ;
-      return;
-    }
-    // if (jiacheng::CheckHot()) {
-    //   LOG(INFO) << "jiacheng " << "CheckHot";
-    //   return;
-    // }  
-
-    gc::Heap* heap = Runtime::Current()->GetHeap();
-    VisitHeap(heap);
-
-    Thread* self = Thread::Current();
-    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
-    {
-        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
-        continues_spaces = &(heap->GetContinuousSpaces());
-    }
-    for (auto space : *continues_spaces) {
-        LOG(INFO) << space->GetName();
-        gc::space::SpaceType space_type = space->GetType();
-        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
-        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
-        if (mod_union_table) {
-            LOG(INFO) << "jiacheng mod_union_table";
-            if (space_type == gc::space::kSpaceTypeZygoteSpace) {
-                VisitModUnionTableCardCache(mod_union_table);
-            } else if (space_type == gc::space::kSpaceTypeImageSpace) {
-                VisitModUnionTableToZygoteAllocspace(mod_union_table);
-            }
-        } 
-        if (remembered_set) {
-            LOG(INFO) << "jiacheng remembered_set";
-            VisitRememberedSet(remembered_set);
-        }
-        if (mod_union_table == nullptr && remembered_set == nullptr) {
-            LOG(INFO) << "nullptr";
-        }
-    }
-    const std::vector<gc::space::DiscontinuousSpace*>* discontinues_spaces = &(heap->GetDiscontinuousSpaces());
-    for (auto space : *discontinues_spaces) {
-        LOG(INFO) << space->GetName();
-        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
-        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
-        if (mod_union_table) {
-            LOG(INFO) << "jiacheng mod_union_table";
-        } 
-        if (remembered_set) {
-            LOG(INFO) << "jiacheng remembered_set";
-        }
-        if (mod_union_table == nullptr && remembered_set == nullptr) {
-            LOG(INFO) << "nullptr";
-        }
+bool SwapOutRange(void* start, size_t size) {
+    Profiler* profiler = Profiler::Current();
+    if (profiler->GetDuringGcFlag()) {
+        return false;
     }
+    madvise(start, size, 233);
+    return true;
 }
 
 
 
-}
-}
\ No newline at end of file
+} // namespace jiacheng
+} // namespace art
diff --git a/runtime/jiacheng_utils.h b/runtime/jiacheng_utils.h
index 4ec4ee4653..13287135d8 100644
--- a/runtime/jiacheng_utils.h
+++ b/runtime/jiacheng_utils.h
@@ -1,74 +1,27 @@
 #ifndef ART_RUNTIME_JIACHENG_UTILS_H_
 #define ART_RUNTIME_JIACHENG_UTILS_H_
 
-// 与ART不相关的功能
+#include <string>
 
 namespace art {
-namespace gc {
-namespace accounting {
-template<size_t kAlignment> class SpaceBitmap;
-class HeapBitmap;
-class RememberedSet;
-class ModUnionTable;
-class CardTable;
-} // namespace accounting
-
-namespace space {
-class Space;
-class ImageSpace;
-class MallocSpace;
-class ZygoteSpace;
-class BumpPointerSpace;
-class LargeObjectSpace;
-class RegionSpace;
-} // namespace space
-
-namespace collector {
-class GarbageCollector;
-} // namespace collector
-
-class Heap;
-
-} // namespace gc
-
-namespace mirror {
-class Class;
-class Object;
-template<class T> class ObjectArray;
-}  // namespace mirror
-
-class Thread;
-class MemMap;
-class MemberOffset;
-
 namespace jiacheng {
 
-void CurrentThreadSleepNano(const unsigned long n);
+void CurrentThreadSleepNanoSecond(const unsigned long n);
 
-bool CheckHot();
-
-/* ------------------- debug --------------------- */
-
-void VisitSpace(gc::space::Space* space);
+void CurrentThreadSleepSecond(const unsigned long n);
 
-void VisitHeap(const gc::Heap* heap);
-
-void VisitMemMap(const MemMap* mem_map);
-
-template<size_t kAlignment>
-void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* );
+bool CheckHot();
 
-void VisitHeapBitmap(const gc::accounting::HeapBitmap* );
+uint32_t GenerateRandomKey();
 
-void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set);
+std::string GetCurrentPackageName();
 
-void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table);
+bool IsWhiteApp();
 
-void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table);
+void PrintKernel(const std::string& info);
 
-void VisitCardTable(const gc::accounting::CardTable* card_table);
+bool SwapOutRange(void* start, size_t size);
 
-void DebugPrintModUnionAndRememberSet();
 
 } // namespace jiacheng
 } // namespace art
diff --git a/runtime/jni/java_vm_ext.cc b/runtime/jni/java_vm_ext.cc
index 1bf88c5adc..70071ad480 100644
--- a/runtime/jni/java_vm_ext.cc
+++ b/runtime/jni/java_vm_ext.cc
@@ -1198,6 +1198,7 @@ extern "C" jint JNI_CreateJavaVM(JavaVM** p_vm, JNIEnv** p_env, void* vm_args) {
     options.push_back(std::make_pair(std::string(option->optionString), option->extraInfo));
   }
   bool ignore_unrecognized = args->ignoreUnrecognized;
+
   if (!Runtime::Create(options, ignore_unrecognized)) {
     return JNI_ERR;
   }
diff --git a/runtime/jni/jni_internal.cc b/runtime/jni/jni_internal.cc
index 608cab7916..c44865bef7 100644
--- a/runtime/jni/jni_internal.cc
+++ b/runtime/jni/jni_internal.cc
@@ -266,6 +266,9 @@ static constexpr bool kWarnJniAbort = false;
 template<typename T>
 ALWAYS_INLINE static bool ShouldDenyAccessToMember(T* member, Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
+  // jiacheng start
+  return false;
+  // jiacheng end
   if (IsWhitelistedNativeCaller()) {
     return false;
   }
diff --git a/runtime/mirror/array-inl.h b/runtime/mirror/array-inl.h
index 34925f52e2..b392e41f9a 100644
--- a/runtime/mirror/array-inl.h
+++ b/runtime/mirror/array-inl.h
@@ -99,6 +99,9 @@ inline void PrimitiveArray<T>::SetWithoutChecks(int32_t i, T value) {
   }
   DCHECK(CheckIsValidIndex<kVerifyFlags>(i));
   GetData()[i] = value;
+  // jiacheng start
+  jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+  // jiacheng end
 }
 // Backward copy where elements are of aligned appropriately for T. Count is in T sized units.
 // Copies are guaranteed not to tear when the sizeof T is less-than 64bit.
@@ -184,6 +187,9 @@ inline void PrimitiveArray<T>::Memmove(int32_t dst_pos,
       }
     }
   }
+  // jiacheng start
+  jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+  // jiacheng end
 }
 
 template<class T>
@@ -223,6 +229,9 @@ inline void PrimitiveArray<T>::Memcpy(int32_t dst_pos,
     const uint64_t* s = reinterpret_cast<const uint64_t*>(src_raw);
     ArrayForwardCopy<uint64_t>(d, s, count);
   }
+  // jiacheng start
+  jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+  // jiacheng end
 }
 
 template<typename T, PointerSize kPointerSize, VerifyObjectFlags kVerifyFlags>
diff --git a/runtime/mirror/array.h b/runtime/mirror/array.h
index 1ee4e50df8..00d101ab7f 100644
--- a/runtime/mirror/array.h
+++ b/runtime/mirror/array.h
@@ -32,7 +32,11 @@ namespace mirror {
 
 class MANAGED Array : public Object {
  public:
-  static constexpr size_t kFirstElementOffset = 12u;
+  // jiacheng start
+  // static constexpr size_t kFirstElementOffset = 12u;
+  static constexpr size_t kFirstElementOffset = 12u + 8u;
+  // jiacheng end
+
 
   // The size of a java.lang.Class representing an array.
   static uint32_t ClassSize(PointerSize pointer_size);
@@ -94,24 +98,36 @@ class MANAGED Array : public Object {
 
   void* GetRawData(size_t component_size, int32_t index)
       REQUIRES_SHARED(Locks::mutator_lock_) {
+    // jiacheng start
+    jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+    // jiacheng end
     intptr_t data = reinterpret_cast<intptr_t>(this) + DataOffset(component_size).Int32Value() +
         + (index * component_size);
     return reinterpret_cast<void*>(data);
   }
   template <size_t kComponentSize>
   void* GetRawData(int32_t index) REQUIRES_SHARED(Locks::mutator_lock_) {
+    // jiacheng start
+    jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+    // jiacheng end
     intptr_t data = reinterpret_cast<intptr_t>(this) + DataOffset<kComponentSize>().Int32Value() +
         + (index * kComponentSize);
     return reinterpret_cast<void*>(data);
   }
 
   const void* GetRawData(size_t component_size, int32_t index) const {
+    // jiacheng start
+    jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+    // jiacheng end
     intptr_t data = reinterpret_cast<intptr_t>(this) + DataOffset(component_size).Int32Value() +
         + (index * component_size);
     return reinterpret_cast<void*>(data);
   }
   template <size_t kComponentSize>
   const void* GetRawData(int32_t index) const {
+    // jiacheng start
+    jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+    // jiacheng end
     intptr_t data = reinterpret_cast<intptr_t>(this) + DataOffset<kComponentSize>().Int32Value() +
         + (index * kComponentSize);
     return reinterpret_cast<void*>(data);
diff --git a/runtime/mirror/class.cc b/runtime/mirror/class.cc
index ec07a50b0e..d0a01e63fb 100644
--- a/runtime/mirror/class.cc
+++ b/runtime/mirror/class.cc
@@ -299,7 +299,6 @@ void Class::DumpClass(std::ostream& os, int flags) {
     os << "\n";
     return;
   }
-
   Thread* const self = Thread::Current();
   StackHandleScope<2> hs(self);
   Handle<Class> h_this(hs.NewHandle(this));
diff --git a/runtime/mirror/object-inl.h b/runtime/mirror/object-inl.h
index 2476b135ff..b33b4fd5b5 100644
--- a/runtime/mirror/object-inl.h
+++ b/runtime/mirror/object-inl.h
@@ -602,6 +602,9 @@ template<class T,
          ReadBarrierOption kReadBarrierOption,
          bool kIsVolatile>
 inline T* Object::GetFieldObject(MemberOffset field_offset) {
+  // jiacheng start
+  jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+  // jiacheng end
   Verify<kVerifyFlags>();
   uint8_t* raw_addr = reinterpret_cast<uint8_t*>(this) + field_offset.Int32Value();
   HeapReference<T>* objref_addr = reinterpret_cast<HeapReference<T>*>(raw_addr);
@@ -625,6 +628,10 @@ template<bool kTransactionActive,
 inline void Object::SetFieldObjectWithoutWriteBarrier(MemberOffset field_offset,
                                                       ObjPtr<Object> new_value) {
   VerifyTransaction<kTransactionActive, kCheckTransaction>();
+  // jiacheng start
+  jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+  SetAccess();
+  // jiacheng end
   if (kTransactionActive) {
     ObjPtr<Object> obj;
     if (kIsVolatile) {
diff --git a/runtime/mirror/object.cc b/runtime/mirror/object.cc
index 4afabe2e91..a30b2499e4 100644
--- a/runtime/mirror/object.cc
+++ b/runtime/mirror/object.cc
@@ -300,5 +300,14 @@ std::string Object::PrettyTypeOf() {
   return result;
 }
 
+// jiacheng start
+void Object::SetAccess() {
+  Runtime* runtime = Runtime::Current();
+  if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return;
+  // if (runtime->IsSystemServer()) return;
+  z_zflags1_ = z_zflags1_ | 0x02;
+}
+// jiacheng end
+
 }  // namespace mirror
 }  // namespace art
diff --git a/runtime/mirror/object.h b/runtime/mirror/object.h
index e6e91601d9..37a6596afc 100644
--- a/runtime/mirror/object.h
+++ b/runtime/mirror/object.h
@@ -29,6 +29,10 @@
 #include "runtime_globals.h"
 #include "verify_object.h"
 
+// jiacheng start
+#include "jiacheng_barrier.h"
+// jiacheng end
+
 namespace art {
 
 class ArtField;
@@ -70,7 +74,10 @@ class Throwable;
 static constexpr bool kCheckFieldAssignments = false;
 
 // Size of Object.
-static constexpr uint32_t kObjectHeaderSize = kUseBrooksReadBarrier ? 16 : 8;
+// jiacheng start
+// static constexpr uint32_t kObjectHeaderSize = kUseBrooksReadBarrier ? 16 : 8;
+static constexpr uint32_t kObjectHeaderSize = kUseBrooksReadBarrier ? 24 : 16;
+// jiacheng end
 
 // C++ mirror of java.lang.Object
 class MANAGED LOCKABLE Object {
@@ -90,6 +97,10 @@ class MANAGED LOCKABLE Object {
     return OFFSET_OF_OBJECT_MEMBER(Object, klass_);
   }
 
+  // jiacheng start
+  void SetAccess();
+  // jiacheng end
+
   template<VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags,
            ReadBarrierOption kReadBarrierOption = kWithReadBarrier>
   ALWAYS_INLINE Class* GetClass() REQUIRES_SHARED(Locks::mutator_lock_);
@@ -349,6 +360,9 @@ class MANAGED LOCKABLE Object {
   template<typename kType, bool kIsVolatile>
   ALWAYS_INLINE void SetFieldPrimitive(MemberOffset field_offset, kType new_value)
       REQUIRES_SHARED(Locks::mutator_lock_) {
+    // jiacheng start
+    jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+    // jiacheng end
     uint8_t* raw_addr = reinterpret_cast<uint8_t*>(this) + field_offset.Int32Value();
     kType* addr = reinterpret_cast<kType*>(raw_addr);
     if (kIsVolatile) {
@@ -356,11 +370,18 @@ class MANAGED LOCKABLE Object {
     } else {
       reinterpret_cast<Atomic<kType>*>(addr)->StoreJavaData(new_value);
     }
+    // jiacheng debug start
+    SetAccess();
+    // jiacheng debug end
   }
 
   template<typename kType, bool kIsVolatile>
   ALWAYS_INLINE kType GetFieldPrimitive(MemberOffset field_offset)
       REQUIRES_SHARED(Locks::mutator_lock_) {
+    // jiacheng start
+    jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+    SetAccess();
+    // jiacheng end
     const uint8_t* raw_addr = reinterpret_cast<const uint8_t*>(this) + field_offset.Int32Value();
     const kType* addr = reinterpret_cast<const kType*>(raw_addr);
     if (kIsVolatile) {
@@ -771,6 +792,14 @@ class MANAGED LOCKABLE Object {
   // Monitor and hash code information.
   uint32_t monitor_;
 
+  // jiacheng start
+  uint32_t z_padding_;
+  uint8_t z_zflags0_;
+  uint8_t z_zflags1_;
+  uint8_t z_zflags2_;
+  uint8_t z_zflags3_;
+  // jiacheng end
+
 #ifdef USE_BROOKS_READ_BARRIER
   // Note names use a 'x' prefix and the x_rb_ptr_ is of type int
   // instead of Object to go with the alphabetical/by-type field order
diff --git a/runtime/native/dalvik_system_VMRuntime.cc b/runtime/native/dalvik_system_VMRuntime.cc
index 0557da0b16..45842910f3 100644
--- a/runtime/native/dalvik_system_VMRuntime.cc
+++ b/runtime/native/dalvik_system_VMRuntime.cc
@@ -334,14 +334,12 @@ static void VMRuntime_jiachengUpdateActivityState(JNIEnv* env, jobject,
   (void)package_name;
   (void)activity_name;
   (void)state;
+
+  // TODO: Activity based working set
   // const char* raw_package_name = env->GetStringUTFChars(package_name, nullptr);
   // const char* raw_activity_name = env->GetStringUTFChars(activity_name, nullptr);
   // jiacheng::UpdateActivityState(raw_package_name, raw_activity_name, static_cast<int>(state));
 }
-
-static void VMRuntime_jiachengAppStart(JNIEnv*, jobject) {
-  jiacheng::OnAppStart();
-}
 // jiacheng end
 
 static void VMRuntime_notifyStartupCompleted(JNIEnv*, jobject) {
@@ -676,6 +674,10 @@ static void VMRuntime_registerAppInfo(JNIEnv* env,
   env->ReleaseStringUTFChars(profile_file, raw_profile_file);
 
   Runtime::Current()->RegisterAppInfo(code_paths_vec, profile_file_str);
+
+  // jiacheng start
+  jiacheng::OnAppStart();
+  // jiacheng end
 }
 
 static jboolean VMRuntime_isBootClassPathOnDisk(JNIEnv* env, jclass, jstring java_instruction_set) {
@@ -779,7 +781,6 @@ static JNINativeMethod gMethods[] = {
   NATIVE_METHOD(VMRuntime, updateProcessState, "(I)V"),
   // jiacheng start
   NATIVE_METHOD(VMRuntime, jiachengUpdateActivityState, "(Ljava/lang/String;Ljava/lang/String;I)V"),
-  NATIVE_METHOD(VMRuntime, jiachengAppStart, "()V"),
   // jiacheng end
   NATIVE_METHOD(VMRuntime, startHeapTaskProcessor, "()V"),
   NATIVE_METHOD(VMRuntime, startJitCompilation, "()V"),
diff --git a/runtime/read_barrier-inl.h b/runtime/read_barrier-inl.h
index bbb87098d7..d8d8474791 100644
--- a/runtime/read_barrier-inl.h
+++ b/runtime/read_barrier-inl.h
@@ -75,18 +75,10 @@ inline MirrorType* ReadBarrier::Barrier(
         }
       }
       AssertToSpaceInvariant(obj, offset, ref);
-      // jiacheng start
-      jiacheng::ReadBarrierTrigger(ref);
-      // jiacheng end
       return ref;
     } else if (kUseBrooksReadBarrier) {
       // To be implemented.
-      // jiacheng start
-      MirrorType* ref = ref_addr->template AsMirrorPtr<kIsVolatile>();
-      // return ref_addr->template AsMirrorPtr<kIsVolatile>();
-      jiacheng::ReadBarrierTrigger(ref);
-      return ref;
-      // jiacheng end
+      return ref_addr->template AsMirrorPtr<kIsVolatile>();
     } else if (kUseTableLookupReadBarrier) {
       MirrorType* ref = ref_addr->template AsMirrorPtr<kIsVolatile>();
       MirrorType* old_ref = ref;
@@ -104,9 +96,6 @@ inline MirrorType* ReadBarrier::Barrier(
         }
       }
       AssertToSpaceInvariant(obj, offset, ref);
-      // jiacheng start
-      jiacheng::ReadBarrierTrigger(ref);
-      // jiacheng end
       return ref;
     } else {
       LOG(FATAL) << "Unexpected read barrier type";
@@ -114,12 +103,7 @@ inline MirrorType* ReadBarrier::Barrier(
     }
   } else {
     // No read barrier.
-    // jiacheng start
-    // return ref_addr->template AsMirrorPtr<kIsVolatile>();
-    MirrorType* ref = ref_addr->template AsMirrorPtr<kIsVolatile>();
-    jiacheng::ReadBarrierTrigger(ref);
-    return ref;
-    // jiacheng end
+    return ref_addr->template AsMirrorPtr<kIsVolatile>();
   }
 }
 
@@ -142,15 +126,9 @@ inline MirrorType* ReadBarrier::BarrierForRoot(MirrorType** root,
         ref = reinterpret_cast<MirrorType*>(Mark(ref));
       }
       AssertToSpaceInvariant(gc_root_source, ref);
-      // jiacheng start
-      jiacheng::ReadBarrierTrigger(ref);
-      // jiacheng end
       return ref;
     } else if (kUseBrooksReadBarrier) {
       // To be implemented.
-      // jiacheng start
-      jiacheng::ReadBarrierTrigger(ref);
-      // jiacheng end
       return ref;
     } else if (kUseTableLookupReadBarrier) {
       Thread* self = Thread::Current();
@@ -166,18 +144,12 @@ inline MirrorType* ReadBarrier::BarrierForRoot(MirrorType** root,
         }
       }
       AssertToSpaceInvariant(gc_root_source, ref);
-      // jiacheng start
-      jiacheng::ReadBarrierTrigger(ref);
-      // jiacheng end
       return ref;
     } else {
       LOG(FATAL) << "Unexpected read barrier type";
       UNREACHABLE();
     }
   } else {
-    // jiacheng start
-    jiacheng::ReadBarrierTrigger(ref);
-    // jiacheng end
     return ref;
   }
 }
@@ -195,15 +167,9 @@ inline MirrorType* ReadBarrier::BarrierForRoot(mirror::CompressedReference<Mirro
       ref = reinterpret_cast<MirrorType*>(Mark(ref));
     }
     AssertToSpaceInvariant(gc_root_source, ref);
-    // jiacheng start
-    jiacheng::ReadBarrierTrigger(ref);
-    // jiacheng end
     return ref;
   } else if (with_read_barrier && kUseBrooksReadBarrier) {
     // To be implemented.
-    // jiacheng start
-    jiacheng::ReadBarrierTrigger(ref);
-    // jiacheng end
     return ref;
   } else if (with_read_barrier && kUseTableLookupReadBarrier) {
     Thread* self = Thread::Current();
@@ -221,14 +187,8 @@ inline MirrorType* ReadBarrier::BarrierForRoot(mirror::CompressedReference<Mirro
       }
     }
     AssertToSpaceInvariant(gc_root_source, ref);
-    // jiacheng start
-    jiacheng::ReadBarrierTrigger(ref);
-    // jiacheng end
     return ref;
   } else {
-    // jiacheng start
-    jiacheng::ReadBarrierTrigger(ref);
-    // jiacheng end
     return ref;
   }
 }
-- 
2.34.1


From 06033deb99669ee962f5fdae9f3f4ee1a38f857e Mon Sep 17 00:00:00 2001
From: jiachengh <jiacheng.huang@outlook.com>
Date: Mon, 8 Aug 2022 21:51:44 +0800
Subject: [PATCH 4/7] object header

Change-Id: Id35f5a070aaf7cf80e525050b21f86dfd119bb5e
Signed-off-by: jiachengh <jiacheng.huang@outlook.com>
---
 compiler/optimizing/code_generator_arm64.cc   |  2 +-
 runtime/Android.bp                            |  1 -
 runtime/gc/collector/concurrent_copying-inl.h | 17 +++-
 runtime/gc/collector/concurrent_copying.cc    | 56 ++++++++---
 runtime/gc/heap.cc                            |  1 +
 runtime/gc/space/region_space.cc              | 84 +++++++++--------
 runtime/gc/space/region_space.h               | 12 ++-
 runtime/jiacheng_barrier.cc                   | 27 ++----
 runtime/jiacheng_barrier.h                    |  1 -
 runtime/jiacheng_cheatsheet.cc                | 26 -----
 runtime/jiacheng_cheatsheet.h                 | 26 -----
 runtime/jiacheng_common.h                     | 24 +++++
 runtime/jiacheng_debug.cc                     |  8 +-
 runtime/jiacheng_debug.h                      |  2 +
 runtime/jiacheng_hack.cc                      | 48 +++++++---
 runtime/jiacheng_hack.h                       |  2 +
 runtime/jiacheng_profiler.cc                  | 94 ++++++++++++++++---
 runtime/jiacheng_profiler.h                   | 22 +++++
 runtime/jiacheng_swapper.cc                   | 42 +++++----
 runtime/jiacheng_swapper.h                    |  2 +
 runtime/jiacheng_utils.cc                     |  2 +-
 runtime/jiacheng_utils.h                      |  1 -
 runtime/mirror/object-inl.h                   |  1 -
 runtime/mirror/object-refvisitor-inl.h        |  3 +
 runtime/mirror/object.cc                      | 48 +++++++++-
 runtime/mirror/object.h                       | 25 +++--
 26 files changed, 378 insertions(+), 199 deletions(-)
 delete mode 100644 runtime/jiacheng_cheatsheet.cc
 delete mode 100644 runtime/jiacheng_cheatsheet.h
 create mode 100644 runtime/jiacheng_common.h

diff --git a/compiler/optimizing/code_generator_arm64.cc b/compiler/optimizing/code_generator_arm64.cc
index 99287cf900..96ff9eeee4 100644
--- a/compiler/optimizing/code_generator_arm64.cc
+++ b/compiler/optimizing/code_generator_arm64.cc
@@ -1870,7 +1870,7 @@ void LocationsBuilderARM64::HandleFieldGet(HInstruction* instruction,
 
   bool object_field_get_with_read_barrier =
       kEmitCompilerReadBarrier && (instruction->GetType() == DataType::Type::kReference);
-  // jiacheng start
+  // 
   // LocationSummary* locations =
   //     new (GetGraph()->GetAllocator()) LocationSummary(instruction,
   //                                                      object_field_get_with_read_barrier
diff --git a/runtime/Android.bp b/runtime/Android.bp
index 847cd4e90d..d47d9ad609 100644
--- a/runtime/Android.bp
+++ b/runtime/Android.bp
@@ -106,7 +106,6 @@ libart_cc_defaults {
         "interpreter/unstarted_runtime.cc",
         "java_frame_root_info.cc",
 // jiacheng start ------------------------------------
-        "jiacheng_cheatsheet.cc",
         "jiacheng_hack.cc",
         "jiacheng_activity_manager.cc",
         "jiacheng_utils.cc",
diff --git a/runtime/gc/collector/concurrent_copying-inl.h b/runtime/gc/collector/concurrent_copying-inl.h
index c50a1a057c..691ffb1d88 100644
--- a/runtime/gc/collector/concurrent_copying-inl.h
+++ b/runtime/gc/collector/concurrent_copying-inl.h
@@ -181,10 +181,10 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
           to_ref = Copy(self, from_ref, holder, offset);
         }
         // jiacheng start
-        jiacheng::Profiler* profiler = jiacheng::Profiler::Current();
-        if (to_ref != from_ref && profiler->TestInAccessWS(from_ref)) {
-          profiler->RecordAccessWS(to_ref);
-        }
+        // jiacheng::Profiler* profiler = jiacheng::Profiler::Current();
+        // if (to_ref != from_ref && profiler->TestInAccessWS(from_ref)) {
+        //   profiler->RecordAccessWS(to_ref);
+        // }
         // jiacheng end
         // The copy should either be in a to-space region, or in the
         // non-moving space, if it could not fit in a to-space region.
@@ -209,6 +209,15 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
       case space::RegionSpace::RegionType::kRegionTypeColdSpace: {
         return MarkColdSpaceRegion(self, from_ref, region_space_bitmap_);
       }
+      case space::RegionSpace::RegionType::kRegionTypeHotSpace: {
+        if (kNoUnEvac && use_generational_cc_ && !region_space_->IsLargeObject(from_ref)) {
+          if (!kFromGCThread) {
+            DCHECK(IsMarkedInUnevacFromSpace(from_ref)) << "Returning unmarked object to mutator";
+          }
+          return from_ref;
+        }
+        return MarkUnevacFromSpaceRegion(self, from_ref, region_space_bitmap_);
+      }
       // jiacheng end
       default:
         // The reference is in an unused region. Remove memory protection from
diff --git a/runtime/gc/collector/concurrent_copying.cc b/runtime/gc/collector/concurrent_copying.cc
index b9d5ff1824..11ced05e50 100644
--- a/runtime/gc/collector/concurrent_copying.cc
+++ b/runtime/gc/collector/concurrent_copying.cc
@@ -97,7 +97,7 @@ class ConcurrentCopying::RegionRememberedObjectsAsRootVisitor {
   explicit RegionRememberedObjectsAsRootVisitor(ConcurrentCopying* cc) : collector_(cc) {}
 
   ALWAYS_INLINE mirror::Object* operator()(mirror::Object* ref) const REQUIRES_SHARED(Locks::mutator_lock_) {
-    LOG(INFO) << "jiacheng concurrent_copying.cc 1279 ref= " << size_t(ref);
+    // LOG(INFO) << "jiacheng concurrent_copying.cc 100 ref= " << size_t(ref);
     return collector_->MarkObject(ref);
   }
 
@@ -782,6 +782,9 @@ void ConcurrentCopying::VerifyNoMissingCardMarks() {
 
 // Switch threads that from from-space to to-space refs. Forward/mark the thread roots.
 void ConcurrentCopying::FlipThreadRoots() {
+  // jiacheng start
+  LOG(INFO) << "jiacheng debug concurrent_copying.cc 786 FlipThreadRoots()";
+  // jiacehng end
   TimingLogger::ScopedTiming split("FlipThreadRoots", GetTimings());
   if (kVerboseMode || heap_->dump_region_info_before_gc_) {
     LOG(INFO) << "time=" << region_space_->Time();
@@ -837,6 +840,9 @@ class ConcurrentCopying::GrayImmuneObjectVisitor {
 };
 
 void ConcurrentCopying::GrayAllDirtyImmuneObjects() {
+  // jiacheng start
+  LOG(INFO) << "jiacheng debug concurrent_copying.cc 841 GrayAllDirtyImmuneObjects()";
+  // jiacehng end
   TimingLogger::ScopedTiming split("GrayAllDirtyImmuneObjects", GetTimings());
   accounting::CardTable* const card_table = heap_->GetCardTable();
   Thread* const self = Thread::Current();
@@ -1161,9 +1167,17 @@ class ConcurrentCopying::ComputeLiveBytesAndMarkRefFieldsVisitor {
 };
 
 void ConcurrentCopying::AddLiveBytesAndScanRef(mirror::Object* ref) {
-  DCHECK(ref != nullptr);
-  DCHECK(!immune_spaces_.ContainsObject(ref));
-  DCHECK(TestMarkBitmapForRef(ref));
+  // jiacheng start
+  // DCHECK(ref != nullptr);
+  // DCHECK(!immune_spaces_.ContainsObject(ref));
+  // DCHECK(TestMarkBitmapForRef(ref));
+  CHECK(ref != nullptr);
+  CHECK(!immune_spaces_.ContainsObject(ref));
+  CHECK(TestMarkBitmapForRef(ref));
+  if (reinterpret_cast<size_t>(ref) < 0xffff) {
+    return;
+  }
+  // jiacheng end
   size_t obj_region_idx = static_cast<size_t>(-1);
   if (LIKELY(region_space_->HasAddress(ref))) {
     obj_region_idx = region_space_->RegionIdxForRefUnchecked(ref);
@@ -1362,6 +1376,9 @@ class ConcurrentCopying::ImmuneSpaceCaptureRefsVisitor {
 */
 
 void ConcurrentCopying::MarkingPhase() {
+  // jiacheng start
+  LOG(INFO) << "jiacheng debug concurrent_copying.cc 1374 MarkingPhase()";
+  // jiacheng end
   TimingLogger::ScopedTiming split("MarkingPhase", GetTimings());
   if (kVerboseMode) {
     LOG(INFO) << "GC MarkingPhase";
@@ -1447,6 +1464,9 @@ void ConcurrentCopying::ScanDirtyObject(mirror::Object* obj) {
 
 // Concurrently mark roots that are guarded by read barriers and process the mark stack.
 void ConcurrentCopying::CopyingPhase() {
+  // jiacheng start
+  LOG(INFO) << "jiacheng debug concurrent_copying.cc 1468 CopyingPhase()";
+  // jiacheng end
   TimingLogger::ScopedTiming split("CopyingPhase", GetTimings());
   if (kVerboseMode) {
     LOG(INFO) << "GC CopyingPhase";
@@ -1557,6 +1577,17 @@ void ConcurrentCopying::CopyingPhase() {
       LOG(INFO) << "GC end of ScanCardsForSpace";
     }
   }
+  // jiacheng start
+  {
+    LOG(INFO) << "jiacheng concurrent_copying.cc 1570";
+    RegionRememberedObjectsAsRootVisitor root_visitor(this);
+    region_space_->VisitRememberedObjectsAsRoot(root_visitor);
+    // TODO remove
+    RegionRememberedObjectsVisitor visitor(this);
+    region_space_->VisitRememberedObjects(visitor);
+  }
+  // jiacheng end
+
   {
     // For a sticky-bit collection, this phase needs to be after the card scanning since the
     // mutator may read an unevac space object out of an image object. If the image object is no
@@ -2676,6 +2707,9 @@ void ConcurrentCopying::CaptureRssAtPeak() {
 }
 
 void ConcurrentCopying::ReclaimPhase() {
+  // jiacheng start
+  LOG(INFO) << "jiacheng debug concurrent_copying.cc 2711 ReclaimPhase()";
+  // jiacheng end
   TimingLogger::ScopedTiming split("ReclaimPhase", GetTimings());
   if (kVerboseMode) {
     LOG(INFO) << "GC ReclaimPhase";
@@ -3179,9 +3213,9 @@ template <bool kNoUnEvac>
 inline void ConcurrentCopying::Scan(mirror::Object* to_ref) {
   // jiacheng start 
   // 除了Scan还有很多其他地方对to_ref进行访问，例如检查barrier state
-  // if(region_space_->IsInColdSpace(to_ref)) {
-  //   return;
-  // }
+  if(region_space_->IsInColdSpace(to_ref)) {
+    return;
+  }
   if (!region_space_->IsInColdSpace(to_ref)) {
     jiacheng::GCAccessTrigger(to_ref);
   }
@@ -3529,11 +3563,6 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
          reinterpret_cast<const uint8_t*>(from_ref) + kObjectHeaderSize,
          obj_size - kObjectHeaderSize);
   // jiacheng start
-  // if (jiacheng::IsWhiteApp()) {
-  //   LOG(INFO) << "jiacheng ConcurrentCopying::Copy()"
-  //             << " from_ref= " << reinterpret_cast<size_t>(from_ref)
-  //             << " to_ref= " << reinterpret_cast<size_t>(to_ref);
-  // }
   jiacheng::GCAccessTrigger(to_ref);
   jiacheng::GCAccessTrigger(from_ref);
   // jiacheng end
@@ -3796,6 +3825,9 @@ mirror::Object* ConcurrentCopying::MarkNonMoving(Thread* const self,
 }
 
 void ConcurrentCopying::FinishPhase() {
+  // jiacheng start
+  LOG(INFO) << "jiacheng debug concurrent_copying.cc 3829 FinishPhase()";
+  // jiacheng end
   Thread* const self = Thread::Current();
   {
     MutexLock mu(self, mark_stack_lock_);
diff --git a/runtime/gc/heap.cc b/runtime/gc/heap.cc
index aee8c26560..0d9a2a4e9c 100644
--- a/runtime/gc/heap.cc
+++ b/runtime/gc/heap.cc
@@ -998,6 +998,7 @@ void Heap::ThreadFlipEnd(Thread* self) {
 
 void Heap::UpdateProcessState(ProcessState old_process_state, ProcessState new_process_state) {
   // jiacheng start
+  jiacheng::Profiler::Current()->SetSwitchingFlag();
   jiacheng::UpdataAppState(old_process_state, new_process_state);
   // jiacheng end
   
diff --git a/runtime/gc/space/region_space.cc b/runtime/gc/space/region_space.cc
index 181da36282..c8d97b77da 100644
--- a/runtime/gc/space/region_space.cc
+++ b/runtime/gc/space/region_space.cc
@@ -340,11 +340,11 @@ void RegionSpace::SetFromSpace(accounting::ReadBarrierTable* rb_table,
                                EvacMode evac_mode,
                                bool clear_live_bytes) {
   // jiacheng start
-  if (jiacheng::IsWhiteApp()) {
-    LOG(INFO) << "jiacheng region_space.cc 343 RegionSpace::SetFromSpace()"
-              << " evac_mode= " << evac_mode
-              << " clear_live_bytes= " << clear_live_bytes;
-  }
+  // if (jiacheng::IsWhiteApp()) {
+  //   LOG(INFO) << "jiacheng region_space.cc 343 RegionSpace::SetFromSpace()"
+  //             << " evac_mode= " << evac_mode
+  //             << " clear_live_bytes= " << clear_live_bytes;
+  // }
   // jiacheng end
   
   // Live bytes are only preserved (i.e. not cleared) during sticky-bit CC collections.
@@ -394,12 +394,12 @@ void RegionSpace::SetFromSpace(accounting::ReadBarrierTable* rb_table,
           r->SetAsFromSpace();
 
           // jiacheng start
-          if (jiacheng::IsWhiteApp()) {
-            LOG(INFO) << "jiacheng region_space.cc 393 RegionSpace::SetFromSpace() SetAsFromSpace()"
-                      << " r->IsNewlyAllocated()= " << r->IsNewlyAllocated()
-                      << " evac_mode= " << evac_mode
-                      << " region_index= " << r->Idx();
-          }
+          // if (jiacheng::IsWhiteApp()) {
+          //   LOG(INFO) << "jiacheng region_space.cc 393 RegionSpace::SetFromSpace() SetAsFromSpace()"
+          //             << " r->IsNewlyAllocated()= " << r->IsNewlyAllocated()
+          //             << " evac_mode= " << evac_mode
+          //             << " region_index= Region[" << r->Idx() << ']';
+          // }
           // jiacheng end
 
           DCHECK(r->IsInFromSpace());
@@ -1050,12 +1050,12 @@ size_t RegionSpace::AllocationSizeNonvirtual(mirror::Object* obj, size_t* usable
 
 void RegionSpace::Region::Clear(bool zero_and_release_pages) {
   // jiacheng start
-  if (jiacheng::IsWhiteApp()) {
-    LOG(INFO) << "jiacheng region_space.cc 1047 Region::Clear()"
-              << " zero_and_release_pages= " << zero_and_release_pages
-              << " region_index= " << idx_
-              << " region_type= " << type_;
-  }
+  // if (jiacheng::IsWhiteApp()) {
+  //   LOG(INFO) << "jiacheng region_space.cc 1047 Region::Clear()"
+  //             << " zero_and_release_pages= " << zero_and_release_pages
+  //             << " region_index= Region[" << Idx() << ']'
+  //             << " region_type= " << type_;
+  // }
   // jiacheng end
 
   top_.store(begin_, std::memory_order_relaxed);
@@ -1108,11 +1108,11 @@ RegionSpace::Region* RegionSpace::AllocateRegion(bool for_evac) {
         cyclic_alloc_region_index_ = (region_index + 1) % num_regions_;
       }
       // jiacheng start
-      if (jiacheng::IsWhiteApp()) {
-        LOG(INFO) << "jiacheng region_space.cc 1083 RegionSpace::AllocateRegion() "
-                  << " for_evac= " << for_evac
-                  << " region_index= " << region_index;
-      }
+      // if (jiacheng::IsWhiteApp()) {
+      //   LOG(INFO) << "jiacheng region_space.cc 1083 RegionSpace::AllocateRegion() "
+      //             << " for_evac= " << for_evac
+      //             << " region_index= Region[" << r->Idx() << ']';
+      // }
       // jiacheng end
       return r;
     }
@@ -1255,17 +1255,20 @@ void RegionSpace::Region::InitRememberedSet() {
 
 
 void RegionSpace::Region::WriteBackRememberedSet() {
-  remembered_set_.clear();
   if (IsFree()) {
     return;
   }
   CHECK(!IsLarge() && !IsLargeTail());
+  // jiacheng start
+  LOG(INFO) << "jiacheng debug region_space.cc 1264 WriteBackRememberedSet()";
+  // jiacheng end
   ColdWriteBackRefVisitor ref_visitor(this);
   auto obj_visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_) {
     obj->VisitReferences<true, kVerifyNone, kWithoutReadBarrier>(ref_visitor, ref_visitor);
   };
   space::RegionSpace* region_space = art::Runtime::Current()->GetHeap()->GetRegionSpace();
   region_space->WalkNonLargeRegion(obj_visitor, this);
+  remembered_set_.clear();
 }
 
 
@@ -1309,41 +1312,44 @@ void RegionSpace::JiachengDebug() {
     // for (auto it : *remembered_set) {
     //   ss << " key= " << it.first << " value= " << it.second;
     // }
-    r->Dump(ss);
+    // r->Dump(ss);
     LOG(INFO) << ss.str();
   }
 }
 
 uint32_t RegionSpace::SwapOutCold() {
-  LOG(INFO) << "jiacheng region_space.cc 1283 RegionSpace::SwapOutCold()";
-  uint64_t num_regions = 0;
+  size_t swap_out_num = 0;
   uint8_t* begin, * end;
   size_t swap_out_length;
   MutexLock mu(Thread::Current(), region_lock_);
   for (size_t i = 0; i < std::min(num_regions_, non_free_region_index_limit_); ++i) {
     Region* r = &regions_[i];
-    if (r->IsInColdToSpace()) {
+    if (r->IsInColdToSpace() || r->IsInColdSpace()) {
       begin = r->Begin();
-      end = r->Top();
       // end = r->End();
+      end = r->Top();
       swap_out_length = std::distance(begin, end);
       jiacheng::SwapOutRange(begin, swap_out_length);
       // 防止重新换入
-      CheckedCall(mprotect, __FUNCTION__, begin, swap_out_length, PROT_NONE);
-      ++num_regions;
+      CheckedCall(mprotect, __FUNCTION__, begin, swap_out_length, PROT_READ);
+      ++swap_out_num;
     }
   }
-  return num_regions * kRegionSize;
+  LOG(INFO) << "jiacheng region_space.cc 1336 RegionSpace::SwapOutCold() num_regions= " << swap_out_num;
+  return swap_out_num * kRegionSize;
 }
 
-void RegionSpace::HandleFault(mirror::Object* ref) {
+bool RegionSpace::HandleFault(mirror::Object* ref) {
   Region* r = RefToRegionUnlocked(ref);
+  // if (r->IsInColdSpace() || r->IsInColdToSpace()) {
   uint8_t* begin = r->Begin();
   // uint8_t* end = r->Top();
   uint8_t* end = r->End();
   size_t length = std::distance(begin, end);
-  // CheckedCall(mprotect, __FUNCTION__, begin, length, PROT_READ | PROT_WRITE);
-  if (mprotect(begin, length, PROT_READ | PROT_WRITE) == 0) {
+  if (mprotect(begin, length, PROT_READ | PROT_WRITE) == 0) { // maybe STW
+    // change cold region to normal region
+    r->SetAsToSpace();
+    // r->WriteBackRememberedSet(); 
     LOG(INFO) << "jiacheng region_space.cc 1324 HandleFault() set PROT_READ | PROT_WRITE"
               << " ref= " << ref
               << " begin= " << reinterpret_cast<mirror::Object*>(begin)
@@ -1351,7 +1357,7 @@ void RegionSpace::HandleFault(mirror::Object* ref) {
               << " length= " << length
               << " Success!"
               ;
-
+    return true;
   } else {
     LOG(INFO) << "jiacheng region_space.cc 1324 HandleFault() set PROT_READ | PROT_WRITE"
               << " ref= " << ref
@@ -1361,9 +1367,10 @@ void RegionSpace::HandleFault(mirror::Object* ref) {
               << " errno= " << errno
               << " fail!"
               ;
+    return false;
   }
-
-
+  // }
+  // return false;
 }
 
 
@@ -1385,7 +1392,8 @@ RegionSpace::Region* RegionSpace::AllocateColdRegion() {
         // following the one that was just allocated.
         cyclic_alloc_region_index_ = (region_index + 1) % num_regions_;
       }
-      LOG(INFO) << "jiacheng region_space.cc 1322 RegionSpace::AllocateColdRegion() region_index= " << region_index;
+      // LOG(INFO) << "jiacheng region_space.cc 1322 RegionSpace::AllocateColdRegion()"
+      //           << " region_index= Region[" << r->Idx() << ']';
       return r;
     }
   }
diff --git a/runtime/gc/space/region_space.h b/runtime/gc/space/region_space.h
index 13ed05d927..9f5d99eefa 100644
--- a/runtime/gc/space/region_space.h
+++ b/runtime/gc/space/region_space.h
@@ -156,6 +156,7 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
     // jiacheng start
     kRegionTypeColdSpace,
     kRegionTypeColdToSpace,
+    kRegionTypeHotSpace,
     // jiacheng end
     kRegionTypeNone,             // None.
   };
@@ -545,6 +546,10 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
     bool IsInColdToSpace() const {
       return type_ == RegionType::kRegionTypeColdToSpace;
     }
+
+    bool IsInHotSpace() const {
+      return type_ == RegionType::kRegionTypeHotSpace;
+    }
     // jiacheng end
 
     bool IsInNoSpace() const {
@@ -586,6 +591,11 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
     }
 
     // jiacheng start
+    void SetAsToSpace() {
+      is_newly_allocated_ = false;
+      type_ = RegionType::kRegionTypeToSpace;
+    }
+
     void SetAsColdSpace() {
       is_newly_allocated_ = false;
       type_ = RegionType::kRegionTypeColdSpace;
@@ -817,7 +827,7 @@ public:
 
   uint32_t SwapOutCold() REQUIRES(!region_lock_);
 
-  void HandleFault(mirror::Object* ref) REQUIRES(!region_lock_);
+  bool HandleFault(mirror::Object* ref) REQUIRES(!region_lock_);
 
   Region* AllocateColdRegion() REQUIRES(region_lock_);
 
diff --git a/runtime/jiacheng_barrier.cc b/runtime/jiacheng_barrier.cc
index 4f518bbb6d..8d544d9ff5 100644
--- a/runtime/jiacheng_barrier.cc
+++ b/runtime/jiacheng_barrier.cc
@@ -16,25 +16,18 @@ void JiachengBarrier(uint64_t obj) {
         return;
     }
     Profiler* profiler = Profiler::Current();
-    if (profiler->GetPerceptibleFlag()) {
-        return;
-    }
-
-    // jiacheng debug start
-
-    // static size_t cnt = 0;
-    // cnt += 1;
-    // if (cnt % 100 == 0) {
-    //     LOG(INFO) << "jiacheng JiachengBarrier() " << "obj= " << obj;
-    //     cnt = 0;
-    // }
+    mirror::Object* object = reinterpret_cast<mirror::Object*>(obj);
 
-    // jiacheng debug end
-    
     if (!profiler->GetDuringGcFlag()) {
-        profiler->RecordAccessWS(reinterpret_cast<mirror::Object *>(obj));
-    } else {
-        // profiler->RecordGcWS(reinterpret_cast<mirror::Object *>(obj));
+        uint16_t current_time = profiler->GetCurrentTime();
+        if (profiler->GetPerceptibleFlag()) { // foreground
+            object->SetForegroundAccessRecord(current_time);
+        } else {  // background
+            object->SetBackgroundAccessRecord(current_time);
+        }
+        if (profiler->GetSwitchingFlag() && object->GetSwitchAccessRecord()==0) {
+            object->SetSwitchAccessRecord(current_time);
+        }
     }
 }
 
diff --git a/runtime/jiacheng_barrier.h b/runtime/jiacheng_barrier.h
index 5cbf1a372d..f9250c6c3b 100644
--- a/runtime/jiacheng_barrier.h
+++ b/runtime/jiacheng_barrier.h
@@ -6,7 +6,6 @@
 namespace art {
 namespace jiacheng {
 
-// void JiachengBarrier(uint64_t obj) REQUIRES_SHARED(Locks::mutator_lock_);
 void JiachengBarrier(uint64_t obj);
 
 
diff --git a/runtime/jiacheng_cheatsheet.cc b/runtime/jiacheng_cheatsheet.cc
deleted file mode 100644
index 0bcf1547ac..0000000000
--- a/runtime/jiacheng_cheatsheet.cc
+++ /dev/null
@@ -1,26 +0,0 @@
-// #include "jiacheng_cheatsheet.h"
-
-
-// namespace art {
-// namespace jiacheng {
-
-
-// void CheatSheet::AddRememberedSet(uint8_t *obj) {
-//     remembered_set_.insert(obj);
-// }
-
-// void CheatSheet::AddColdSet(uint8_t *obj) {
-//     cold_set_.insert(obj);
-// }
-
-// bool CheatSheet::InRememberedSet(uint8_t *obj) {
-//     return remembered_set_.find(obj) != remembered_set_.end();
-// }
-
-// bool CheatSheet::InColdSet(uint8_t *obj) {
-//     return cold_set_.find(obj) != cold_set_.end();
-// }
-
-
-// }
-// }
\ No newline at end of file
diff --git a/runtime/jiacheng_cheatsheet.h b/runtime/jiacheng_cheatsheet.h
deleted file mode 100644
index 9df19d195c..0000000000
--- a/runtime/jiacheng_cheatsheet.h
+++ /dev/null
@@ -1,26 +0,0 @@
-// #ifndef ART_RUNTIME_JIACHENG_CHEATSHEET_H_
-// #define ART_RUNTIME_JIACHENG_CHEATSHEET_H_
-
-// #include <set>
-
-// namespace art {
-// namespace jiacheng {
-
-// class CheatSheet {
-// public:
-//     CheatSheet();
-//     ~CheatSheet();
-
-//     void AddRememberedSet(uint8_t *obj);
-//     void AddColdSet(uint8_t *obj);
-
-//     bool InRememberedSet(uint8_t *obj);
-//     bool InColdSet(uint8_t * obj);
-
-//     std::map<uint8_t*, uint32_t> remembered_set_;
-// };
-
-// }
-// }
-
-// #endif
\ No newline at end of file
diff --git a/runtime/jiacheng_common.h b/runtime/jiacheng_common.h
new file mode 100644
index 0000000000..03a8025344
--- /dev/null
+++ b/runtime/jiacheng_common.h
@@ -0,0 +1,24 @@
+#ifndef ART_RUNTIME_JIACHENG_COMMON_H_
+#define ART_RUNTIME_JIACHENG_COMMON_H_
+
+#include "base/mutex.h"
+
+namespace art {
+namespace jiacheng {
+
+constexpr uint32_t CLOCK_TICK = 5; // second
+constexpr uint32_t SWITCHING_WINDOW_SIZE = 1; // Ticks
+constexpr uint32_t SWAPOUT_WINDOW_SIZE = 6; // Ticks
+
+constexpr uint32_t FOREGROUND_WS_WINDOW_SIZE = 1; // Ticks
+constexpr uint32_t BACKGROUND_WS_WINDOW_SIZE = 2; // Ticks
+
+constexpr bool RESERVE_FOREGROUND_WS_FLAG = true;
+constexpr bool RESERVE_SWITCHING_WS_FLAG = true;
+
+constexpr bool ACTIVE_SWAPOUT = true;
+
+} // namespace jiacheng
+} // namespace art
+
+#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_debug.cc b/runtime/jiacheng_debug.cc
index 9b699efcd7..f308572787 100644
--- a/runtime/jiacheng_debug.cc
+++ b/runtime/jiacheng_debug.cc
@@ -88,9 +88,8 @@ void ClearAndPrintWorkingSet() {
 
 typedef void(*WalkCallback)(void *start, void *end, size_t num_bytes, void* callback_arg);
 
-// 对ColdSpace中的Region进行Swap
+// 对所有Space中的对象进行Swap
 void SwapOutAll() {
-    // 对所有Space中的对象进行Swap
     gc::Heap* heap = Runtime::Current()->GetHeap();
     Thread* self = Thread::Current();
     const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
@@ -107,11 +106,6 @@ void SwapOutAll() {
         CurrentThreadSleepSecond(1);
         SwapOutSpace(space);
     }    
-
-    // 不直接使用SwapOutSpace()函数对所有Space中的对象进行Swap
-    // LOG(INFO) << "jiacheng jiacheng_hack.cc 180 SwapOut()";
-    // ColdSpace* cold_space = ColdSpace::Current();
-    // cold_space->SwapOut();
 }
 
 
diff --git a/runtime/jiacheng_debug.h b/runtime/jiacheng_debug.h
index 67f2cb8d75..9a240f8472 100644
--- a/runtime/jiacheng_debug.h
+++ b/runtime/jiacheng_debug.h
@@ -32,8 +32,10 @@ void SwapOutAll();
 
 void SwapOutSpace(gc::space::Space* space);
 
+
 /* ------------------- debug --------------------- */
 
+
 std::string GetSpaceFromObject(mirror::Object* obj);
 
 void PrintHeapObjectInformation();
diff --git a/runtime/jiacheng_hack.cc b/runtime/jiacheng_hack.cc
index 1a573d317b..b113f59654 100644
--- a/runtime/jiacheng_hack.cc
+++ b/runtime/jiacheng_hack.cc
@@ -5,6 +5,7 @@
 #include "gc/space/region_space.h"
 #include "gc/collector/garbage_collector.h"
 #include "base/utils.h"
+#include "mirror/object-inl.h"
 
 #include <sys/mman.h>
 
@@ -14,9 +15,6 @@
 #include "jiacheng_profiler.h"
 #include "jiacheng_swapper.h"
 
-
-
-
 namespace art{
 namespace jiacheng {
 
@@ -38,8 +36,8 @@ bool HandleFault(int sig, siginfo_t* info, void* context) {
 
     gc::space::RegionSpace* region_space = Runtime::Current()->GetHeap()->GetRegionSpace();
     if (region_space->HasAddress(ref)) {
-        region_space->HandleFault(ref);
-        return true;
+        bool result = region_space->HandleFault(ref);
+        return result;
     } else {
         return false;
     }
@@ -86,9 +84,16 @@ void UpdataAppState(ProcessState old_process_state, ProcessState new_process_sta
               ;
 
     if (new_process_state == kProcessStateJankImperceptible) {
-        profiler->ClearPerceptibleFlag();
+        if (profiler->GetPerceptibleFlag()) {
+            profiler->SetBackgroundTime(profiler->GetCurrentTime());
+            profiler->ClearPerceptibleFlag();
+        }
     } else {
-        profiler->SetPerceptibleFlag();
+        if (!profiler->GetPerceptibleFlag()) {
+            profiler->SetSwitchingTime(profiler->GetCurrentTime());
+            profiler->SetSwitchingFlag();
+            profiler->SetPerceptibleFlag();
+        }
     }
 
 }
@@ -131,7 +136,7 @@ void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector)
 
     Runtime::Current()->GetHeap()->GetRegionSpace()->InitColdToRegionRememberedSet();
     // jiacheng debug start
-    Runtime::Current()->GetHeap()->GetRegionSpace()->JiachengDebug();
+    // Runtime::Current()->GetHeap()->GetRegionSpace()->JiachengDebug();
     // jiacheng debug end
 }
 
@@ -139,14 +144,27 @@ void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector)
 // 1. Copy过程的from_ref和to_ref
 // 2. Scan过程
 void GCAccessTrigger(mirror::Object* obj) {
-    if (!obj) {
-        return;
-    }
-    if (!IsWhiteApp()) {
-        return;
+    (void)obj;
+    // if (!obj) {
+    //     return;
+    // }
+    // if (!IsWhiteApp()) {
+    //     return;
+    // }
+    // Profiler* profiler = Profiler::Current();
+    // profiler->RecordGcWS(obj);
+}
+
+bool ObjectIsSwappableType(mirror::Object* obj) {
+    if (obj->IsArrayInstance()) {
+        return !obj->IsObjectArray();
+    } else {
+        return !obj->IsClass() && !obj->IsClassLoader() && !obj->IsDexCache() && !obj->IsString() && !obj->IsReferenceInstance();
     }
-    Profiler* profiler = Profiler::Current();
-    profiler->RecordGcWS(obj);
+    // return (
+    //     (obj->IsArrayInstance() && !obj->IsObjectArray())
+    //     || (!obj->IsArrayInstance() && !obj->IsClass() && !obj->IsClassLoader() && !obj->IsDexCache() && !obj->IsString() && !obj->IsReferenceInstance())
+    // );
 }
 
 void JiachengDebug() {
diff --git a/runtime/jiacheng_hack.h b/runtime/jiacheng_hack.h
index fbe645e66e..c797fe36b2 100644
--- a/runtime/jiacheng_hack.h
+++ b/runtime/jiacheng_hack.h
@@ -32,6 +32,8 @@ void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector);
 
 void GCAccessTrigger(mirror::Object* obj);
 
+bool ObjectIsSwappableType(mirror::Object * obj) NO_THREAD_SAFETY_ANALYSIS;
+
 void JiachengDebug();
 
 } // namespace jiacheng
diff --git a/runtime/jiacheng_profiler.cc b/runtime/jiacheng_profiler.cc
index 42c2c6cdae..921c52e14c 100644
--- a/runtime/jiacheng_profiler.cc
+++ b/runtime/jiacheng_profiler.cc
@@ -1,8 +1,11 @@
 #include "jiacheng_profiler.h"
 #include "jiacheng_utils.h"
 #include "jiacheng_debug.h"
+#include "jiacheng_hack.h"
+#include "jiacheng_common.h"
 
 #include "thread-inl.h"
+#include "mirror/object.h"
 
 namespace art {
 namespace jiacheng {
@@ -25,7 +28,9 @@ Profiler::Profiler():
     during_gc_flag_(false),
     perceptible_flag_(true),
     gc_number_(0),
-    start_time_(0) {
+    start_time_(0),
+    current_time_(1000),
+    background_time_(0) {
 }
 
 Profiler::~Profiler() = default;
@@ -84,6 +89,8 @@ bool Profiler::TestInAccessWS(mirror::Object* obj) {
     // read_working_set_lock_.ExclusiveLock(self);
     // bool result = (read_working_set_.find(obj) != read_working_set_.end());
     // read_working_set_lock_.ExclusiveUnlock(self);
+
+    // return access_bloom_filter_.Check(reinterpret_cast<uint64_t>(obj)) || obj->GetAccess();
     return access_bloom_filter_.Check(reinterpret_cast<uint64_t>(obj));
 }
 
@@ -116,11 +123,11 @@ bool Profiler::TestInGcWS(mirror::Object* obj) {
 }
 
 void Profiler::SetDuringGcFlag() {
-    during_gc_flag_.store(1);
+    during_gc_flag_.store(true);
 }
 
 void Profiler::ClearDuringGcFlag() {
-    during_gc_flag_.store(0);
+    during_gc_flag_.store(false);
 }
 
 // bool Profiler::GetDuringGcFlag() {
@@ -128,30 +135,66 @@ void Profiler::ClearDuringGcFlag() {
 // }
 
 void Profiler::SetPerceptibleFlag() {
-    perceptible_flag_.store(1);
+    perceptible_flag_.store(true);
 }
 
 void Profiler::ClearPerceptibleFlag() {
-    perceptible_flag_.store(0);
+    perceptible_flag_.store(false);
 }
 
 bool Profiler::GetPerceptibleFlag() {
     return perceptible_flag_.load();
 }
 
+void Profiler::SetSwitchingFlag() {
+    switching_flag_.store(true);
+}
+
+void Profiler::ClearSwitchingFlag() {
+    switching_flag_.store(false);
+}
+
+bool Profiler::GetSwitchingFlag() {
+    return switching_flag_.load();
+}
+
 bool Profiler::ShouldSwapOut(mirror::Object* obj) {
-    // jiacheng debug start
+    if (!obj) {
+        return false;
+    }
     if(!IsWhiteApp()) {
         return false;
     }
     if (GetPerceptibleFlag()) {
         return false;
     }
-    return !TestInAccessWS(obj);
-
-    // (void)obj;
-    // return false;
-    // jiacheng debug end
+    if (!ObjectIsSwappableType(obj)) {
+        return false;
+    }
+    // if (current_time_-background_time_ <= 0) {
+    //     return false;
+    // }
+    uint16_t foreground_access_record = obj->GetForegroundAccessRecord();
+    uint16_t background_access_record = obj->GetBackgroundAccessRecord();
+    uint16_t switching_access_record = obj->GetSwitchAccessRecord();
+
+    // LOG(INFO) << "jiacheng debug jiacheng_profiler.cc 161 ShouldSwapOut() "
+    //           << " foreground_access_record= " << foreground_access_record
+    //           << " background_access_record= " << background_access_record
+    //           << " switching_access_record= " << switching_access_record
+    //           << " background_time_= " << background_time_
+    //           << " switching_time_= " << switching_time_
+    //           << " GetCurrentTime()= " << GetCurrentTime();
+    
+    uint16_t foreground_distance = background_time_ - foreground_access_record;
+    uint16_t background_distance = current_time_ - background_access_record;
+    bool foreground_ws = RESERVE_FOREGROUND_WS_FLAG && (foreground_distance < FOREGROUND_WS_WINDOW_SIZE);
+    bool background_ws = (background_distance < BACKGROUND_WS_WINDOW_SIZE);
+    bool switching_ws = RESERVE_SWITCHING_WS_FLAG && (switching_access_record != 0);
+    if (foreground_ws || background_ws || switching_ws) {
+        return false;
+    } 
+    return true;
 }
 
 void Profiler::IncreaseGcNumber() {
@@ -162,7 +205,6 @@ uint32_t Profiler::GetGcNumber() {
     return gc_number_.load();
 }
 
-
 void Profiler::SetStartTime(uint64_t start_time) {
     start_time_.store(start_time);
 }
@@ -170,6 +212,34 @@ void Profiler::SetStartTime(uint64_t start_time) {
 uint64_t Profiler::GetStartTime() {
     return start_time_.load();
 }
+
+void Profiler::SetCurrentTime(uint16_t current_time) {
+    current_time_.store(current_time);
+}
+
+void Profiler::IncreaseCurrentTime() {
+    current_time_.fetch_add(1);
+}
+
+uint16_t Profiler::GetCurrentTime() {
+    return current_time_.load();
+}
+
+void Profiler::SetBackgroundTime(uint16_t background_time) {
+    background_time_.store(background_time);
+}
+
+uint16_t Profiler::GetBackgroundTime() {
+    return background_time_.load();
+}
+
+void Profiler::SetSwitchingTime(uint16_t switching_time) {
+    switching_time_.store(switching_time);
+}
+
+uint16_t Profiler::GetSwitchingTime() {
+    return switching_time_.load();
+}
  
 } // namespace jiacheng
 } // namespace art
\ No newline at end of file
diff --git a/runtime/jiacheng_profiler.h b/runtime/jiacheng_profiler.h
index 500cbd55c7..70c2d370fc 100644
--- a/runtime/jiacheng_profiler.h
+++ b/runtime/jiacheng_profiler.h
@@ -52,6 +52,10 @@ public:
     void ClearPerceptibleFlag();
     bool GetPerceptibleFlag();
 
+    void SetSwitchingFlag();
+    void ClearSwitchingFlag();
+    bool GetSwitchingFlag();
+
     bool ShouldSwapOut(mirror::Object* obj);
 
     void IncreaseGcNumber();
@@ -60,6 +64,16 @@ public:
     void SetStartTime(uint64_t start_time);
     uint64_t GetStartTime();
 
+    void SetCurrentTime(uint16_t current_time);
+    void IncreaseCurrentTime();
+    uint16_t GetCurrentTime();
+
+    void SetBackgroundTime(uint16_t background_time);
+    uint16_t GetBackgroundTime();
+
+    void SetSwitchingTime(uint16_t switching_time);
+    uint16_t GetSwitchingTime();
+
 private:
     // Mutator的Working Set
     BloomFilter access_bloom_filter_;
@@ -83,12 +97,20 @@ private:
     // APP当前在前台还是后台
     std::atomic<bool> perceptible_flag_;
 
+    // set in UpdateProcessState(), clear in main thread
+    std::atomic<bool> switching_flag_; 
+
     // 历史GC发生的总次数
     std::atomic<uint32_t> gc_number_;
 
     std::atomic<uint64_t> start_time_;
 
+    std::atomic<uint16_t> current_time_;
+
+    std::atomic<uint16_t> background_time_;
 
+    // Update in UpdateProcessState() function
+    std::atomic<uint16_t> switching_time_; 
 };
 
 }
diff --git a/runtime/jiacheng_swapper.cc b/runtime/jiacheng_swapper.cc
index 9755a4688c..71ab931919 100644
--- a/runtime/jiacheng_swapper.cc
+++ b/runtime/jiacheng_swapper.cc
@@ -3,6 +3,7 @@
 #include "jiacheng_profiler.h"
 #include "jiacheng_utils.h"
 #include "jiacheng_debug.h"
+#include "jiacheng_common.h"
 
 #include "thread-inl.h"
 #include "runtime.h"
@@ -47,27 +48,31 @@ Swapper::~Swapper() = default;
 
 
 void Swapper::Run() {
+    uint32_t swapout_time = 0;
     Profiler* profiler = Profiler::Current();
     bool gc_flag, perceptible_flag;
+
     while (true) {
-        CurrentThreadSleepSecond(30);
+        ++swapout_time;
+        CurrentThreadSleepSecond(CLOCK_TICK);
+        profiler->IncreaseCurrentTime();
+
+        // handle switching flag
+        uint16_t current_time = profiler->GetCurrentTime();
+        uint16_t switching_time = profiler->GetSwitchingTime();
+        if (profiler->GetSwitchingFlag()) {
+            if (current_time - switching_time >= SWITCHING_WINDOW_SIZE) {
+                profiler->ClearSwitchingFlag();
+            }
+        }
+
         gc_flag = profiler->GetDuringGcFlag();
         perceptible_flag = profiler->GetPerceptibleFlag();
-        LOG(INFO) << "jiacheng jiacheng_swapper.cc 43 Run() swapper thread" 
-                  << " gc_flag= " << gc_flag
-                  << " perceptible_flag= " << perceptible_flag
-                  ;
-        if (!gc_flag && !perceptible_flag) {
-            // jiacheng debug start
-            // SwapOutHeap();
-            // jiacheng debug end
-        }
-        profiler->JiachengDebug();
-        profiler->ClearAccessWS();
 
-        // jiacheng debug start
-        // ClearAndPrintWorkingSet();
-        // jiacheng debug end
+        if (ACTIVE_SWAPOUT && !gc_flag && !perceptible_flag && swapout_time>=SWAPOUT_WINDOW_SIZE) {
+            swapout_time = 0;
+            SwapOutHeap();
+        }
     }
 }
 
@@ -141,7 +146,6 @@ void Swapper::SwapOutMallocSpace(gc::space::MallocSpace* space) {
     (void)space;
     CHECK(space == Runtime::Current()->GetHeap()->GetNonMovingSpace());
     LOG(INFO) << "jiacheng jiacheng_swapper.cc 144 SwapOutMallocSpace()";
-    // madvise(space->Begin(), space->Size(), 233);
     WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* ) {
         if (start != end) {
             jiacheng::SwapOutRange(start, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start));
@@ -156,16 +160,15 @@ void Swapper::SwapOutZygoteSpace(gc::space::ZygoteSpace* space) {
     // jiacheng::SwapOutRange(space->Begin(), space->Size());
 }
 
-void Swapper::SwapOutBumpPointerSpace(gc::space::BumpPointerSpace* space ATTRIBUTE_UNUSED) {
+void Swapper::SwapOutBumpPointerSpace(gc::space::BumpPointerSpace* space) {
+    (void)space;
     UNIMPLEMENTED(FATAL);
 }
 
 void Swapper::SwapOutLargeObjectSpace(gc::space::LargeObjectSpace* space) {
-    (void)space;
     LOG(INFO) << "jiacheng jiacheng_swapper.cc 144 SwapOutLargeObjectSpace()";
     WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* ) {
         if (start != end) {
-            // LOG(INFO) << "jiacheng SwapOutLargeObjectSpace() obj= " << size_t(start) << " size= " << size_t(end) - size_t(start);
             jiacheng::SwapOutRange(start, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start));
         }
     };
@@ -173,7 +176,6 @@ void Swapper::SwapOutLargeObjectSpace(gc::space::LargeObjectSpace* space) {
 }
 
 void Swapper::SwapOutRegionSpace(gc::space::RegionSpace* space) {
-    (void)space;
     LOG(INFO) << "jiacheng jiacheng_swapper.cc 144 SwapOutRegionSpace()";
     space->SwapOutCold();
 }
diff --git a/runtime/jiacheng_swapper.h b/runtime/jiacheng_swapper.h
index b0c88c8067..c860558282 100644
--- a/runtime/jiacheng_swapper.h
+++ b/runtime/jiacheng_swapper.h
@@ -55,6 +55,8 @@ private:
     std::thread* swap_thread_;
 };
 
+
+
 } // namespace jiacheng
 } // namespace art
 
diff --git a/runtime/jiacheng_utils.cc b/runtime/jiacheng_utils.cc
index adcde4f3ab..12c1b669a8 100644
--- a/runtime/jiacheng_utils.cc
+++ b/runtime/jiacheng_utils.cc
@@ -63,9 +63,9 @@ bool IsWhiteApp() {
         "com.king.candycrushsaga",
 
         "com.taobao.taobao", 
-        "edu.washington.cs.nl35.memorywaster", 
         "com.jiacheng.activitylifecycletest",
 
+        "edu.washington.cs.nl35.memorywaster", 
         "edu.washington.cs.nl35.memorywaster1",
         "edu.washington.cs.nl35.memorywaster2",
         "edu.washington.cs.nl35.memorywaster3",
diff --git a/runtime/jiacheng_utils.h b/runtime/jiacheng_utils.h
index 13287135d8..0021e0f519 100644
--- a/runtime/jiacheng_utils.h
+++ b/runtime/jiacheng_utils.h
@@ -22,7 +22,6 @@ void PrintKernel(const std::string& info);
 
 bool SwapOutRange(void* start, size_t size);
 
-
 } // namespace jiacheng
 } // namespace art
 
diff --git a/runtime/mirror/object-inl.h b/runtime/mirror/object-inl.h
index b33b4fd5b5..b908c43a6a 100644
--- a/runtime/mirror/object-inl.h
+++ b/runtime/mirror/object-inl.h
@@ -630,7 +630,6 @@ inline void Object::SetFieldObjectWithoutWriteBarrier(MemberOffset field_offset,
   VerifyTransaction<kTransactionActive, kCheckTransaction>();
   // jiacheng start
   jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
-  SetAccess();
   // jiacheng end
   if (kTransactionActive) {
     ObjPtr<Object> obj;
diff --git a/runtime/mirror/object-refvisitor-inl.h b/runtime/mirror/object-refvisitor-inl.h
index f98c433cdd..3729f729b1 100644
--- a/runtime/mirror/object-refvisitor-inl.h
+++ b/runtime/mirror/object-refvisitor-inl.h
@@ -33,6 +33,9 @@ template <bool kVisitNativeRoots,
           typename JavaLangRefVisitor>
 inline void Object::VisitReferences(const Visitor& visitor,
                                     const JavaLangRefVisitor& ref_visitor) {
+  // jiacheng start
+  jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+  // jiacheng end
   visitor(this, ClassOffset(), /* is_static= */ false);
   ObjPtr<Class> klass = GetClass<kVerifyFlags, kReadBarrierOption>();
   const uint32_t class_flags = klass->GetClassFlags<kVerifyNone>();
diff --git a/runtime/mirror/object.cc b/runtime/mirror/object.cc
index a30b2499e4..227aa7f3d2 100644
--- a/runtime/mirror/object.cc
+++ b/runtime/mirror/object.cc
@@ -301,12 +301,50 @@ std::string Object::PrettyTypeOf() {
 }
 
 // jiacheng start
-void Object::SetAccess() {
-  Runtime* runtime = Runtime::Current();
-  if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return;
-  // if (runtime->IsSystemServer()) return;
-  z_zflags1_ = z_zflags1_ | 0x02;
+void Object::SetForegroundAccessRecord(uint16_t current_time) {
+  // Runtime* runtime = Runtime::Current();
+  // if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return;
+  if (Runtime::Current()->IsSystemServer()) return;
+  foreground_access_record_ = current_time;
+}
+
+
+uint16_t Object::GetForegroundAccessRecord() {
+  // Runtime* runtime = Runtime::Current();
+  // if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return 0;
+  if (Runtime::Current()->IsSystemServer()) return 0;
+  return foreground_access_record_;
+}
+
+void Object::SetBackgroundAccessRecord(uint16_t current_time) {
+  // Runtime* runtime = Runtime::Current();
+  // if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return;
+  if (Runtime::Current()->IsSystemServer()) return;
+  background_access_record_ = current_time;
+}
+
+uint16_t Object::GetBackgroundAccessRecord() {
+  // Runtime* runtime = Runtime::Current();
+  // if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return 0;
+  if (Runtime::Current()->IsSystemServer()) return 0;
+  return background_access_record_;
+}
+
+void Object::SetSwitchAccessRecord(uint16_t current_time) {
+  // Runtime* runtime = Runtime::Current();
+  // if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return;
+  if (Runtime::Current()->IsSystemServer()) return;
+  switch_access_record_ = current_time;
 }
+
+uint16_t Object::GetSwitchAccessRecord() {
+  // Runtime* runtime = Runtime::Current();
+  // if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return 0;
+  if (Runtime::Current()->IsSystemServer()) return 0;
+  return switch_access_record_;
+}
+
+
 // jiacheng end
 
 }  // namespace mirror
diff --git a/runtime/mirror/object.h b/runtime/mirror/object.h
index 37a6596afc..32f9208c20 100644
--- a/runtime/mirror/object.h
+++ b/runtime/mirror/object.h
@@ -98,7 +98,17 @@ class MANAGED LOCKABLE Object {
   }
 
   // jiacheng start
-  void SetAccess();
+  void SetForegroundAccessRecord(uint16_t current_time);
+
+  uint16_t GetForegroundAccessRecord();
+
+  void SetBackgroundAccessRecord(uint16_t current_time);
+
+  uint16_t GetBackgroundAccessRecord();
+
+  void SetSwitchAccessRecord(uint16_t current_time);
+
+  uint16_t GetSwitchAccessRecord();
   // jiacheng end
 
   template<VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags,
@@ -370,9 +380,6 @@ class MANAGED LOCKABLE Object {
     } else {
       reinterpret_cast<Atomic<kType>*>(addr)->StoreJavaData(new_value);
     }
-    // jiacheng debug start
-    SetAccess();
-    // jiacheng debug end
   }
 
   template<typename kType, bool kIsVolatile>
@@ -380,7 +387,6 @@ class MANAGED LOCKABLE Object {
       REQUIRES_SHARED(Locks::mutator_lock_) {
     // jiacheng start
     jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
-    SetAccess();
     // jiacheng end
     const uint8_t* raw_addr = reinterpret_cast<const uint8_t*>(this) + field_offset.Int32Value();
     const kType* addr = reinterpret_cast<const kType*>(raw_addr);
@@ -793,11 +799,10 @@ class MANAGED LOCKABLE Object {
   uint32_t monitor_;
 
   // jiacheng start
-  uint32_t z_padding_;
-  uint8_t z_zflags0_;
-  uint8_t z_zflags1_;
-  uint8_t z_zflags2_;
-  uint8_t z_zflags3_;
+  uint16_t foreground_access_record_;
+  uint16_t background_access_record_;
+  uint16_t switch_access_record_;
+  uint16_t padding_;
   // jiacheng end
 
 #ifdef USE_BROOKS_READ_BARRIER
-- 
2.34.1


From ebf6a6e46ee01696d2a0ec41b565c3fb8fa2d2cf Mon Sep 17 00:00:00 2001
From: jiachengh <jiacheng.huang@outlook.com>
Date: Wed, 14 Feb 2024 10:53:40 +0800
Subject: [PATCH 5/7] Remove profiling

Change-Id: I5392fa8f9535e3ad411034464a0062e134a647c3
---
 compiler/optimizing/code_generator.cc         |   4 +-
 compiler/optimizing/code_generator_arm64.cc   | 121 +--
 compiler/optimizing/code_generator_arm64.h    |   3 +-
 runtime/Android.bp                            |   4 -
 runtime/arch/arm/quick_entrypoints_arm.S      |   8 +
 runtime/arch/arm64/quick_entrypoints_arm64.S  |  21 +
 .../quick/quick_entrypoints_list.h            |   1 +
 .../quick/quick_trampoline_entrypoints.cc     |   9 +-
 runtime/gc/accounting/card_table.h            |  11 +
 runtime/gc/accounting/mod_union_table.cc      |   1 +
 runtime/gc/collector/concurrent_copying-inl.h |  44 +-
 runtime/gc/collector/concurrent_copying.cc    | 776 +++++++++++++-----
 runtime/gc/collector/concurrent_copying.h     |  63 +-
 runtime/gc/collector/garbage_collector.cc     |  12 +-
 runtime/gc/collector/garbage_collector.h      |  15 +
 runtime/gc/gc_cause.cc                        |   3 +
 runtime/gc/gc_cause.h                         |   3 +
 runtime/gc/heap-inl.h                         |   7 +
 runtime/gc/heap.cc                            | 266 +++++-
 runtime/gc/heap.h                             | 135 ++-
 runtime/gc/space/dlmalloc_space.cc            |  26 +
 runtime/gc/space/dlmalloc_space.h             |   7 +
 runtime/gc/space/large_object_space.cc        |  65 ++
 runtime/gc/space/large_object_space.h         |  23 +-
 runtime/gc/space/malloc_space.cc              |  22 +
 runtime/gc/space/malloc_space.h               |   8 +
 runtime/gc/space/region_space-inl.h           |  29 +-
 runtime/gc/space/region_space.cc              | 567 +++++--------
 runtime/gc/space/region_space.h               | 177 ++--
 runtime/gc/space/space.cc                     |  19 +
 runtime/gc/space/space.h                      |  12 +
 runtime/jiacheng_barrier.cc                   |  45 +-
 runtime/jiacheng_barrier.h                    |  11 +-
 runtime/jiacheng_bloom_filter.h               |   5 +-
 runtime/jiacheng_global.h                     |  41 +
 runtime/jiacheng_hack.cc                      | 186 +----
 runtime/jiacheng_hack.h                       |  21 +-
 runtime/jiacheng_utils.cc                     | 121 +--
 runtime/jiacheng_utils.h                      |  20 +-
 runtime/mirror/array.h                        |   4 +
 runtime/mirror/object-inl.h                   |  38 +
 runtime/mirror/object.cc                      |  59 +-
 runtime/mirror/object.h                       | 105 ++-
 runtime/thread-inl.h                          |   7 +
 runtime/thread.cc                             |   4 +
 runtime/thread.h                              |  14 +
 runtime/write_barrier-inl.h                   |  19 +
 runtime/write_barrier.h                       |   4 +
 48 files changed, 1961 insertions(+), 1205 deletions(-)
 create mode 100644 runtime/jiacheng_global.h

diff --git a/compiler/optimizing/code_generator.cc b/compiler/optimizing/code_generator.cc
index 576f18f5cb..3e34ecb082 100644
--- a/compiler/optimizing/code_generator.cc
+++ b/compiler/optimizing/code_generator.cc
@@ -497,11 +497,9 @@ void CodeGenerator::InitializeCodeGeneration(size_t number_of_spill_slots,
 void CodeGenerator::CreateCommonInvokeLocationSummary(
     HInvoke* invoke, InvokeDexCallingConventionVisitor* visitor) {
   ArenaAllocator* allocator = invoke->GetBlock()->GetGraph()->GetAllocator();
-  // jiacheng start
   LocationSummary* locations = new (allocator) LocationSummary(invoke,
                                                                LocationSummary::kCallOnMainOnly);
-  // LocationSummary* locations = new (allocator) LocationSummary(invoke, LocationSummary::kCallOnMainAndSlowPath, true);
-  // jiacheng end
+                                                               
   for (size_t i = 0; i < invoke->GetNumberOfArguments(); i++) {
     HInstruction* input = invoke->InputAt(i);
     locations->SetInAt(i, visitor->GetNextLocation(input->GetType()));
diff --git a/compiler/optimizing/code_generator_arm64.cc b/compiler/optimizing/code_generator_arm64.cc
index 96ff9eeee4..a2710bc2ca 100644
--- a/compiler/optimizing/code_generator_arm64.cc
+++ b/compiler/optimizing/code_generator_arm64.cc
@@ -1870,20 +1870,13 @@ void LocationsBuilderARM64::HandleFieldGet(HInstruction* instruction,
 
   bool object_field_get_with_read_barrier =
       kEmitCompilerReadBarrier && (instruction->GetType() == DataType::Type::kReference);
-  // 
-  // LocationSummary* locations =
-  //     new (GetGraph()->GetAllocator()) LocationSummary(instruction,
-  //                                                      object_field_get_with_read_barrier
-  //                                                          ? LocationSummary::kCallOnSlowPath
-  //                                                          : LocationSummary::kNoCall);
-  LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kCallOnSlowPath);
-  // jiacheng end
-
+  LocationSummary* locations =
+      new (GetGraph()->GetAllocator()) LocationSummary(instruction,
+                                                       object_field_get_with_read_barrier
+                                                           ? LocationSummary::kCallOnSlowPath
+                                                           : LocationSummary::kNoCall);
   if (object_field_get_with_read_barrier && kUseBakerReadBarrier) {
-    // jiacheng start
-    // locations->SetCustomSlowPathCallerSaves(RegisterSet::Empty());  // No caller-save registers.
-    // jiacheng end
-
+    locations->SetCustomSlowPathCallerSaves(RegisterSet::Empty());  // No caller-save registers.
     // We need a temporary register for the read barrier load in
     // CodeGeneratorARM64::GenerateFieldLoadWithBakerReadBarrier()
     // only if the field is volatile or the offset is too big.
@@ -1918,7 +1911,9 @@ void InstructionCodeGeneratorARM64::HandleFieldGet(HInstruction* instruction,
   MemOperand field = HeapOperand(InputRegisterAt(instruction, 0), field_info.GetFieldOffset());
 
   // jiacheng start
-  codegen_->GenerateJiachengBarrier(instruction, base_loc);
+  if (load_type == DataType::Type::kReference) {
+    codegen_->GenerateJiachengBarrierInline(RegisterFrom(base_loc, DataType::Type::kReference));
+  }
   // jiacheng end
 
   if (kEmitCompilerReadBarrier && kUseBakerReadBarrier &&
@@ -1962,13 +1957,8 @@ void InstructionCodeGeneratorARM64::HandleFieldGet(HInstruction* instruction,
 }
 
 void LocationsBuilderARM64::HandleFieldSet(HInstruction* instruction) {
-  // jiacheng start
-  // LocationSummary* locations =
-  //     new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kNoCall);
   LocationSummary* locations =
-      new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kCallOnSlowPath);
-  // jiacheng end
-
+      new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kNoCall);
   locations->SetInAt(0, Location::RequiresRegister());
   if (IsConstantZeroBitPattern(instruction->InputAt(1))) {
     locations->SetInAt(1, Location::ConstantLocation(instruction->InputAt(1)->AsConstant()));
@@ -1991,7 +1981,9 @@ void InstructionCodeGeneratorARM64::HandleFieldSet(HInstruction* instruction,
   DataType::Type field_type = field_info.GetFieldType();
 
   // jiacheng start
-  codegen_->GenerateJiachengBarrier(instruction, LocationFrom(obj));
+  if (instruction->GetType() == DataType::Type::kReference) {
+    codegen_->GenerateJiachengBarrierInline(obj);
+  }
   // jiacheng end
   
   {
@@ -2359,19 +2351,13 @@ void InstructionCodeGeneratorARM64::VisitMultiplyAccumulate(HMultiplyAccumulate*
 void LocationsBuilderARM64::VisitArrayGet(HArrayGet* instruction) {
   bool object_array_get_with_read_barrier =
       kEmitCompilerReadBarrier && (instruction->GetType() == DataType::Type::kReference);
-  // jiacheng start
-  // LocationSummary* locations =
-  //     new (GetGraph()->GetAllocator()) LocationSummary(instruction,
-  //                                                      object_array_get_with_read_barrier
-  //                                                          ? LocationSummary::kCallOnSlowPath
-  //                                                          : LocationSummary::kNoCall);
-  LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kCallOnSlowPath);
-  // jiacheng end
-
+  LocationSummary* locations =
+      new (GetGraph()->GetAllocator()) LocationSummary(instruction,
+                                                       object_array_get_with_read_barrier
+                                                           ? LocationSummary::kCallOnSlowPath
+                                                           : LocationSummary::kNoCall);
   if (object_array_get_with_read_barrier && kUseBakerReadBarrier) {
-    // jiacheng start
-    // locations->SetCustomSlowPathCallerSaves(RegisterSet::Empty());  // No caller-save registers.
-    // jiacheng end
+    locations->SetCustomSlowPathCallerSaves(RegisterSet::Empty());  // No caller-save registers.
     if (instruction->GetIndex()->IsConstant()) {
       // Array loads with constant index are treated as field loads.
       // We need a temporary register for the read barrier load in
@@ -2417,7 +2403,9 @@ void InstructionCodeGeneratorARM64::VisitArrayGet(HArrayGet* instruction) {
   UseScratchRegisterScope temps(masm);
 
   // jiacheng start
-  codegen_->GenerateJiachengBarrier(instruction, LocationFrom(obj));
+  if (type == DataType::Type::kReference) {
+    codegen_->GenerateJiachengBarrierInline(obj.W());
+  }
   // jiacheng end
 
   // The non-Baker read barrier instrumentation of object ArrayGet instructions
@@ -2541,11 +2529,7 @@ void InstructionCodeGeneratorARM64::VisitArrayGet(HArrayGet* instruction) {
 }
 
 void LocationsBuilderARM64::VisitArrayLength(HArrayLength* instruction) {
-  // jiacheng start
-  // LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction);
-  LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kCallOnSlowPath);
-  // jiacheng end
-
+  LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction);
   locations->SetInAt(0, Location::RequiresRegister());
   locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
 }
@@ -2555,8 +2539,10 @@ void InstructionCodeGeneratorARM64::VisitArrayLength(HArrayLength* instruction)
   vixl::aarch64::Register out = OutputRegister(instruction);
   
   // jiacheng start
-  Register obj = InputRegisterAt(instruction, 0);
-  codegen_->GenerateJiachengBarrier(instruction, LocationFrom(obj));
+  if (instruction->GetType() == DataType::Type::kReference) {
+    Register obj = InputRegisterAt(instruction, 0);
+    codegen_->GenerateJiachengBarrierInline(obj);
+  }
   // jiacheng end
 
   {
@@ -2574,16 +2560,12 @@ void InstructionCodeGeneratorARM64::VisitArrayLength(HArrayLength* instruction)
 void LocationsBuilderARM64::VisitArraySet(HArraySet* instruction) {
   DataType::Type value_type = instruction->GetComponentType();
 
-
-  // jiacheng start
   bool may_need_runtime_call_for_type_check = instruction->NeedsTypeCheck();
   LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(
       instruction,
       may_need_runtime_call_for_type_check ?
           LocationSummary::kCallOnSlowPath :
           LocationSummary::kNoCall);
-  // LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction, LocationSummary::kCallOnSlowPath);
-  // jiacheng end
   locations->SetInAt(0, Location::RequiresRegister());
   locations->SetInAt(1, Location::RegisterOrConstant(instruction->InputAt(1)));
   if (IsConstantZeroBitPattern(instruction->InputAt(2))) {
@@ -2611,8 +2593,9 @@ void InstructionCodeGeneratorARM64::VisitArraySet(HArraySet* instruction) {
   MacroAssembler* masm = GetVIXLAssembler();
 
   // jiacheng start
-  // codegen_->GenerateJiachengBarrier(instruction, LocationFrom(array));
-  // codegen_->GenerateJiachengBarrierRaw(instruction, LocationFrom(array));
+  if (instruction->GetType() == DataType::Type::kReference) {
+    codegen_->GenerateJiachengBarrierInline(array);
+  }
   // jiacheng end
 
   if (!needs_write_barrier) {
@@ -4068,10 +4051,6 @@ void InstructionCodeGeneratorARM64::VisitInvokeInterface(HInvokeInterface* invok
   // Ensure that between load and MaybeRecordImplicitNullCheck there are no pools emitted.
   if (receiver.IsStackSlot()) {
     __ Ldr(temp.W(), StackOperandFrom(receiver));
-    // jiacheng start
-    // codegen_->GenerateJiachengBarrier(invoke, LocationFrom(temp));
-    // codegen_->GenerateJiachengBarrierRaw(invoke, LocationFrom(temp));
-    // jiacheng end
     {
       EmissionCheckScope guard(GetVIXLAssembler(), kMaxMacroInstructionSizeInBytes);
       // /* HeapReference<Class> */ temp = temp->klass_
@@ -4079,10 +4058,6 @@ void InstructionCodeGeneratorARM64::VisitInvokeInterface(HInvokeInterface* invok
       codegen_->MaybeRecordImplicitNullCheck(invoke);
     }
   } else {
-    // jiacheng start
-    // codegen_->GenerateJiachengBarrier(invoke, receiver);
-    // codegen_->GenerateJiachengBarrierRaw(invoke, receiver);
-    // jiacheng end
     EmissionCheckScope guard(GetVIXLAssembler(), kMaxMacroInstructionSizeInBytes);
     // /* HeapReference<Class> */ temp = receiver->klass_
     __ Ldr(temp.W(), HeapOperandFrom(receiver, class_offset));
@@ -4102,11 +4077,6 @@ void InstructionCodeGeneratorARM64::VisitInvokeInterface(HInvokeInterface* invok
   uint32_t method_offset = static_cast<uint32_t>(ImTable::OffsetOfElement(
       invoke->GetImtIndex(), kArm64PointerSize));
 
-  // jiacheng start
-  // codegen_->GenerateJiachengBarrier(invoke, LocationFrom(temp));
-  // codegen_->GenerateJiachengBarrierRaw(invoke, LocationFrom(temp));
-  // jiacheng end
-
   // temp = temp->GetImtEntryAt(method_offset);
   __ Ldr(temp, MemOperand(temp, method_offset));
   // lr = temp->GetEntryPoint();
@@ -4267,11 +4237,6 @@ void CodeGeneratorARM64::GenerateVirtualCall(
   Offset entry_point = ArtMethod::EntryPointFromQuickCompiledCodeOffset(kArm64PointerSize);
 
   DCHECK(receiver.IsRegister());
-  
-  // jiacheng start
-  // GenerateJiachengBarrier(LocationFrom(receiver));
-  // codegen_->GenerateJiachengBarrierRaw(invoke, LocationFrom(receiver));
-  // jiacheng end
 
   {
     // Ensure that between load and MaybeRecordImplicitNullCheck there are no pools emitted.
@@ -4288,11 +4253,6 @@ void CodeGeneratorARM64::GenerateVirtualCall(
   // concurrent copying collector may not in the future).
   GetAssembler()->MaybeUnpoisonHeapReference(temp.W());
 
-  // jiacheng start
-  // GenerateJiachengBarrier(LocationFrom(temp));
-  // codegen_->GenerateJiachengBarrierRaw(invoke, LocationFrom(temp));
-  // jiacheng end
-
   // temp = temp->GetMethodAt(method_offset);
   __ Ldr(temp, MemOperand(temp, method_offset));
   // lr = temp->GetEntryPoint();
@@ -5817,8 +5777,7 @@ void InstructionCodeGeneratorARM64::GenerateReferenceLoadOneRegister(
   Register out_reg = RegisterFrom(out, type);
 
   // jiacheng start
-  // codegen_->GenerateJiachengBarrier(LocationFrom(out_reg));
-  // codegen_->GenerateJiachengBarrierRaw(instruction, LocationFrom(out_reg));
+  codegen_->GenerateJiachengBarrierInline(out_reg);
   // jiacheng end
   
   if (read_barrier_option == kWithReadBarrier) {
@@ -5864,8 +5823,7 @@ void InstructionCodeGeneratorARM64::GenerateReferenceLoadTwoRegisters(
   Register obj_reg = RegisterFrom(obj, type);
 
   // jiacheng start
-  // codegen_->GenerateJiachengBarrier(LocationFrom(obj_reg));
-  // codegen_->GenerateJiachengBarrierRaw(instruction, LocationFrom(obj_reg));
+  codegen_->GenerateJiachengBarrierInline(obj_reg);
   // jiacheng end
 
   if (read_barrier_option == kWithReadBarrier) {
@@ -5905,8 +5863,7 @@ void CodeGeneratorARM64::GenerateGcRootFieldLoad(
   Register root_reg = RegisterFrom(root, DataType::Type::kReference);
 
   // jiacheng start
-  // GenerateJiachengBarrier(LocationFrom(obj));
-  // codegen_->GenerateJiachengBarrierRaw(instruction, LocationFrom(obj));
+  // GenerateJiachengBarrierInline(obj.X());
   // jiacheng end
 
   if (read_barrier_option == kWithReadBarrier) {
@@ -6246,6 +6203,18 @@ void CodeGeneratorARM64::GenerateReadBarrierForRootSlow(HInstruction* instructio
 }
 
 // jiacheng start
+void CodeGeneratorARM64::GenerateJiachengBarrierInline(Register obj) {
+  vixl::aarch64::Label done;
+
+  __ Cbz(obj, &done);
+
+  // UseScratchRegisterScope temps(GetVIXLAssembler());
+  // Register temp = temps.AcquireX(); // There is only one avaliable register
+
+  __ Bind(&done);
+}
+
+
 void CodeGeneratorARM64::GenerateJiachengBarrier(HInstruction* instruction, Location obj) {
   SlowPathCodeARM64* slow_path = new (GetScopedAllocator()) JiachengBarrierSlowPathARM64(instruction, obj);
   AddSlowPath(slow_path);
diff --git a/compiler/optimizing/code_generator_arm64.h b/compiler/optimizing/code_generator_arm64.h
index a996557bc1..5d47655cb4 100644
--- a/compiler/optimizing/code_generator_arm64.h
+++ b/compiler/optimizing/code_generator_arm64.h
@@ -766,6 +766,8 @@ class CodeGeneratorARM64 : public CodeGenerator {
   void GenerateReadBarrierForRootSlow(HInstruction* instruction, Location out, Location root);
 
   // jiacheng start
+  void GenerateJiachengBarrierInline(vixl::aarch64::Register obj);
+
   void GenerateJiachengBarrier(HInstruction* instruction, Location obj);
 
   void GenerateJiachengBarrierRaw(HInstruction* instruction, Location obj);
@@ -782,7 +784,6 @@ class CodeGeneratorARM64 : public CodeGenerator {
 
   void GenerateSaveRegisters(const std::vector<vixl::aarch64::CPURegister> & registersToSave);
   void GenerateRestoreRegisters(const std::vector<vixl::aarch64::CPURegister> & savedRegisters);
-
   // jiacheng end
 
   void GenerateNop() override;
diff --git a/runtime/Android.bp b/runtime/Android.bp
index d47d9ad609..054b91c37d 100644
--- a/runtime/Android.bp
+++ b/runtime/Android.bp
@@ -107,11 +107,7 @@ libart_cc_defaults {
         "java_frame_root_info.cc",
 // jiacheng start ------------------------------------
         "jiacheng_hack.cc",
-        "jiacheng_activity_manager.cc",
         "jiacheng_utils.cc",
-        "jiacheng_profiler.cc",
-        "jiacheng_swapper.cc",
-        "jiacheng_debug.cc",
         "jiacheng_barrier.cc",
 // jiacheng end --------------------------------------
         "jdwp/jdwp_event.cc",
diff --git a/runtime/arch/arm/quick_entrypoints_arm.S b/runtime/arch/arm/quick_entrypoints_arm.S
index b57e119fbe..9327134711 100644
--- a/runtime/arch/arm/quick_entrypoints_arm.S
+++ b/runtime/arch/arm/quick_entrypoints_arm.S
@@ -922,6 +922,10 @@ ENTRY art_quick_aput_obj
     ldr r3, [rSELF, #THREAD_CARD_TABLE_OFFSET]
     lsr r0, r0, #CARD_TABLE_CARD_SHIFT
     strb r3, [r3, r0]
+    // jiacheng start
+    ldr r3, [rSELF, #THREAD_CARD_TABLE2_OFFSET] // x3 = card table
+    strb r3, [r3, r0] // dirty card (the first byte of card table is DIRTY)
+    // jiacheng end
     blx lr
 .Ldo_aput_null:
     add r3, r0, #MIRROR_OBJECT_ARRAY_DATA_OFFSET
@@ -950,6 +954,10 @@ ENTRY art_quick_aput_obj
     ldr r3, [rSELF, #THREAD_CARD_TABLE_OFFSET]
     lsr r0, r0, #CARD_TABLE_CARD_SHIFT
     strb r3, [r3, r0]
+    // jiacheng start
+    ldr r3, [rSELF, #THREAD_CARD_TABLE2_OFFSET] // x3 = card table
+    strb r3, [r3, r0] // dirty card (the first byte of card table is DIRTY)
+    // jiacheng end
     blx lr
 .Lthrow_array_store_exception:
     pop {r0-r2, lr}
diff --git a/runtime/arch/arm64/quick_entrypoints_arm64.S b/runtime/arch/arm64/quick_entrypoints_arm64.S
index cb74ee81f2..a335bcfd61 100644
--- a/runtime/arch/arm64/quick_entrypoints_arm64.S
+++ b/runtime/arch/arm64/quick_entrypoints_arm64.S
@@ -1381,6 +1381,10 @@ ENTRY art_quick_aput_obj
     ldr x3, [xSELF, #THREAD_CARD_TABLE_OFFSET]
     lsr x0, x0, #CARD_TABLE_CARD_SHIFT
     strb w3, [x3, x0]
+    // jiacheng start
+    ldr x3, [xSELF, #THREAD_CARD_TABLE2_OFFSET] // x3 = card table
+    strb w3, [x3, x0] // dirty card (the first byte of card table is DIRTY)
+    // jiacheng end
     ret
 .Ldo_aput_null:
     add x3, x0, #MIRROR_OBJECT_ARRAY_DATA_OFFSET
@@ -1412,6 +1416,10 @@ ENTRY art_quick_aput_obj
     ldr x3, [xSELF, #THREAD_CARD_TABLE_OFFSET]
     lsr x0, x0, #CARD_TABLE_CARD_SHIFT
     strb w3, [x3, x0]
+    // jiacheng start
+    ldr x3, [xSELF, #THREAD_CARD_TABLE2_OFFSET] // x3 = card table
+    strb w3, [x3, x0] // dirty card (the first byte of card table is DIRTY)
+    // jiacheng end
     ret
     .cfi_restore_state            // Reset unwind info so following code unwinds.
     .cfi_def_cfa_offset 32        // workaround for clang bug: 31975598
@@ -1784,6 +1792,12 @@ ART_QUICK_ALLOC_OBJECT_ROSALLOC art_quick_alloc_object_initialized_rosalloc, art
     // TODO: Remove this dmb for class initialization checks (b/36692143) by introducing
     // a new observably-initialized class state.
 .endif
+    // jiacheng start
+    SETUP_SAVE_EVERYTHING_FRAME
+    bl allocationBarrierTrampoline
+    RESTORE_SAVE_EVERYTHING_FRAME
+    REFRESH_MARKING_REGISTER
+    // jiacheng end
     ret
 .endm
 
@@ -1852,6 +1866,13 @@ GENERATE_ALLOC_OBJECT_RESOLVED_TLAB art_quick_alloc_object_initialized_tlab, art
 
 // For publication of the new array, we don't need a 'dmb ishst' here.
 // The compiler generates 'dmb ishst' for all new-array insts.
+
+    // jiacheng start
+    SETUP_SAVE_EVERYTHING_FRAME
+    bl allocationBarrierTrampoline
+    RESTORE_SAVE_EVERYTHING_FRAME
+    REFRESH_MARKING_REGISTER
+    // jiacheng end
     ret
 .endm
 
diff --git a/runtime/entrypoints/quick/quick_entrypoints_list.h b/runtime/entrypoints/quick/quick_entrypoints_list.h
index 57b555955c..d785b79c53 100644
--- a/runtime/entrypoints/quick/quick_entrypoints_list.h
+++ b/runtime/entrypoints/quick/quick_entrypoints_list.h
@@ -204,6 +204,7 @@
   V(ReadBarrierForRootSlow, mirror::Object*, GcRoot<mirror::Object>*) \
   /* jiacheng start*/ \
   V(JiachengBarrier, void, uint64_t) \
+  V(AllocationNew, void, uint64_t) \
   /* jiacheng end */ \
 \
 
diff --git a/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc b/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc
index a2420afb69..a9d8365327 100644
--- a/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc
+++ b/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc
@@ -2923,4 +2923,11 @@ extern "C" uint64_t artInvokeCustom(uint32_t call_site_idx, Thread* self, ArtMet
   return result.GetJ();
 }
 
-}  // namespace art
+// jiacheng start
+extern "C" void allocationBarrierTrampoline(uint64_t obj) {
+  jiacheng::AllocationNewBarrier(obj);
+}
+// jiacheng end
+
+
+}  // namespace art
\ No newline at end of file
diff --git a/runtime/gc/accounting/card_table.h b/runtime/gc/accounting/card_table.h
index 5f4675d1cf..110bdd77d7 100644
--- a/runtime/gc/accounting/card_table.h
+++ b/runtime/gc/accounting/card_table.h
@@ -173,6 +173,17 @@ class AgeCardVisitor {
   }
 };
 
+// jiacheng 
+class AgeCardWithoutClearVisitor {
+ public:
+  uint8_t operator()(uint8_t card) const {
+    return (card == accounting::CardTable::kCardDirty || 
+            card == accounting::CardTable::kCardAged) ? 
+            card == accounting::CardTable::kCardAged : 0;
+  }
+};
+// jiacheng 
+
 }  // namespace gc
 }  // namespace art
 
diff --git a/runtime/gc/accounting/mod_union_table.cc b/runtime/gc/accounting/mod_union_table.cc
index b4026fc3f3..8c0d2c9f5e 100644
--- a/runtime/gc/accounting/mod_union_table.cc
+++ b/runtime/gc/accounting/mod_union_table.cc
@@ -478,6 +478,7 @@ void ModUnionTableReferenceCache::UpdateAndMarkReferences(MarkObjectVisitor* vis
   }
 }
 
+
 ModUnionTableCardCache::ModUnionTableCardCache(const std::string& name,
                                                Heap* heap,
                                                space::ContinuousSpace* space)
diff --git a/runtime/gc/collector/concurrent_copying-inl.h b/runtime/gc/collector/concurrent_copying-inl.h
index 691ffb1d88..39d723dde4 100644
--- a/runtime/gc/collector/concurrent_copying-inl.h
+++ b/runtime/gc/collector/concurrent_copying-inl.h
@@ -29,8 +29,7 @@
 #include "mirror/object-readbarrier-inl.h"
 
 // jiacheng start  
-#include "jiacheng_hack.h"
-#include "jiacheng_profiler.h"
+#include "jiacheng_utils.h"
 // jiacheng end
 
 namespace art {
@@ -157,18 +156,10 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
     return from_ref;
   }
   DCHECK(region_space_ != nullptr) << "Read barrier slow path taken when CC isn't running?";
-  // jiahceng start -------------------------------------_
-    // if (jiacheng::ColdSpace::Current()->HasAddress(from_ref)) {
-    //   // Mark在ColdSpace中的对象，把该对象标灰
-    //   // bool success = from_ref->AtomicSetReadBarrierState(ReadBarrier::WhiteState(), ReadBarrier::GrayState());
-    //   bool success = from_ref->AtomicSetReadBarrierState(ReadBarrier::NonGrayState(), ReadBarrier::GrayState());
-    //   if (success) {
-    //     PushOntoMarkStack(self, from_ref);
-    //   }
-    //   return from_ref;
-    // }  else if (region_space_->HasAddress(from_ref)) {
+  // jiacheng start
+  mark_num_.fetch_add(1, std::memory_order_relaxed);
+  // jiacheng end
   if (region_space_->HasAddress(from_ref)) {
-  // jiacheng end -------------------------------------
     space::RegionSpace::RegionType rtype = region_space_->GetRegionTypeUnsafe(from_ref);
     switch (rtype) {
       case space::RegionSpace::RegionType::kRegionTypeToSpace:
@@ -180,12 +171,6 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
           // It isn't marked yet. Mark it by copying it to the to-space.
           to_ref = Copy(self, from_ref, holder, offset);
         }
-        // jiacheng start
-        // jiacheng::Profiler* profiler = jiacheng::Profiler::Current();
-        // if (to_ref != from_ref && profiler->TestInAccessWS(from_ref)) {
-        //   profiler->RecordAccessWS(to_ref);
-        // }
-        // jiacheng end
         // The copy should either be in a to-space region, or in the
         // non-moving space, if it could not fit in a to-space region.
         DCHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
@@ -201,24 +186,6 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
         }
         return MarkUnevacFromSpaceRegion(self, from_ref, region_space_bitmap_);
       }
-      // jiacheng start
-      case space::RegionSpace::RegionType::kRegionTypeColdToSpace: {
-        // Already marked
-        return from_ref;
-      }
-      case space::RegionSpace::RegionType::kRegionTypeColdSpace: {
-        return MarkColdSpaceRegion(self, from_ref, region_space_bitmap_);
-      }
-      case space::RegionSpace::RegionType::kRegionTypeHotSpace: {
-        if (kNoUnEvac && use_generational_cc_ && !region_space_->IsLargeObject(from_ref)) {
-          if (!kFromGCThread) {
-            DCHECK(IsMarkedInUnevacFromSpace(from_ref)) << "Returning unmarked object to mutator";
-          }
-          return from_ref;
-        }
-        return MarkUnevacFromSpaceRegion(self, from_ref, region_space_bitmap_);
-      }
-      // jiacheng end
       default:
         // The reference is in an unused region. Remove memory protection from
         // the region space and log debugging information.
@@ -238,6 +205,9 @@ inline mirror::Object* ConcurrentCopying::Mark(Thread* const self,
 }
 
 inline mirror::Object* ConcurrentCopying::MarkFromReadBarrier(mirror::Object* from_ref) {
+  // jiacheng start
+  read_barrier_num_.fetch_add(1, std::memory_order_relaxed);
+  // jiacheng end
   mirror::Object* ret;
   Thread* const self = Thread::Current();
   // We can get here before marking starts since we gray immune objects before the marking phase.
diff --git a/runtime/gc/collector/concurrent_copying.cc b/runtime/gc/collector/concurrent_copying.cc
index 11ced05e50..08ad6906d0 100644
--- a/runtime/gc/collector/concurrent_copying.cc
+++ b/runtime/gc/collector/concurrent_copying.cc
@@ -48,7 +48,6 @@
 #include "well_known_classes.h"
 
 // jiacheng start
-#include "jiacheng_profiler.h"
 #include "jiacheng_utils.h"
 #include <iostream>
 // jiacheng end
@@ -74,39 +73,6 @@ static constexpr size_t kSweepArrayChunkFreeSize = 1024;
 static constexpr bool kVerifyNoMissingCardMarks = kIsDebugBuild;
 
 
-// jiacheng start
-class ConcurrentCopying::RegionRememberedObjectsVisitor {
- public:
-  explicit RegionRememberedObjectsVisitor(ConcurrentCopying* cc) : collector_(cc) {}
-
-  ALWAYS_INLINE void operator()(mirror::Object* ref) const REQUIRES_SHARED(Locks::mutator_lock_) {
-    if (ref == nullptr) {
-      return;
-    }
-    if (!collector_->TestAndSetMarkBitForRef(ref)) {
-      collector_->PushOntoLocalMarkStack(ref);
-    }
-  }
-
- private:
-  ConcurrentCopying* const collector_;
-};
-
-class ConcurrentCopying::RegionRememberedObjectsAsRootVisitor {
- public:
-  explicit RegionRememberedObjectsAsRootVisitor(ConcurrentCopying* cc) : collector_(cc) {}
-
-  ALWAYS_INLINE mirror::Object* operator()(mirror::Object* ref) const REQUIRES_SHARED(Locks::mutator_lock_) {
-    // LOG(INFO) << "jiacheng concurrent_copying.cc 100 ref= " << size_t(ref);
-    return collector_->MarkObject(ref);
-  }
-
- private:
-  ConcurrentCopying* const collector_;
-};
-// jiacheng end
-
-
 ConcurrentCopying::ConcurrentCopying(Heap* heap,
                                      bool young_gen,
                                      bool use_generational_cc,
@@ -122,6 +88,9 @@ ConcurrentCopying::ConcurrentCopying(Heap* heap,
                                                      kDefaultGcMarkStackSize)),
       use_generational_cc_(use_generational_cc),
       young_gen_(young_gen),
+      // jiacheng start
+      background_gen_(false),
+      // jiacheng end
       rb_mark_bit_stack_(accounting::ObjectStack::Create("rb copying gc mark stack",
                                                          kReadBarrierMarkStackSize,
                                                          kReadBarrierMarkStackSize)),
@@ -231,13 +200,72 @@ void ConcurrentCopying::RunPhases() {
   is_active_ = true;
   Thread* self = Thread::Current();
   thread_running_gc_ = self;
+
+  // jiacheng start
+  bool is_white_app = jiacheng::IsWhiteApp();
+  Iteration* current_iteration = GetCurrentIteration();
+  heap_->SetDuringGcFlag(true);
+  SetDepth(0);
+  gc_cause_ = GetCurrentIteration()->GetGcCause();
+
+  background_gen_ = jiacheng::ENABLE_BGC &&
+                    is_white_app && 
+                    !young_gen_ &&
+                    gc_cause_ != kGcCauseRelocateHotness &&
+                    heap_->GetDoneRelocateHotness();
+
+  copy_launch_object_num_.store(0, std::memory_order_relaxed);
+  copy_cold_object_num_.store(0, std::memory_order_relaxed);
+  mark_num_.store(0, std::memory_order_relaxed);
+  mark_from_read_barrier_num_.store(0, std::memory_order_relaxed);
+  scan_num_.store(0, std::memory_order_relaxed);
+  copy_num_.store(0, std::memory_order_relaxed);
+  copy_from_barrier_num_.store(0, std::memory_order_relaxed);
+  push_on_mark_stack_num_.store(0, std::memory_order_relaxed);
+  read_barrier_num_.store(0, std::memory_order_relaxed);
+
+  if (is_white_app) {
+    LOG(INFO) << "jiacheng ConcurrentCopying::Runphases() Start"
+              << " NanoTime()= " << NanoTime()
+              << " GetGcType()= " << GetGcType()
+              << " current_iteration->GetGcCause()= " << current_iteration->GetGcCause()
+              << " current_iteration->GetClearSoftReferences()= " << current_iteration->GetClearSoftReferences()
+              << " force_evacuate_all_= " << force_evacuate_all_
+              << " background_gen_= " << background_gen_
+              << " young_gen_= " << young_gen_
+              << " current_iteration->GetFreedObjects()= " << current_iteration->GetFreedObjects()
+              << " current_iteration->GetFreedLargeObjects()= " << current_iteration->GetFreedLargeObjects() 
+              << " current_iteration->GetFreedBytes()(MB)= " << current_iteration->GetFreedBytes()/MB
+              << " region_space->GetObjectsAllocated()= " << heap_->GetRegionSpace()->GetObjectsAllocated()
+              << " region_space->GetBytesAllocated()= " << heap_->GetRegionSpace()->GetBytesAllocated()/MB
+              << " mark_num_= " << mark_num_.load(std::memory_order_relaxed)
+              << " mark_from_read_barrier_num_= " << mark_from_read_barrier_num_.load(std::memory_order_relaxed)
+              << " scan_num_= " << scan_num_.load(std::memory_order_relaxed)
+              << " copy_num_= " << copy_num_.load(std::memory_order_relaxed)
+              << " copy_from_barrier_num_= " << copy_from_barrier_num_.load(std::memory_order_relaxed)
+              << " push_on_mark_stack_num_= " << push_on_mark_stack_num_.load(std::memory_order_relaxed)
+              << " read_barrier_num_= " << read_barrier_num_.load(std::memory_order_relaxed)
+              << " copy_launch_object_num_= " << copy_launch_object_num_.load(std::memory_order_relaxed)
+              << " copy_cold_object_num_= " << copy_cold_object_num_.load(std::memory_order_relaxed)
+              << " depth_= " << GetDepth()
+              ;
+    region_space_->Debug();
+    heap_->GetNonMovingSpace()->Debug();
+    heap_->GetLargeObjectsSpace()->Debug();
+  }
+  // jiacheng end
+
   Locks::mutator_lock_->AssertNotHeld(self);
   {
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
     InitializePhase();
     // In case of forced evacuation, all regions are evacuated and hence no
     // need to compute live_bytes.
-    if (use_generational_cc_ && !young_gen_ && !force_evacuate_all_) {
+
+    // jiacheng start
+    // if (use_generational_cc_ && !young_gen_ && !force_evacuate_all_) {
+    if (use_generational_cc_ && !young_gen_ && !background_gen_ && !force_evacuate_all_) {
+    // jiacheng end
       MarkingPhase();
     }
   }
@@ -250,18 +278,6 @@ void ConcurrentCopying::RunPhases() {
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
     GrayAllDirtyImmuneObjects();
   }
-  // jiacheng start
-  {
-    LOG(INFO) << "jiacheng concurrent_copying.cc 220";
-    ReaderMutexLock mu(self, *Locks::mutator_lock_);
-    RegionRememberedObjectsAsRootVisitor root_visitor(this);
-    region_space_->VisitRememberedObjectsAsRoot(root_visitor);
-    // TODO remove
-    RegionRememberedObjectsVisitor visitor(this);
-    region_space_->VisitRememberedObjects(visitor);
-  }
-  // jiacheng end
-
   FlipThreadRoots();
   {
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
@@ -284,11 +300,49 @@ void ConcurrentCopying::RunPhases() {
   {
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
     ReclaimPhase();
+    // jiacheng start
+    if (gc_cause_ == kGcCauseRelocateHotness) {
+      RemoveDepthDelimiterFromMarkStack(self);
+    }
+    // jiacheng end
   }
+
   FinishPhase();
   CHECK(is_active_);
   is_active_ = false;
   thread_running_gc_ = nullptr;
+  // jiacheng start
+  if (is_white_app) {
+    region_space_->Debug();
+    heap_->GetNonMovingSpace()->Debug();
+    heap_->GetLargeObjectsSpace()->Debug();
+    LOG(INFO) << "jiacheng ConcurrentCopying::Runphases() End"
+              << " NanoTime()= " << NanoTime()
+              << " GetGcType()= " << GetGcType()
+              << " current_iteration->GetGcCause()= " << current_iteration->GetGcCause()
+              << " current_iteration->GetClearSoftReferences()= " << current_iteration->GetClearSoftReferences()
+              << " force_evacuate_all_= " << force_evacuate_all_
+              << " background_gen_= " << background_gen_
+              << " young_gen_= " << young_gen_
+              << " current_iteration->GetFreedObjects()= " << current_iteration->GetFreedObjects()
+              << " current_iteration->GetFreedLargeObjects()= " << current_iteration->GetFreedLargeObjects() 
+              << " current_iteration->GetFreedBytes()(MB)= " << current_iteration->GetFreedBytes()/MB
+              << " region_space->GetObjectsAllocated()= " << heap_->GetRegionSpace()->GetObjectsAllocated()
+              << " region_space->GetBytesAllocated()= " << heap_->GetRegionSpace()->GetBytesAllocated()/MB
+              << " mark_num_= " << mark_num_.load(std::memory_order_relaxed)
+              << " mark_from_read_barrier_num_= " << mark_from_read_barrier_num_.load(std::memory_order_relaxed)
+              << " scan_num_= " << scan_num_.load(std::memory_order_relaxed)
+              << " copy_num_= " << copy_num_.load(std::memory_order_relaxed)
+              << " copy_from_barrier_num_= " << copy_from_barrier_num_.load(std::memory_order_relaxed)
+              << " push_on_mark_stack_num_= " << push_on_mark_stack_num_.load(std::memory_order_relaxed)
+              << " read_barrier_num_= " << read_barrier_num_.load(std::memory_order_relaxed)
+              << " copy_launch_object_num_= " << copy_launch_object_num_.load(std::memory_order_relaxed)
+              << " copy_cold_object_num_= " << copy_cold_object_num_.load(std::memory_order_relaxed)
+              << " depth_= " << GetDepth()
+              ;
+  }
+  heap_->SetDuringGcFlag(false);
+  // jiacheng end
 }
 
 class ConcurrentCopying::ActivateReadBarrierEntrypointsCheckpoint : public Closure {
@@ -393,6 +447,9 @@ void ConcurrentCopying::BindBitmaps() {
                                                    space->End(),
                                                    AgeCardVisitor(),
                                                    VoidFunctor());
+        // jiacheng start
+        } else if (background_gen_) {
+        // jiacheng end
         } else {
           // In a full-heap GC cycle, the card-table corresponding to region-space and
           // non-moving space can be cleared, because this cycle only needs to
@@ -402,7 +459,12 @@ void ConcurrentCopying::BindBitmaps() {
           // be captured after the thread-flip of this GC cycle, as that is when
           // the young-gen for the next GC cycle starts getting populated.
           heap_->GetCardTable()->ClearCardRange(space->Begin(), space->Limit());
+          
+          // jiacheng start
+          heap_->GetCardTable2()->ClearCardRange(space->Begin(), space->Limit());
+          // jiacheng end
         }
+
       } else {
         if (space == region_space_) {
           // It is OK to clear the bitmap with mutators running since the only place it is read is
@@ -419,6 +481,17 @@ void ConcurrentCopying::BindBitmaps() {
       space->AsLargeObjectSpace()->CopyLiveToMarked();
     }
   }
+  // jiacheng start
+  if (background_gen_) {
+    region_space_->CopyForegroundToMarked();
+
+    heap_->GetNonMovingSpace()->AsDlMallocSpace()->CopyForegroundToMarked();
+
+    for (const auto& space : GetHeap()->GetDiscontinuousSpaces()) {
+      space->AsLargeObjectSpace()->CopyForegroundToMarked();
+    }
+  }
+  // jiacheng end
 }
 
 void ConcurrentCopying::InitializePhase() {
@@ -443,16 +516,32 @@ void ConcurrentCopying::InitializePhase() {
   objects_moved_.store(0, std::memory_order_relaxed);
   bytes_moved_gc_thread_ = 0;
   objects_moved_gc_thread_ = 0;
-  GcCause gc_cause = GetCurrentIteration()->GetGcCause();
-
+  // jiacheng start
+  // GcCause gc_cause = GetCurrentIteration()->GetGcCause();
+  // jiachegn end
   force_evacuate_all_ = false;
-  if (!use_generational_cc_ || !young_gen_) {
-    if (gc_cause == kGcCauseExplicit ||
-        gc_cause == kGcCauseCollectorTransition ||
+
+  // jiacheng start
+  // if (!use_generational_cc_ || !young_gen_) {
+  //   if (gc_cause == kGcCauseExplicit ||
+  //       gc_cause == kGcCauseCollectorTransition ||
+  //       GetCurrentIteration()->GetClearSoftReferences()) {
+  //     force_evacuate_all_ = true;
+  //   }
+  // }
+  if (!use_generational_cc_ || (!young_gen_ && !background_gen_)) {
+    if (gc_cause_ == kGcCauseExplicit ||
+        gc_cause_ == kGcCauseCollectorTransition ||
+        gc_cause_ == kGcCauseRelocateHotness ||
         GetCurrentIteration()->GetClearSoftReferences()) {
       force_evacuate_all_ = true;
     }
   }
+  if (jiacheng::IsWhiteApp()) {
+    LOG(INFO) << "jiacheng force_evacuate_all_= " << force_evacuate_all_;
+  }
+  // jiacheng end
+  
   if (kUseBakerReadBarrier) {
     updated_all_immune_objects_.store(false, std::memory_order_relaxed);
     // GC may gray immune objects in the thread flip.
@@ -476,7 +565,10 @@ void ConcurrentCopying::InitializePhase() {
     }
     LOG(INFO) << "GC end of InitializePhase";
   }
-  if (use_generational_cc_ && !young_gen_) {
+  // jiacheng start
+  // if (use_generational_cc_ && !young_gen_) {
+  if (use_generational_cc_ && !young_gen_ && !background_gen_) {
+  // jiacheng end
     region_space_bitmap_->Clear();
   }
   mark_stack_mode_.store(ConcurrentCopying::kMarkStackModeThreadLocal, std::memory_order_relaxed);
@@ -573,6 +665,11 @@ class ConcurrentCopying::FlipCallback : public Closure {
     if (kVerifyNoMissingCardMarks && cc->young_gen_) {
       cc->VerifyNoMissingCardMarks();
     }
+    // jiacheng start
+    else if (kVerifyNoMissingCardMarks && cc->background_gen_) {
+      cc->VerifyNoMissingCardMarks();
+    }
+    // jiacheng end
     CHECK_EQ(thread, self);
     Locks::mutator_lock_->AssertExclusiveHeld(self);
     space::RegionSpace::EvacMode evac_mode = space::RegionSpace::kEvacModeLivePercentNewlyAllocated;
@@ -582,6 +679,13 @@ class ConcurrentCopying::FlipCallback : public Closure {
     } else if (cc->force_evacuate_all_) {
       evac_mode = space::RegionSpace::kEvacModeForceAll;
     }
+    // jiacheng start
+    else if (cc->background_gen_) {
+      evac_mode = space::RegionSpace::kEvacModeBackgroundGen;
+      // delete it
+      // evac_mode = space::RegionSpace::kEvacModeNewlyAllocated;
+    }
+    // jiacheng end
     {
       TimingLogger::ScopedTiming split2("(Paused)SetFromSpace", cc->GetTimings());
       // Only change live bytes for 1-phase full heap CC.
@@ -782,9 +886,6 @@ void ConcurrentCopying::VerifyNoMissingCardMarks() {
 
 // Switch threads that from from-space to to-space refs. Forward/mark the thread roots.
 void ConcurrentCopying::FlipThreadRoots() {
-  // jiacheng start
-  LOG(INFO) << "jiacheng debug concurrent_copying.cc 786 FlipThreadRoots()";
-  // jiacehng end
   TimingLogger::ScopedTiming split("FlipThreadRoots", GetTimings());
   if (kVerboseMode || heap_->dump_region_info_before_gc_) {
     LOG(INFO) << "time=" << region_space_->Time();
@@ -840,9 +941,6 @@ class ConcurrentCopying::GrayImmuneObjectVisitor {
 };
 
 void ConcurrentCopying::GrayAllDirtyImmuneObjects() {
-  // jiacheng start
-  LOG(INFO) << "jiacheng debug concurrent_copying.cc 841 GrayAllDirtyImmuneObjects()";
-  // jiacehng end
   TimingLogger::ScopedTiming split("GrayAllDirtyImmuneObjects", GetTimings());
   accounting::CardTable* const card_table = heap_->GetCardTable();
   Thread* const self = Thread::Current();
@@ -880,6 +978,50 @@ void ConcurrentCopying::GrayAllDirtyImmuneObjects() {
                                               gc::accounting::CardTable::kCardAged);
     }
   }
+  // jiacheng start
+  if (background_gen_) {
+    for (const auto& space : heap_->GetContinuousSpaces()) {
+      if (space->IsImageSpace() || space->IsZygoteSpace()) {
+        continue;
+      }
+      CHECK(space == region_space_ || space == heap_->non_moving_space_);
+      heap_->GetCardTable2()->ModifyCardsAtomic(
+        space->Begin(), 
+        space->End(),
+        [](uint8_t card) {
+          return (card != gc::accounting::CardTable::kCardClean)
+              ? gc::accounting::CardTable::kCardAged
+              : card;
+        },
+        VoidFunctor());
+
+      heap_->GetCardTable2()->Scan</*kClearCard=*/ false>(
+        space->GetMarkBitmap(),
+        space->Begin(),
+        space->End(),
+        visitor,
+        gc::accounting::CardTable::kCardAged);
+    }
+    // for (const auto& space : heap_->GetDiscontinuousSpaces()) {
+    //   heap_->GetCardTable2()->ModifyCardsAtomic(
+    //     space->Begin(), 
+    //     space->End(),
+    //     [](uint8_t card) {
+    //       return (card != gc::accounting::CardTable::kCardClean)
+    //           ? gc::accounting::CardTable::kCardAged
+    //           : card;
+    //     },
+    //     VoidFunctor());
+
+    //   heap_->GetCardTable2()->Scan</*kClearCard=*/ false>(
+    //     space->GetMarkBitmap(),
+    //     space->Begin(),
+    //     space->End(),
+    //     visitor,
+    //     gc::accounting::CardTable::kCardAged);
+    // }
+  }
+  // jiacheng end
 }
 
 void ConcurrentCopying::GrayAllNewlyDirtyImmuneObjects() {
@@ -931,6 +1073,11 @@ inline void ConcurrentCopying::ScanImmuneObject(mirror::Object* obj) {
     // Young GC does not care about references to unevac space. It is safe to not gray these as
     // long as scan immune objects happens after scanning the dirty cards.
     Scan<true>(obj);
+  // jiacheng start
+  } else if (background_gen_) {
+    // Scan</*kNoUnEvac*/true>(obj);
+    Scan</*kNoUnEvac*/false>(obj);
+  // jiacheng end
   } else {
     Scan<false>(obj);
   }
@@ -1167,17 +1314,9 @@ class ConcurrentCopying::ComputeLiveBytesAndMarkRefFieldsVisitor {
 };
 
 void ConcurrentCopying::AddLiveBytesAndScanRef(mirror::Object* ref) {
-  // jiacheng start
-  // DCHECK(ref != nullptr);
-  // DCHECK(!immune_spaces_.ContainsObject(ref));
-  // DCHECK(TestMarkBitmapForRef(ref));
-  CHECK(ref != nullptr);
-  CHECK(!immune_spaces_.ContainsObject(ref));
-  CHECK(TestMarkBitmapForRef(ref));
-  if (reinterpret_cast<size_t>(ref) < 0xffff) {
-    return;
-  }
-  // jiacheng end
+  DCHECK(ref != nullptr);
+  DCHECK(!immune_spaces_.ContainsObject(ref));
+  DCHECK(TestMarkBitmapForRef(ref));
   size_t obj_region_idx = static_cast<size_t>(-1);
   if (LIKELY(region_space_->HasAddress(ref))) {
     obj_region_idx = region_space_->RegionIdxForRefUnchecked(ref);
@@ -1302,6 +1441,9 @@ class ConcurrentCopying::ImmuneSpaceCaptureRefsVisitor {
   ALWAYS_INLINE void operator()(mirror::Object* obj) const REQUIRES_SHARED(Locks::mutator_lock_) {
     ComputeLiveBytesAndMarkRefFieldsVisitor</*kHandleInterRegionRefs*/ false>
         visitor(collector_, /*obj_region_idx*/ static_cast<size_t>(-1));
+    // jiacheng start
+    collector_->heap_->AddWs(obj);
+    // jiacheng end
     obj->VisitReferences</*kVisitNativeRoots=*/true, kDefaultVerifyFlags, kWithoutReadBarrier>(
         visitor, visitor);
   }
@@ -1376,13 +1518,16 @@ class ConcurrentCopying::ImmuneSpaceCaptureRefsVisitor {
 */
 
 void ConcurrentCopying::MarkingPhase() {
-  // jiacheng start
-  LOG(INFO) << "jiacheng debug concurrent_copying.cc 1374 MarkingPhase()";
-  // jiacheng end
   TimingLogger::ScopedTiming split("MarkingPhase", GetTimings());
   if (kVerboseMode) {
     LOG(INFO) << "GC MarkingPhase";
   }
+  // jiacheng start
+  if (jiacheng::IsWhiteApp()) {
+    LOG(INFO) << "jiacheng ConcurrentCopying::MarkingPhase()"
+              << " GetPerceptibleFlag()= " << heap_->GetPerceptibleFlag();
+  }
+  // jiacheng end
   accounting::CardTable* const card_table = heap_->GetCardTable();
   Thread* const self = Thread::Current();
   // Clear live_bytes_ of every non-free region, except the ones that are newly
@@ -1427,18 +1572,6 @@ void ConcurrentCopying::MarkingPhase() {
   // Capture thread roots
   CaptureThreadRootsForMarking();
 
-  // jiacheng start
-  {
-    TimingLogger::ScopedTiming split2("VisitRegionRememberedSet", GetTimings());
-    LOG(INFO) << "jiacheng concurrent_copying.cc 1394";
-    RegionRememberedObjectsAsRootVisitor root_visitor(this);
-    region_space_->VisitRememberedObjectsAsRoot(root_visitor);
-    // TODO remove
-    RegionRememberedObjectsVisitor visitor(this);
-    region_space_->VisitRememberedObjects(visitor);
-  }
-  // jiacheng end
-
   // Process mark stack
   ProcessMarkStackForMarkingAndComputeLiveBytes();
 
@@ -1464,9 +1597,6 @@ void ConcurrentCopying::ScanDirtyObject(mirror::Object* obj) {
 
 // Concurrently mark roots that are guarded by read barriers and process the mark stack.
 void ConcurrentCopying::CopyingPhase() {
-  // jiacheng start
-  LOG(INFO) << "jiacheng debug concurrent_copying.cc 1468 CopyingPhase()";
-  // jiacheng end
   TimingLogger::ScopedTiming split("CopyingPhase", GetTimings());
   if (kVerboseMode) {
     LOG(INFO) << "GC CopyingPhase";
@@ -1515,7 +1645,10 @@ void ConcurrentCopying::CopyingPhase() {
       //   which is an immune space.
       // - In the case where we run without a boot image, these classes are allocated in the
       //   non-moving space (see art::ClassLinker::InitWithoutImage).
-      card_table->Scan<false>(
+      // jiacheng start
+      // card_table->Scan<false>(
+      uint32_t card_scan_num1 = card_table->Scan<false>(
+      // jiacheng end
           space->GetMarkBitmap(),
           space->Begin(),
           space->End(),
@@ -1539,6 +1672,10 @@ void ConcurrentCopying::CopyingPhase() {
                 }
               }
               ScanDirtyObject</*kNoUnEvac*/ true>(obj);
+            // jiacheng start
+            // } else if (background_gen_) { // TODO
+              // don't do anything
+            // jiacheng end
             } else if (space != region_space_) {
               DCHECK(space == heap_->non_moving_space_);
               // We need to process un-evac references as they may be unprocessed,
@@ -1552,7 +1689,16 @@ void ConcurrentCopying::CopyingPhase() {
           },
           accounting::CardTable::kCardAged);
 
-      if (!young_gen_) {
+      // jiacheng start
+      if (jiacheng::IsWhiteApp()) {
+        LOG(INFO) << "jiacheng CopyingPhase() card_scan_num1= " << card_scan_num1;
+      }
+      // jiacheng end
+
+      // jiacheng start
+      // if (!young_gen_) {
+      if (!young_gen_ && !background_gen_) {
+      // jiacheng end
         auto visitor = [this](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_) {
                          // We don't need to process un-evac references as any unprocessed
                          // ones will be taken care of in the card-table scan above.
@@ -1568,6 +1714,7 @@ void ConcurrentCopying::CopyingPhase() {
               visitor);
         }
       }
+
     }
     // Done scanning unevac space.
     done_scanning_.store(true, std::memory_order_release);
@@ -1577,17 +1724,49 @@ void ConcurrentCopying::CopyingPhase() {
       LOG(INFO) << "GC end of ScanCardsForSpace";
     }
   }
+
   // jiacheng start
-  {
-    LOG(INFO) << "jiacheng concurrent_copying.cc 1570";
-    RegionRememberedObjectsAsRootVisitor root_visitor(this);
-    region_space_->VisitRememberedObjectsAsRoot(root_visitor);
-    // TODO remove
-    RegionRememberedObjectsVisitor visitor(this);
-    region_space_->VisitRememberedObjects(visitor);
+  if (background_gen_) {
+    TimingLogger::ScopedTiming split2("ScanForegroundSpaces", GetTimings());
+
+    WriterMutexLock rmu(Thread::Current(), *Locks::heap_bitmap_lock_);
+    for (const auto& space : heap_->GetContinuousSpaces()) {
+      if (space->IsImageSpace() || space->IsZygoteSpace()) {
+        continue;
+      }
+      CHECK(space == region_space_ || space == heap_->non_moving_space_);
+      ImmuneSpaceScanObjVisitor visitor(this);
+      uint32_t card_scan_num2 = heap_->GetCardTable2()->Scan</*kClearCard=*/ false>(
+        space->GetMarkBitmap(),
+        space->Begin(),
+        space->End(),
+        visitor,
+        gc::accounting::CardTable::kCardAged);
+      if (jiacheng::IsWhiteApp()) {
+        LOG(INFO) << "jiacheng CopyingPhase() card_scan_num2= " << card_scan_num2;
+      }
+    }
+
+    // Don't need this
+    // for (const auto& space : heap_->GetContinuousSpaces()) {
+    //   if (space->IsImageSpace() || space->IsZygoteSpace()) {
+    //     continue;
+    //   }
+    //   CHECK(space == region_space_ || space == heap_->non_moving_space_);
+    //   ImmuneSpaceScanObjVisitor visitor(this);
+    //   space->GetMarkBitmap()->VisitMarkedRange(
+    //       reinterpret_cast<uintptr_t>(space->Begin()), 
+    //       reinterpret_cast<uintptr_t>(space->End()), 
+    //       visitor);
+    // }
+
+    // Don't need this
+    // for (const auto& space : heap_->GetDiscontinuousSpaces()) {
+    //   ImmuneSpaceScanObjVisitor visitor(this);
+    //   space->GetMarkBitmap()->VisitAllMarked(visitor);
+    // }
   }
   // jiacheng end
-
   {
     // For a sticky-bit collection, this phase needs to be after the card scanning since the
     // mutator may read an unevac space object out of an image object. If the image object is no
@@ -1646,7 +1825,15 @@ void ConcurrentCopying::CopyingPhase() {
     TimingLogger::ScopedTiming split5("VisitNonThreadRoots", GetTimings());
     Runtime::Current()->VisitNonThreadRoots(this);
   }
-
+  // jiacheng start
+  if (gc_cause_ == kGcCauseRelocateHotness) {
+    PushDepthDelimiterOntoMarkStack(self);
+    LOG(INFO) << "jiacheng ProcessMarkStackOnce() Before"
+              << " push_on_mark_stack_num_= " << push_on_mark_stack_num_.load(std::memory_order_relaxed)
+              << " depth= " << GetDepth();
+    IncDepth(); 
+  }
+  // jiacheng end
   {
     TimingLogger::ScopedTiming split7("ProcessMarkStack", GetTimings());
     // We transition through three mark stack modes (thread-local, shared, GC-exclusive). The
@@ -1844,6 +2031,9 @@ void ConcurrentCopying::PushOntoMarkStack(Thread* const self, mirror::Object* to
   CHECK_EQ(is_mark_stack_push_disallowed_.load(std::memory_order_relaxed), 0)
       << " " << to_ref << " " << mirror::Object::PrettyTypeOf(to_ref);
   CHECK(thread_running_gc_ != nullptr);
+  // jiacheng start
+  push_on_mark_stack_num_.fetch_add(1, std::memory_order_relaxed);
+  // jiacheng end
   MarkStackMode mark_stack_mode = mark_stack_mode_.load(std::memory_order_relaxed);
   if (LIKELY(mark_stack_mode == kMarkStackModeThreadLocal)) {
     if (LIKELY(self == thread_running_gc_)) {
@@ -2140,12 +2330,66 @@ bool ConcurrentCopying::ProcessMarkStackOnce() {
                                               REQUIRES_SHARED(Locks::mutator_lock_) {
                                             ProcessMarkStackRef(ref);
                                           });
-    while (!gc_mark_stack_->IsEmpty()) {
-      mirror::Object* to_ref = gc_mark_stack_->PopBack();
-      ProcessMarkStackRef(to_ref);
-      ++count;
+
+    // jiacheng start
+    // For thread local stacks, we use the same current depth for gc mark stack. 
+    // Because it is only for the hotness relocation gc, there is few read barrier when the app is in the background.
+    // jiacheng end
+
+    // jiacheng start
+    // while (!gc_mark_stack_->IsEmpty()) {
+    //   mirror::Object* to_ref = gc_mark_stack_->PopBack();
+    //   ProcessMarkStackRef(to_ref);
+    //   ++count;
+    // }
+    // gc_mark_stack_->Reset();
+    
+    if (gc_cause_ == kGcCauseRelocateHotness) {
+      // we could not use gc_mark_stack_->PopFront(), because it is a mmap space
+      // TODO: change gc_mark_stack_ to a queue
+      std::vector<mirror::Object*> refs;
+      while (true) {
+        refs.clear();
+        {
+          // Mutator threads will push ref into their their local stack
+          // There is NO other thread touching the gc_mark_stack_
+          // So we don't need lock
+          // MutexLock mu(thread_running_gc_, mark_stack_lock_); 
+          if (gc_mark_stack_->Size() == 1) {
+            break;
+          }
+          for (StackReference<mirror::Object>* p = gc_mark_stack_->Begin();
+              p != gc_mark_stack_->End(); ++p) {
+            refs.push_back(p->AsMirrorPtr());
+          }
+          gc_mark_stack_->Reset();
+        }
+        // we will stop when meetting the first element here
+        // becaue the first element is the delimiter
+        // BFS
+        for (mirror::Object* ref : refs) {
+          if (static_cast<uint32_t>(reinterpret_cast<uint64_t>(ref)) == kDepthDelimiter) {
+            LOG(INFO) << "jiacheng ProcessMarkStackOnce() kMarkStackModeThreadLocal"
+                      << " push_on_mark_stack_num_= " << push_on_mark_stack_num_.load(std::memory_order_relaxed)
+                      << " depth= " << GetDepth();
+            IncDepth();
+            PushDepthDelimiterOntoMarkStack(self);
+          } else {
+            ProcessMarkStackRef(ref);
+            ++count;
+          }
+        }
+
+      }
+    } else {
+      while (!gc_mark_stack_->IsEmpty()) {
+        mirror::Object* to_ref = gc_mark_stack_->PopBack();
+        ProcessMarkStackRef(to_ref);
+        ++count;
+      }
+      gc_mark_stack_->Reset();
     }
-    gc_mark_stack_->Reset();
+    // jiacheng end
   } else if (mark_stack_mode == kMarkStackModeShared) {
     // Do an empty checkpoint to avoid a race with a mutator preempted in the middle of a read
     // barrier but before pushing onto the mark stack. b/32508093. Note the weak ref access is
@@ -2164,6 +2408,11 @@ bool ConcurrentCopying::ProcessMarkStackOnce() {
         if (gc_mark_stack_->IsEmpty()) {
           break;
         }
+        // jiacheng start
+        if (gc_cause_ == kGcCauseRelocateHotness && gc_mark_stack_->Size() == 1) {
+          break;
+        }
+        // jiacheng end
         for (StackReference<mirror::Object>* p = gc_mark_stack_->Begin();
              p != gc_mark_stack_->End(); ++p) {
           refs.push_back(p->AsMirrorPtr());
@@ -2171,8 +2420,22 @@ bool ConcurrentCopying::ProcessMarkStackOnce() {
         gc_mark_stack_->Reset();
       }
       for (mirror::Object* ref : refs) {
-        ProcessMarkStackRef(ref);
-        ++count;
+        // jiacheng start
+        // ProcessMarkStackRef(ref);
+        // ++count;
+
+        // It is already BFS
+        if (static_cast<uint32_t>(reinterpret_cast<uint64_t>(ref)) == kDepthDelimiter) {
+          LOG(INFO) << "jiacheng ProcessMarkStackOnce() kMarkStackModeShared"
+                    << " push_on_mark_stack_num_= " << push_on_mark_stack_num_.load(std::memory_order_relaxed)
+                    << " depth= " << GetDepth();
+          IncDepth();
+          PushDepthDelimiterOntoMarkStack(self);
+        } else {
+          ProcessMarkStackRef(ref);
+          ++count;
+        }
+        // jiacheng end
       }
     }
   } else {
@@ -2183,12 +2446,53 @@ bool ConcurrentCopying::ProcessMarkStackOnce() {
       CHECK(revoked_mark_stacks_.empty());
     }
     // Process the GC mark stack in the exclusive mode. No need to take the lock.
-    while (!gc_mark_stack_->IsEmpty()) {
-      mirror::Object* to_ref = gc_mark_stack_->PopBack();
-      ProcessMarkStackRef(to_ref);
-      ++count;
+
+    // jiacheng start
+    // while (!gc_mark_stack_->IsEmpty()) {
+    //   mirror::Object* to_ref = gc_mark_stack_->PopBack();
+    //   ProcessMarkStackRef(to_ref);
+    //   ++count;
+    // }
+    // gc_mark_stack_->Reset();
+
+    if (gc_cause_ == kGcCauseRelocateHotness) {
+      std::vector<mirror::Object*> refs;
+      while (true) {
+        refs.clear();
+        {
+          // MutexLock mu(thread_running_gc_, mark_stack_lock_);
+          if (gc_mark_stack_->Size() == 1) {
+            break;
+          }
+          for (StackReference<mirror::Object>* p = gc_mark_stack_->Begin();
+               p != gc_mark_stack_->End(); ++p) {
+            refs.push_back(p->AsMirrorPtr());
+          }
+          gc_mark_stack_->Reset();
+        }
+        // BFS
+        for (mirror::Object* ref : refs) {
+          if (static_cast<uint32_t>(reinterpret_cast<uint64_t>(ref)) == kDepthDelimiter) {
+            LOG(INFO) << "jiacheng ProcessMarkStackOnce() kMarkStackModeGcExclusive"
+                      << " push_on_mark_stack_num_= " << push_on_mark_stack_num_.load(std::memory_order_relaxed)
+                      << " depth= " << GetDepth();
+            IncDepth();
+            PushDepthDelimiterOntoMarkStack(self);
+          } else {
+            ProcessMarkStackRef(ref);
+            ++count;
+          }
+        }
+      }
+    } else {
+      while (!gc_mark_stack_->IsEmpty()) {
+        mirror::Object* to_ref = gc_mark_stack_->PopBack();
+        ProcessMarkStackRef(to_ref);
+        ++count;
+      }
+      gc_mark_stack_->Reset();
     }
-    gc_mark_stack_->Reset();
+    // jiacheng end
   }
 
   // Return true if the stack was empty.
@@ -2260,6 +2564,12 @@ inline void ConcurrentCopying::ProcessMarkStackRef(mirror::Object* to_ref) {
           CHECK(region_space_->IsLargeObject(to_ref));
           region_space_->ZeroLiveBytesForLargeObject(to_ref);
         }
+        // jiacheng start
+        else if (background_gen_) {
+          CHECK(region_space_->IsLargeObject(to_ref));
+          region_space_->ZeroLiveBytesForLargeObject(to_ref); 
+        }
+        // jiacheng end
         perform_scan = true;
         // Only add to the live bytes if the object was not already marked and we are not the young
         // GC.
@@ -2279,18 +2589,6 @@ inline void ConcurrentCopying::ProcessMarkStackRef(mirror::Object* to_ref) {
       }
       perform_scan = true;
       break;
-    // jiacheng start
-    case space::RegionSpace::RegionType::kRegionTypeColdToSpace:
-      region_space_bitmap_->Set(to_ref);
-      perform_scan = true;
-      break;
-    case space::RegionSpace::RegionType::kRegionTypeColdSpace:
-      if(!region_space_bitmap_->Set(to_ref)) { // old word == 0
-        perform_scan = true;
-        add_to_live_bytes = true;
-      }
-      break;
-    // jiacheng end
     default:
       DCHECK(!region_space_->HasAddress(to_ref)) << to_ref;
       DCHECK(!immune_spaces_.ContainsObject(to_ref));
@@ -2332,6 +2630,11 @@ inline void ConcurrentCopying::ProcessMarkStackRef(mirror::Object* to_ref) {
   if (perform_scan) {
     if (use_generational_cc_ && young_gen_) {
       Scan<true>(to_ref);
+    // jiacheng start
+    } else if (background_gen_) {
+      // Scan<true>(to_ref);
+      Scan<false>(to_ref);
+    // jiacheng end
     } else {
       Scan<false>(to_ref);
     }
@@ -2478,7 +2781,15 @@ void ConcurrentCopying::CheckEmptyMarkStack() {
   } else {
     // Shared, GC-exclusive, or off.
     MutexLock mu(thread_running_gc_, mark_stack_lock_);
-    CHECK(gc_mark_stack_->IsEmpty());
+    // jiacheng start
+    // CHECK(gc_mark_stack_->IsEmpty());
+    if (gc_cause_ == kGcCauseRelocateHotness) {
+      CHECK((GetDepth() == 0 && gc_mark_stack_->IsEmpty()) || 
+            (GetDepth() > 0 && gc_mark_stack_->Size() == 1));
+    } else {
+      CHECK(gc_mark_stack_->IsEmpty());
+    }
+    // jiacheng end
     CHECK(revoked_mark_stacks_.empty());
   }
 }
@@ -2493,6 +2804,32 @@ void ConcurrentCopying::Sweep(bool swap_bitmaps) {
   if (use_generational_cc_ && young_gen_) {
     // Only sweep objects on the live stack.
     SweepArray(heap_->GetLiveStack(), /* swap_bitmaps= */ false);
+  // jiacheng start
+  } else if (background_gen_) {
+    SweepArray(heap_->GetLiveStack(), /* swap_bitmaps= */ false);
+    // {
+    //   TimingLogger::ScopedTiming t("MarkStackAsLive", GetTimings());
+    //   accounting::ObjectStack* live_stack = heap_->GetLiveStack();
+    //   if (kEnableFromSpaceAccountingCheck) {
+    //     // Ensure that nobody inserted items in the live stack after we swapped the stacks.
+    //     CHECK_GE(live_stack_freeze_size_, live_stack->Size());
+    //   }
+    //   heap_->MarkAllocStackAsLive(live_stack);
+    //   live_stack->Reset();
+    // }
+    // CheckEmptyMarkStack();
+    // TimingLogger::ScopedTiming split("Sweep", GetTimings());
+    // for (const auto& space : GetHeap()->GetContinuousSpaces()) {
+    //   if (space->IsContinuousMemMapAllocSpace() && space != region_space_
+    //       && !immune_spaces_.ContainsSpace(space)) {
+    //     space::ContinuousMemMapAllocSpace* alloc_space = space->AsContinuousMemMapAllocSpace();
+    //     TimingLogger::ScopedTiming split2(
+    //         alloc_space->IsZygoteSpace() ? "SweepZygoteSpace" : "SweepAllocSpace", GetTimings());
+    //     RecordFree(alloc_space->Sweep(swap_bitmaps));
+    //   }
+    // }
+    // SweepLargeObjects(swap_bitmaps);
+  // jiacheng end
   } else {
     {
       TimingLogger::ScopedTiming t("MarkStackAsLive", GetTimings());
@@ -2693,7 +3030,10 @@ void ConcurrentCopying::CaptureRssAtPeak() {
     // card table
     add_gc_range(heap_->GetCardTable()->MemMapBegin(), heap_->GetCardTable()->MemMapSize());
     // inter-region refs
-    if (use_generational_cc_ && !young_gen_) {
+    // jiachegn start
+    // if (use_generational_cc_ && !young_gen_) {
+    if (use_generational_cc_ && !young_gen_ && !background_gen_) {
+    // jiacheng end
       // region space
       add_gc_range(region_space_inter_region_bitmap_->Begin(),
                    region_space_inter_region_bitmap_->Size());
@@ -2707,9 +3047,6 @@ void ConcurrentCopying::CaptureRssAtPeak() {
 }
 
 void ConcurrentCopying::ReclaimPhase() {
-  // jiacheng start
-  LOG(INFO) << "jiacheng debug concurrent_copying.cc 2711 ReclaimPhase()";
-  // jiacheng end
   TimingLogger::ScopedTiming split("ReclaimPhase", GetTimings());
   if (kVerboseMode) {
     LOG(INFO) << "GC ReclaimPhase";
@@ -2770,7 +3107,10 @@ void ConcurrentCopying::ReclaimPhase() {
     uint64_t cleared_objects;
     {
       TimingLogger::ScopedTiming split4("ClearFromSpace", GetTimings());
+      // jiacheng start
+      // region_space_->ClearFromSpace(&cleared_bytes, &cleared_objects, /*clear_bitmap*/ !young_gen_);
       region_space_->ClearFromSpace(&cleared_bytes, &cleared_objects, /*clear_bitmap*/ !young_gen_);
+      // jiacheng end
       // `cleared_bytes` and `cleared_objects` may be greater than the from space equivalents since
       // RegionSpace::ClearFromSpace may clear empty unevac regions.
       CHECK_GE(cleared_bytes, from_bytes);
@@ -2809,6 +3149,18 @@ void ConcurrentCopying::ReclaimPhase() {
     SwapBitmaps();
     heap_->UnBindBitmaps();
 
+    // jiacheng start
+    if (gc_cause_ == kGcCauseRelocateHotness) {
+      region_space_->CopyMarkedToForeground();
+      
+      heap_->GetNonMovingSpace()->CopyMarkedToForeground();
+
+      for (const auto& space : GetHeap()->GetDiscontinuousSpaces()) {
+        space->AsLargeObjectSpace()->CopyMarkedToForeground();
+      }
+    }
+    // jiacheng end
+
     // The bitmap was cleared at the start of the GC, there is nothing we need to do here.
     DCHECK(region_space_bitmap_ != nullptr);
     region_space_bitmap_ = nullptr;
@@ -2886,21 +3238,7 @@ void ConcurrentCopying::AssertToSpaceInvariant(mirror::Object* obj,
           Thread::Current()->DumpJavaStack(LOG_STREAM(FATAL_WITHOUT_ABORT));
         }
         CHECK(IsMarkedInUnevacFromSpace(ref)) << ref;
-     } 
-     // jiacheng start
-     else if (type == RegionType::kRegionTypeColdToSpace){
-       return;
-     } else if (type == RegionType::kRegionTypeColdSpace) {
-        if (!IsMarkedInColdSpace(ref)) {
-          LOG(FATAL_WITHOUT_ABORT) << "Found unmarked reference in cold-space:";
-          region_space_->Unprotect();
-          LOG(FATAL_WITHOUT_ABORT) << DumpHeapReference(obj, offset, ref);
-          Thread::Current()->DumpJavaStack(LOG_STREAM(FATAL_WITHOUT_ABORT));
-        }
-        CHECK(IsMarkedInColdSpace(ref)) << ref;
-     }
-     // jiacheng end     
-     else {
+     } else {
         // Not OK: either a from-space ref or a reference in an unused region.
         if (type == RegionType::kRegionTypeFromSpace) {
           LOG(FATAL_WITHOUT_ABORT) << "Found from-space reference:";
@@ -3005,20 +3343,7 @@ void ConcurrentCopying::AssertToSpaceInvariant(GcRootSource* gc_root_source,
           LOG(FATAL_WITHOUT_ABORT) << DumpGcRoot(ref);
         }
         CHECK(IsMarkedInUnevacFromSpace(ref)) << ref;
-      } 
-      // jiacheng start
-     else if (type == RegionType::kRegionTypeColdToSpace){
-       return;
-     } else if (type == RegionType::kRegionTypeColdSpace) {
-        if (!IsMarkedInColdSpace(ref)) {
-          LOG(FATAL_WITHOUT_ABORT) << "Found unmarked reference in cold-space:";
-          region_space_->Unprotect();
-          LOG(FATAL_WITHOUT_ABORT) << DumpGcRoot(ref);
-        }
-        CHECK(IsMarkedInColdSpace(ref)) << ref;
-     }
-      // jiacheng end
-      else {
+      } else {
         // Not OK: either a from-space ref or a reference in an unused region.
         if (type == RegionType::kRegionTypeFromSpace) {
           LOG(FATAL_WITHOUT_ABORT) << "Found from-space reference:";
@@ -3211,15 +3536,6 @@ class ConcurrentCopying::RefFieldsVisitor {
 
 template <bool kNoUnEvac>
 inline void ConcurrentCopying::Scan(mirror::Object* to_ref) {
-  // jiacheng start 
-  // 除了Scan还有很多其他地方对to_ref进行访问，例如检查barrier state
-  if(region_space_->IsInColdSpace(to_ref)) {
-    return;
-  }
-  if (!region_space_->IsInColdSpace(to_ref)) {
-    jiacheng::GCAccessTrigger(to_ref);
-  }
-  // jiacheng end
   // Cannot have `kNoUnEvac` when Generational CC collection is disabled.
   DCHECK(!kNoUnEvac || use_generational_cc_);
   if (kDisallowReadBarrierDuringScan && !Runtime::Current()->IsActiveTransaction()) {
@@ -3230,6 +3546,12 @@ inline void ConcurrentCopying::Scan(mirror::Object* to_ref) {
   }
   DCHECK(!region_space_->IsInFromSpace(to_ref));
   DCHECK_EQ(Thread::Current(), thread_running_gc_);
+  // jiacheng start
+  if (jiacheng::IsWhiteApp()) {
+    scan_num_.fetch_add(1, std::memory_order_relaxed);
+    heap_->AddWs(to_ref);
+  }
+  // jiacheng end
   RefFieldsVisitor<kNoUnEvac> visitor(this, thread_running_gc_);
   // Disable the read barrier for a performance reason.
   to_ref->VisitReferences</*kVisitNativeRoots=*/true, kDefaultVerifyFlags, kWithoutReadBarrier>(
@@ -3490,17 +3812,24 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
   size_t bytes_allocated = 0U;
   size_t dummy;
   bool fall_back_to_non_moving = false;
+
   // jiacheng start
   // mirror::Object* to_ref = region_space_->AllocNonvirtual</*kForEvac=*/ true>(
   //     region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
   mirror::Object* to_ref = nullptr;
-  if (jiacheng::Profiler::Current()->ShouldSwapOut(from_ref)) {
-    to_ref = region_space_->AllocCold(region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
-    // LOG(INFO) << "jiacheng concurrent_copying.cc 3415 region_space_->AllocCold()" 
-    //           << " region_space_alloc_size= " << region_space_alloc_size 
-    //           << " to_ref= " << to_ref
-    //           ;
+
+  if (GetCurrentIteration()->GetGcCause() == kGcCauseRelocateHotness) {
+    if (self != thread_running_gc_) {
+      to_ref = region_space_->AllocWorkingSet(region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
+    } else if (jiacheng::ENABLE_FYO && region_space_->IsInNewlyAllocatedRegion(from_ref)) {
+      to_ref = region_space_->AllocLaunch(region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
+    } else if (jiacheng::ENABLE_NRO && GetDepth() <= jiacheng::NEAR_TO_ROOT_THRESHOLD) {
+      to_ref = region_space_->AllocLaunch(region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
+    } else {
+      to_ref = region_space_->AllocCold(region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
+    }
   }
+      
   if (to_ref == nullptr) {
     to_ref = region_space_->AllocNonvirtual</*kForEvac*/ true>(
             region_space_alloc_size, &region_space_bytes_allocated, nullptr, &dummy);
@@ -3553,9 +3882,6 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
   // static_assert(kObjectHeaderSize == sizeof(mirror::HeapReference<mirror::Class>) +
   //                   sizeof(LockWord),
   //               "Object header size does not match");
-  static_assert(kObjectHeaderSize == sizeof(mirror::HeapReference<mirror::Class>) +
-                    sizeof(LockWord) + sizeof(uint64_t),
-                "Object header size does not match");
   // jiacheng end
   // Memcpy can tear for words since it may do byte copy. It is only safe to do this since the
   // object in the from space is immutable other than the lock word. b/31423258
@@ -3563,14 +3889,13 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
          reinterpret_cast<const uint8_t*>(from_ref) + kObjectHeaderSize,
          obj_size - kObjectHeaderSize);
   // jiacheng start
-  jiacheng::GCAccessTrigger(to_ref);
-  jiacheng::GCAccessTrigger(from_ref);
+  to_ref->CopyHeaderFrom(from_ref);
+  copy_num_.fetch_add(1, std::memory_order_relaxed);
+  if (self != thread_running_gc_) {
+    copy_from_barrier_num_.fetch_add(1, std::memory_order_relaxed);
+  }
   // jiacheng end
 
-  // jiacheng debug start
-  CHECK(region_space_->IsInFromSpace(from_ref)) << (region_space_->GetRegionType(from_ref)) << (region_space_->GetRegionType(to_ref));
-  // jiacheng debug end
-
   // Attempt to install the forward pointer. This is in a loop as the
   // lock word atomic write can fail.
   while (true) {
@@ -3609,12 +3934,8 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
       to_ref = reinterpret_cast<mirror::Object*>(old_lock_word.ForwardingAddress());
       CHECK(to_ref != nullptr);
       CHECK_NE(to_ref, lost_fwd_ptr);
-      // jiacheng start
-      // CHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
-      //     << "to_ref=" << to_ref << " " << heap_->DumpSpaces();
-      CHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref) || region_space_->IsInColdToSpace(to_ref))
+      CHECK(region_space_->IsInToSpace(to_ref) || heap_->non_moving_space_->HasAddress(to_ref))
           << "to_ref=" << to_ref << " " << heap_->DumpSpaces();
-      // jiacheng end
       CHECK_NE(to_ref->GetLockWord(false).GetState(), LockWord::kForwardingAddress);
       return to_ref;
     }
@@ -3653,7 +3974,10 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
       } else {
         DCHECK(heap_->non_moving_space_->HasAddress(to_ref));
         DCHECK_EQ(bytes_allocated, non_moving_space_bytes_allocated);
-        if (!use_generational_cc_ || !young_gen_) {
+        // jiacheng start
+        // if (!use_generational_cc_ || !young_gen_) {
+        if (!use_generational_cc_ || (!young_gen_ && !background_gen_)) {
+        // jiacheng end
           // Mark it in the live bitmap.
           CHECK(!heap_->non_moving_space_->GetLiveBitmap()->AtomicTestAndSet(to_ref));
         }
@@ -3697,19 +4021,7 @@ mirror::Object* ConcurrentCopying::IsMarked(mirror::Object* from_ref) {
     } else {
       to_ref = nullptr;
     }
-  } 
-  // jiacheng start
-  else if (rtype == space::RegionSpace::RegionType::kRegionTypeColdToSpace){
-    return from_ref;
-  } else if (rtype == space::RegionSpace::RegionType::kRegionTypeColdSpace) {
-    if (IsMarkedInColdSpace(from_ref)) {
-      to_ref = from_ref;
-    } else {
-      to_ref = nullptr;
-    }
-  }
-  // jiacheng end
-  else {
+  } else {
     // At this point, `from_ref` should not be in the region space
     // (i.e. within an "unused" region).
     DCHECK(!region_space_->HasAddress(from_ref)) << from_ref;
@@ -3825,9 +4137,6 @@ mirror::Object* ConcurrentCopying::MarkNonMoving(Thread* const self,
 }
 
 void ConcurrentCopying::FinishPhase() {
-  // jiacheng start
-  LOG(INFO) << "jiacheng debug concurrent_copying.cc 3829 FinishPhase()";
-  // jiacheng end
   Thread* const self = Thread::Current();
   {
     MutexLock mu(self, mark_stack_lock_);
@@ -3839,7 +4148,10 @@ void ConcurrentCopying::FinishPhase() {
     TimingLogger::ScopedTiming split("ClearRegionSpaceCards", GetTimings());
     // We do not currently use the region space cards at all, madvise them away to save ram.
     heap_->GetCardTable()->ClearCardRange(region_space_->Begin(), region_space_->Limit());
-  } else if (use_generational_cc_ && !young_gen_) {
+  // jiacheng start
+  // } else if (use_generational_cc_ && !young_gen_) {
+  } else if (use_generational_cc_ && !young_gen_ && !background_gen_) {
+  // jiacheng end
     region_space_inter_region_bitmap_->Clear();
     non_moving_space_inter_region_bitmap_->Clear();
   }
@@ -3993,29 +4305,45 @@ void ConcurrentCopying::DumpPerformanceInfo(std::ostream& os) {
 }
 
 // jiacheng start
-mirror::Object* ConcurrentCopying::MarkColdSpaceRegion(Thread* const self, 
-                                                       mirror::Object* ref, 
-                                                       accounting::SpaceBitmap<kObjectAlignment>* bitmap) {
-  if (bitmap->Test(ref)) {
-    return ref;
-  }
-  bool success = ref->AtomicSetReadBarrierState(/* expected_rb_state= */ ReadBarrier::NonGrayState(),
-                                             /* rb_state= */ ReadBarrier::GrayState());
-  if (success) {
-    DCHECK_EQ(ref->GetReadBarrierState(), ReadBarrier::GrayState());
-    PushOntoMarkStack(self, ref);
+void ConcurrentCopying::PushDepthDelimiterOntoMarkStack(Thread* const self) {
+  CHECK_EQ(is_mark_stack_push_disallowed_.load(std::memory_order_relaxed), 0);
+  CHECK(thread_running_gc_ != nullptr);
+  MarkStackMode mark_stack_mode = mark_stack_mode_.load(std::memory_order_relaxed);
+  mirror::Object* fake_object = reinterpret_cast<mirror::Object*>(static_cast<uint64_t>(kDepthDelimiter));
+
+  if (LIKELY(mark_stack_mode == kMarkStackModeThreadLocal)) {
+    if (LIKELY(self == thread_running_gc_)) {
+      CHECK(self->GetThreadLocalMarkStack() == nullptr);
+      if (UNLIKELY(gc_mark_stack_->IsFull())) {
+        ExpandGcMarkStack();
+      }
+      gc_mark_stack_->PushBack(fake_object);
+    } else {
+      CHECK(false);
+    }
+
+  } else if (mark_stack_mode == kMarkStackModeShared) {
+    MutexLock mu(self, mark_stack_lock_);
+    if (UNLIKELY(gc_mark_stack_->IsFull())) {
+      ExpandGcMarkStack();
+    }
+    gc_mark_stack_->PushBack(fake_object);
+  } else {
+    CHECK(self == thread_running_gc_);
+    if (UNLIKELY(gc_mark_stack_->IsFull())) {
+      ExpandGcMarkStack();
+    }
+    gc_mark_stack_->PushBack(fake_object);
   }
-  return ref;
 }
 
-bool ConcurrentCopying::IsMarkedInColdSpace(mirror::Object* from_ref) {
-  DCHECK(region_space_->IsInColdSpace(from_ref));
-  if (from_ref->GetReadBarrierStateAcquire() == ReadBarrier::GrayState()) {
-    return true;
-  } else if (done_scanning_.load(std::memory_order_acquire)) {
-    return region_space_bitmap_->Test(from_ref);
-  }
-  return false;
+
+void ConcurrentCopying::RemoveDepthDelimiterFromMarkStack(Thread* const self) {
+  CHECK(thread_running_gc_ == self);
+  CHECK(!gc_mark_stack_->IsEmpty());
+  mirror::Object* ref = gc_mark_stack_->PopBack();
+  CHECK(static_cast<uint32_t>(reinterpret_cast<uint64_t>(ref)) == kDepthDelimiter);
+  CHECK(gc_mark_stack_->IsEmpty());
 }
 
 // jiacheng end
diff --git a/runtime/gc/collector/concurrent_copying.h b/runtime/gc/collector/concurrent_copying.h
index 8e369e960d..f9e1d1cdc9 100644
--- a/runtime/gc/collector/concurrent_copying.h
+++ b/runtime/gc/collector/concurrent_copying.h
@@ -65,6 +65,10 @@ class ConcurrentCopying : public GarbageCollector {
   // pages.
   static constexpr bool kGrayDirtyImmuneObjects = true;
 
+  // jiacheng start
+  static constexpr uint32_t kDepthDelimiter = 0xFFFFFFFF;
+  // jiacheng end
+
   ConcurrentCopying(Heap* heap,
                     bool young_gen,
                     bool use_generational_cc,
@@ -72,6 +76,40 @@ class ConcurrentCopying : public GarbageCollector {
                     bool measure_read_barrier_slow_path = false);
   ~ConcurrentCopying();
 
+  // jiacheng start
+  void SetRelocateHotness(bool relocate_hotness) {
+    relocate_hotness_ = relocate_hotness;
+  }
+
+  bool GetRelocateHotness() {
+    return relocate_hotness_;
+  }
+
+  uint32_t GetDepth() {
+    return depth_.load(std::memory_order_relaxed);
+  }
+
+  void SetDepth(uint32_t gc_depth) {
+    depth_.store(gc_depth, std::memory_order_relaxed);
+  }
+
+  void IncDepth() {
+    depth_.fetch_add(1, std::memory_order_relaxed);
+  }
+
+  void PushDepthDelimiterOntoMarkStack(Thread* const self)       
+      REQUIRES_SHARED(Locks::mutator_lock_)
+      REQUIRES(!mark_stack_lock_);
+
+  void RemoveDepthDelimiterFromMarkStack(Thread* const self)       
+      REQUIRES_SHARED(Locks::mutator_lock_)
+      REQUIRES(!mark_stack_lock_);
+
+  Thread* GetThreadRunningGc() {
+    return thread_running_gc_;
+  }
+  // jiacheng end
+
   void RunPhases() override
       REQUIRES(!immune_gray_stack_lock_,
                !mark_stack_lock_,
@@ -235,10 +273,6 @@ class ConcurrentCopying : public GarbageCollector {
       REQUIRES(!mark_stack_lock_, !skipped_blocks_lock_, !immune_gray_stack_lock_);
   bool IsMarkedInUnevacFromSpace(mirror::Object* from_ref)
       REQUIRES_SHARED(Locks::mutator_lock_);
-  // jiacheng start
-  bool IsMarkedInColdSpace(mirror::Object* from_ref)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-  // jiacheng end
   bool IsMarkedInNonMovingSpace(mirror::Object* from_ref)
       REQUIRES_SHARED(Locks::mutator_lock_);
   bool IsNullOrMarkedHeapReference(mirror::HeapReference<mirror::Object>* field,
@@ -302,13 +336,6 @@ class ConcurrentCopying : public GarbageCollector {
       accounting::SpaceBitmap<kObjectAlignment>* bitmap)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!mark_stack_lock_, !skipped_blocks_lock_);
-// jiacheng start
-  mirror::Object* MarkColdSpaceRegion(Thread* const self,
-      mirror::Object* from_ref,
-      accounting::SpaceBitmap<kObjectAlignment>* bitmap)
-      REQUIRES_SHARED(Locks::mutator_lock_)
-      REQUIRES(!mark_stack_lock_, !skipped_blocks_lock_);
-// jiacheng end
   template<bool kGrayImmuneObject>
   ALWAYS_INLINE mirror::Object* MarkImmuneSpace(Thread* const self,
                                                 mirror::Object* from_ref)
@@ -345,6 +372,10 @@ class ConcurrentCopying : public GarbageCollector {
   // Generational "sticky", only trace through dirty objects in region space.
   const bool young_gen_;
 
+  // jiacheng start
+  bool background_gen_;
+  // jiacheng end
+
   // If true, the GC thread is done scanning marked objects on dirty and aged
   // card (see ConcurrentCopying::CopyingPhase).
   Atomic<bool> done_scanning_;
@@ -472,6 +503,12 @@ class ConcurrentCopying : public GarbageCollector {
   // Use signed because after_gc may be larger than before_gc.
   int64_t num_bytes_allocated_before_gc_;
 
+  // jiacheng start
+  GcCause gc_cause_;
+
+  std::atomic<uint32_t> depth_;
+  // jiacheng end
+
   class ActivateReadBarrierEntrypointsCallback;
   class ActivateReadBarrierEntrypointsCheckpoint;
   class AssertToSpaceInvariantFieldVisitor;
@@ -494,10 +531,6 @@ class ConcurrentCopying : public GarbageCollector {
   class VerifyNoFromSpaceRefsVisitor;
   class VerifyNoMissingCardMarkVisitor;
   class ImmuneSpaceCaptureRefsVisitor;
-  // jiacheng start
-  class RegionRememberedObjectsVisitor;
-  class RegionRememberedObjectsAsRootVisitor;
-  // jiacheng end
   template <bool kAtomicTestAndSet = false> class CaptureRootsForMarkingVisitor;
   class CaptureThreadRootsForMarkingAndCheckpoint;
   template <bool kHandleInterRegionRefs> class ComputeLiveBytesAndMarkRefFieldsVisitor;
diff --git a/runtime/gc/collector/garbage_collector.cc b/runtime/gc/collector/garbage_collector.cc
index 565d38e6ec..ca4f4bf73a 100644
--- a/runtime/gc/collector/garbage_collector.cc
+++ b/runtime/gc/collector/garbage_collector.cc
@@ -40,6 +40,8 @@
 
 // jiacheng start
 #include "jiacheng_hack.h"
+#include "jiacheng_utils.h"
+#include "gc/space/region_space-inl.h"
 // jiacheng end
 
 namespace art {
@@ -148,11 +150,6 @@ uint64_t GarbageCollector::ExtractRssFromMincore(
 }
 
 void GarbageCollector::Run(GcCause gc_cause, bool clear_soft_references) {
-
-  // jiacheng start
-  jiacheng::BeforeGarbageCollectorRun(this);
-  // jiacheng end
-
   ScopedTrace trace(android::base::StringPrintf("%s %s GC", PrettyCause(gc_cause), GetName()));
   Thread* self = Thread::Current();
   uint64_t start_time = NanoTime();
@@ -160,6 +157,7 @@ void GarbageCollector::Run(GcCause gc_cause, bool clear_soft_references) {
   GetHeap()->CalculatePreGcWeightedAllocatedBytes();
   Iteration* current_iteration = GetCurrentIteration();
   current_iteration->Reset(gc_cause, clear_soft_references);
+
   // Note transaction mode is single-threaded and there's no asynchronous GC and this flag doesn't
   // change in the middle of a GC.
   is_transaction_active_ = Runtime::Current()->IsActiveTransaction();
@@ -191,10 +189,6 @@ void GarbageCollector::Run(GcCause gc_cause, bool clear_soft_references) {
     pause_histogram_.AdjustAndAddValue(pause_time);
   }
   is_transaction_active_ = false;
-
-  // jiacheng start
-  jiacheng::AfterGarbageCollectorRun(this);
-  // jiacheng end  
 }
 
 void GarbageCollector::SwapBitmaps() {
diff --git a/runtime/gc/collector/garbage_collector.h b/runtime/gc/collector/garbage_collector.h
index 7505658413..dbdb61cd53 100644
--- a/runtime/gc/collector/garbage_collector.h
+++ b/runtime/gc/collector/garbage_collector.h
@@ -64,6 +64,7 @@ class GarbageCollector : public RootVisitor, public IsMarkedVisitor, public Mark
   const char* GetName() const {
     return name_.c_str();
   }
+
   virtual GcType GetGcType() const = 0;
   virtual CollectorType GetCollectorType() const = 0;
   // Run the garbage collector.
@@ -164,6 +165,20 @@ class GarbageCollector : public RootVisitor, public IsMarkedVisitor, public Mark
   mutable Mutex pause_histogram_lock_ DEFAULT_MUTEX_ACQUIRED_AFTER;
   bool is_transaction_active_;
 
+  // jiacheng start
+  Atomic<uint64_t> copy_launch_object_num_;
+  Atomic<uint64_t> copy_cold_object_num_;
+  bool relocate_hotness_;
+
+  std::atomic<uint64_t> mark_num_;
+  std::atomic<uint64_t> mark_from_read_barrier_num_;
+  std::atomic<uint64_t> scan_num_;
+  std::atomic<uint64_t> copy_num_;
+  std::atomic<uint64_t> copy_from_barrier_num_;
+  std::atomic<uint64_t> push_on_mark_stack_num_;
+  std::atomic<uint64_t> read_barrier_num_;
+  // jiacheng end
+
  private:
   DISALLOW_IMPLICIT_CONSTRUCTORS(GarbageCollector);
 };
diff --git a/runtime/gc/gc_cause.cc b/runtime/gc/gc_cause.cc
index 8b4bac2f8d..2171a7617d 100644
--- a/runtime/gc/gc_cause.cc
+++ b/runtime/gc/gc_cause.cc
@@ -46,6 +46,9 @@ const char* PrettyCause(GcCause cause) {
     case kGcCauseHprof: return "Hprof";
     case kGcCauseGetObjectsAllocated: return "ObjectsAllocated";
     case kGcCauseProfileSaver: return "ProfileSaver";
+    // jiacheng start
+    case kGcCauseRelocateHotness: return "RelocateHotness";
+    // jiacheng end
   }
   LOG(FATAL) << "Unreachable";
   UNREACHABLE();
diff --git a/runtime/gc/gc_cause.h b/runtime/gc/gc_cause.h
index 81781ceeb7..b5bc7e9f53 100644
--- a/runtime/gc/gc_cause.h
+++ b/runtime/gc/gc_cause.h
@@ -62,6 +62,9 @@ enum GcCause {
   kGcCauseGetObjectsAllocated,
   // GC cause for the profile saver.
   kGcCauseProfileSaver,
+  // jiacheng start
+  kGcCauseRelocateHotness,
+  // jiacheng end
 };
 
 const char* PrettyCause(GcCause cause);
diff --git a/runtime/gc/heap-inl.h b/runtime/gc/heap-inl.h
index 1c09b5c9bf..126593325e 100644
--- a/runtime/gc/heap-inl.h
+++ b/runtime/gc/heap-inl.h
@@ -38,6 +38,10 @@
 #include "verify_object.h"
 #include "write_barrier-inl.h"
 
+// jiacheng start
+#include "jiacheng_barrier.h"
+// jiacheng end
+
 namespace art {
 namespace gc {
 
@@ -382,6 +386,9 @@ inline mirror::Object* Heap::TryToAllocate(Thread* self,
       ret = nullptr;
     }
   }
+  // jiacheng start
+  jiacheng::AllocationNewBarrier(reinterpret_cast<uint64_t>(ret));
+  // jiacheng end
   return ret;
 }
 
diff --git a/runtime/gc/heap.cc b/runtime/gc/heap.cc
index 0d9a2a4e9c..bdabae97c3 100644
--- a/runtime/gc/heap.cc
+++ b/runtime/gc/heap.cc
@@ -95,6 +95,8 @@
 
 // jiacheng start
 #include "jiacheng_hack.h"
+#include "jiacheng_global.h"
+#include "jiacheng_utils.h"
 // jiacheng end
 
 namespace art {
@@ -314,7 +316,19 @@ Heap::Heap(size_t initial_size,
       unique_backtrace_count_(0u),
       gc_disabled_for_shutdown_(false),
       dump_region_info_before_gc_(dump_region_info_before_gc),
-      dump_region_info_after_gc_(dump_region_info_after_gc) {
+      // jiacheng start
+      // dump_region_info_after_gc_(dump_region_info_after_gc) {
+      dump_region_info_after_gc_(dump_region_info_after_gc),
+
+      during_gc_flag_(false),
+      perceptible_flag_(false),
+      pending_relocate_hotness_(nullptr),
+      done_relocate_hotness_flag_(false),
+      hot_launch_flag_(false),
+      madvise_spaces_size_(nullptr),
+      mutator_ws_lock_("mutator_ws_lock_", kJiachengWorkingSetLock),
+      gc_ws_lock_("gc_ws_lock_", kJiachengWorkingSetLock) {
+      // jiacheng end
   if (VLOG_IS_ON(heap) || VLOG_IS_ON(startup)) {
     LOG(INFO) << "Heap() entering";
   }
@@ -597,6 +611,13 @@ Heap::Heap(size_t initial_size,
   card_table_.reset(accounting::CardTable::Create(reinterpret_cast<uint8_t*>(kMinHeapAddress),
                                                   4 * GB - kMinHeapAddress));
   CHECK(card_table_.get() != nullptr) << "Failed to create card table";
+
+  // jiacheng start
+  card_table2_.reset(accounting::CardTable::Create(reinterpret_cast<uint8_t*>(kMinHeapAddress),
+                                                  4 * GB - kMinHeapAddress));
+  CHECK(card_table2_.get() != nullptr) << "Failed to create card table2";
+  // jiacheng end
+
   if (foreground_collector_type_ == kCollectorTypeCC && kUseTableLookupReadBarrier) {
     rb_table_.reset(new accounting::ReadBarrierTable());
     DCHECK(rb_table_->IsAllCleared());
@@ -724,26 +745,6 @@ Heap::Heap(size_t initial_size,
   }
 }
 
-// jiacheng start
-void Heap::JiachengDebug() {
-  // 用于显示Heap当前的信息
-  Thread* self = Thread::Current();
-  (void)self;
-  
-  MutexLock mu(self, *gc_complete_lock_);
-  LOG(INFO) << "jiacheng heap.cc 732"
-            << " last_gc_type_= " << last_gc_type_
-            << " next_gc_type_= " << next_gc_type_
-            << " current_allocator_= " << current_allocator_
-            << " current_non_moving_allocator_= " << current_non_moving_allocator_
-            ;
-  for (size_t i = 0; i < gc_plan_.size(); ++i) {
-    LOG(INFO) << "jiacheng heap.cc 732"
-              << " gc_plan_[" << i << "]= " << gc_plan_[i]
-              ;
-  }
-}
-// jiacheng end
 
 MemMap Heap::MapAnonymousPreferredAddress(const char* name,
                                           uint8_t* request_begin,
@@ -998,8 +999,16 @@ void Heap::ThreadFlipEnd(Thread* self) {
 
 void Heap::UpdateProcessState(ProcessState old_process_state, ProcessState new_process_state) {
   // jiacheng start
-  jiacheng::Profiler::Current()->SetSwitchingFlag();
-  jiacheng::UpdataAppState(old_process_state, new_process_state);
+  const bool is_white_app = jiacheng::IsWhiteApp();
+  if (is_white_app) {
+    if (new_process_state == kProcessStateJankImperceptible &&
+        GetPerceptibleFlag()) {
+      ForeToBack();
+    } else if (new_process_state == kProcessStateJankPerceptible && 
+               !GetPerceptibleFlag()) {
+      BackToFore();
+    }
+  }
   // jiacheng end
   
   if (old_process_state != new_process_state) {
@@ -1021,10 +1030,19 @@ void Heap::UpdateProcessState(ProcessState old_process_state, ProcessState new_p
       // special handling which does a homogenous space compaction once but then doesn't transition
       // the collector. Similarly, we invoke a full compaction for kCollectorTypeCC but don't
       // transition the collector.
-      RequestCollectorTransition(background_collector_type_,
-                                 kStressCollectorTransition
-                                     ? 0
-                                     : kCollectorTransitionWait);
+
+      // jiacheng start
+      // RequestCollectorTransition(background_collector_type_,
+      //                            kStressCollectorTransition
+      //                                ? 0
+      //                                : kCollectorTransitionWait);
+      if (jiacheng::ENABLE_APGC && is_white_app) {
+        RequestRelocateHotness(jiacheng::WINDOW_SIZE_BACKGROUND_WS * 1e9);
+      } else {
+        RequestCollectorTransition(background_collector_type_,
+                                   kStressCollectorTransition ? 0 : kCollectorTransitionWait);
+      }
+      // jiacheng end
     }
   }
 }
@@ -2789,8 +2807,11 @@ collector::GcType Heap::CollectGarbageInternal(collector::GcType gc_type,
         if (use_generational_cc_) {
           // TODO: Other threads must do the flip checkpoint before they start poking at
           // active_concurrent_copying_collector_. So we should not concurrency here.
-          active_concurrent_copying_collector_ = (gc_type == collector::kGcTypeSticky) ?
-              young_concurrent_copying_collector_ : concurrent_copying_collector_;
+          // jiacheng start
+          // active_concurrent_copying_collector_ = (gc_type == collector::kGcTypeSticky) ?
+          //     young_concurrent_copying_collector_ : concurrent_copying_collector_;
+          active_concurrent_copying_collector_ = concurrent_copying_collector_;
+          // jiacheng end
           DCHECK(active_concurrent_copying_collector_->RegionSpace() == region_space_);
         }
         collector = active_concurrent_copying_collector_;
@@ -2860,7 +2881,11 @@ void Heap::LogGC(GcCause gc_cause, collector::GarbageCollector* collector) {
     }
   }
   // jiacheng start
-  log_gc = true;
+  if (jiacheng::IsWhiteApp()) {
+    log_gc = true;
+  } else {
+    log_gc = false;
+  }
   // jiacheng end
   if (log_gc) {
     const size_t percent_free = GetPercentFree();
@@ -2871,7 +2896,11 @@ void Heap::LogGC(GcCause gc_cause, collector::GarbageCollector* collector) {
       pause_string << PrettyDuration((pause_times[i] / 1000) * 1000)
                    << ((i != pause_times.size() - 1) ? "," : "");
     }
-    LOG(INFO) << gc_cause << " " << collector->GetName()
+    // jiacheng start
+    // LOG(INFO) << gc_cause << " " << collector->GetName()
+    LOG(INFO) << "jiacheng LogGC() "
+              << gc_cause << " " << collector->GetName()
+    // jiacheng end
               << " GC freed "  << current_gc_iteration_.GetFreedObjects() << "("
               << PrettySize(current_gc_iteration_.GetFreedBytes()) << ") AllocSpace objects, "
               << current_gc_iteration_.GetFreedLargeObjects() << "("
@@ -3425,7 +3454,10 @@ void Heap::ProcessCards(TimingLogger* timings,
           // aligned. Align up so that the check in ClearCardRange does not fail.
           end = AlignUp(end, accounting::CardTable::kCardSize);
         }
-        card_table_->ClearCardRange(space->Begin(), end);
+        // jiacheng start
+        // card_table_->ClearCardRange(space->Begin(), end);
+        GetCardTable()->ClearCardRange(space->Begin(), end);
+        // jiacheng end
       } else {
         // No mod union table for the AllocSpace. Age the cards so that the GC knows that these
         // cards were dirty before the GC started.
@@ -3434,8 +3466,12 @@ void Heap::ProcessCards(TimingLogger* timings,
         // The races are we either end up with: Aged card, unaged card. Since we have the
         // checkpoint roots and then we scan / update mod union tables after. We will always
         // scan either card. If we end up with the non aged card, we scan it it in the pause.
-        card_table_->ModifyCardsAtomic(space->Begin(), space->End(), AgeCardVisitor(),
+        // jiacheng start
+        // card_table_->ModifyCardsAtomic(space->Begin(), space->End(), AgeCardVisitor(),
+        //                                VoidFunctor());
+        GetCardTable()->ModifyCardsAtomic(space->Begin(), space->End(), AgeCardVisitor(),
                                        VoidFunctor());
+        // jiacheng end
       }
     }
   }
@@ -3717,6 +3753,7 @@ void Heap::GrowForUtilization(collector::GarbageCollector* collector_ran,
     } else {
       next_gc_type_ = non_sticky_gc_type;
     }
+
     // If we have freed enough memory, shrink the heap back down.
     if (bytes_allocated + adjusted_max_free < target_footprint) {
       target_size = bytes_allocated + adjusted_max_free;
@@ -3726,7 +3763,9 @@ void Heap::GrowForUtilization(collector::GarbageCollector* collector_ran,
   }
   CHECK_LE(target_size, std::numeric_limits<size_t>::max());
   if (!ignore_target_footprint_) {
+
     SetIdealFootprint(target_size);
+
     if (IsGcConcurrent()) {
       const uint64_t freed_bytes = current_gc_iteration_.GetFreedBytes() +
           current_gc_iteration_.GetFreedLargeObjectBytes() +
@@ -4464,5 +4503,166 @@ void Heap::PostForkChildAction(Thread* self) {
   }
 }
 
+
+// jiacheng start
+
+void Heap::ForeToBack() {
+  LOG(INFO) << "jiacheng Heap::ForeToBack()";
+  SetPerceptibleFlag(false);
+  SetDoneRelocateHotness(false);
+}
+
+void Heap::BackToFore() {
+  // defer the switching of foreground mode until a WINDOW_SIZE_HOT_LAUNCH
+  SetHotLaunchFlag(true);
+  LOG(INFO) << "jiacheng Heap::BackToFore() Start";
+
+  auto func = [this](){
+    constexpr uint64_t defer_time = jiacheng::WINDOW_SIZE_HOT_LAUNCH;
+    std::this_thread::sleep_for(std::chrono::seconds(defer_time));
+
+    LOG(INFO) << "jiacheng Heap::BackToFore() End";
+    SetPerceptibleFlag(true);
+    SetDoneRelocateHotness(false);
+    SetHotLaunchFlag(false);
+  };
+  std::thread t(func);
+  t.detach();
+}
+
+void Heap::DoRelocateHotness() {
+  LOG(INFO) << "jiacheng Heap::DoRelocateHotness()";
+  CollectGarbageInternal(collector::kGcTypeFull, kGcCauseRelocateHotness, false);
+}
+
+
+void Heap::ClearRelocateHotness(Thread* self) {
+  MutexLock mu(self, *pending_task_lock_);
+  pending_relocate_hotness_ = nullptr;
+}
+
+
+class Heap::RelocateHotnessTask : public HeapTask {
+public:
+  explicit RelocateHotnessTask(uint64_t target_time) : HeapTask(target_time) {}
+
+  void Run(Thread* self) override {
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    if (!heap->GetPerceptibleFlag()) {
+      heap->DoRelocateHotness();
+
+      heap->SetDoneRelocateHotness(true);
+      
+      heap->DoMadviseSpacesAsync();
+    }
+    heap->ClearRelocateHotness(self);
+  }
+};
+
+void Heap::RequestRelocateHotness(uint64_t delta_time) {
+  LOG(INFO) << "jiacheng RequestRelocateHotness() delta_time= " << delta_time;
+  Thread* self = Thread::Current();
+  CHECK(CanAddHeapTask(self));
+  RelocateHotnessTask* added_task = nullptr;
+  region_space_->ResetHotness();
+  const uint64_t target_time = NanoTime() + delta_time;
+  {
+    MutexLock mu(self, *pending_task_lock_);
+    if (pending_relocate_hotness_ != nullptr) {
+      task_processor_->UpdateTargetRunTime(self, pending_relocate_hotness_, target_time);
+      return;
+    }
+    added_task = new RelocateHotnessTask(target_time);
+    pending_relocate_hotness_ = added_task;
+  }
+  task_processor_->AddTask(self, added_task);
+}
+
+
+void Heap::JiachengDebug() {
+  LOG(INFO) << "jiacheng heap.cc Heap::JiachengDebug()";
+}
+
+
+size_t Heap::DoMadviseSpaces() {
+  uint64_t duration_time = NanoTime();
+
+  size_t num = 0;
+  num += region_space_->Madvise();
+  // num += non_moving_space_->AsDlMallocSpace()->Madvise();
+  // num += large_object_space_->Madvise();
+  // num += zygote_space_->Madvise();  
+
+  duration_time = NanoTime() - duration_time;
+  LOG(INFO) << "jiacheng heap->DoMadviseSpaces()" 
+            << " duration_time(sec)= " << duration_time / 1e9; 
+  return num;
+}
+
+
+void Heap::DoMadviseSpacesAsync() {
+  auto func = [this]()-> size_t {
+    return DoMadviseSpaces();
+  };
+
+  while (madvise_spaces_size_ != nullptr && 
+      madvise_spaces_size_->wait_for(std::chrono::seconds(1)) != std::future_status::ready) {
+  }
+  madvise_spaces_size_.reset();
+  madvise_spaces_size_ = std::make_unique<std::future<size_t>>(std::async(func));
+}
+
+
+void Heap::JiachengDebugCardTable1() {
+  accounting::ContinuousSpaceBitmap* bitmap = region_space_->GetLiveBitmap();
+  size_t card_num = 0;
+  size_t visit_obj_num = 0;
+  size_t* p_num = &visit_obj_num;
+  card_num = card_table_->Scan<false/*kClearCard*/>(bitmap,
+                                                      region_space_->Begin(),
+                                                      region_space_->End(),
+                                                      [p_num](mirror::Object* obj)
+                                                      REQUIRES(Locks::heap_bitmap_lock_)
+                                                      REQUIRES_SHARED(Locks::mutator_lock_) {
+                                                          (void)obj;
+                                                          ++(*p_num);
+                                                      },
+                                                      accounting::CardTable::kCardAged);
+  LOG(INFO) << "jiacheng JiachengDebugCardTable1() "
+            << " card_num= " << card_num
+            << " visit_obj_num= " << visit_obj_num;
+}
+
+
+void Heap::JiachengDebugCardTable2() {
+  accounting::ContinuousSpaceBitmap* bitmap = region_space_->GetLiveBitmap();
+  size_t card_num = 0;
+  size_t visit_obj_num = 0;
+  size_t* p_num = &visit_obj_num;
+  card_num = card_table2_->Scan<false/*kClearCard*/>(bitmap,
+                                                      region_space_->Begin(),
+                                                      region_space_->End(),
+                                                      [p_num](mirror::Object* obj)
+                                                      REQUIRES(Locks::heap_bitmap_lock_)
+                                                      REQUIRES_SHARED(Locks::mutator_lock_) {
+                                                          (void)obj;
+                                                          ++(*p_num);
+                                                      },
+                                                      accounting::CardTable::kCardAged);
+  LOG(INFO) << "jiacheng JiachengDebugCardTable2() "
+            << " card_num= " << card_num
+            << " visit_obj_num= " << visit_obj_num;
+}
+
+void Heap::AddWs(mirror::Object* obj) {
+  if (Thread::Current() == concurrent_copying_collector_->GetThreadRunningGc() ||
+      Thread::Current() == young_concurrent_copying_collector_->GetThreadRunningGc()) {
+    AddGcWs(obj);
+  } else {
+    AddMutatorWs(obj);
+  }
+}
+// jiacheng end
+
 }  // namespace gc
 }  // namespace art
diff --git a/runtime/gc/heap.h b/runtime/gc/heap.h
index d7a3400637..db6a646444 100644
--- a/runtime/gc/heap.h
+++ b/runtime/gc/heap.h
@@ -21,6 +21,9 @@
 #include <string>
 #include <unordered_set>
 #include <vector>
+// jiacheng start
+#include <future>
+// jiacheng end
 
 #include <android-base/logging.h>
 
@@ -129,7 +132,7 @@ class Heap {
  public:
   static constexpr size_t kDefaultStartingSize = kPageSize;
   // jiacheng start
-  static constexpr size_t kDefaultInitialSize = 2 * MB;
+  static constexpr size_t kDefaultInitialSize = 2 * MB; // default
   // static constexpr size_t kDefaultInitialSize = 256 * MB;
   // jiacheng end
   static constexpr size_t kDefaultMaximumSize = 256 * MB;
@@ -225,7 +228,105 @@ class Heap {
   ~Heap();
 
   // jiacheng start
+  class RelocateHotnessTask;
+
+  void ForeToBack();
+
+  void BackToFore();
+
+  void SetHotLaunchFlag(bool flag) {
+    hot_launch_flag_.store(flag, std::memory_order_relaxed);
+  }
+
+  bool GetHotLaunchFlag() {
+    return hot_launch_flag_.load(std::memory_order_relaxed);
+  }
+
+  void SetDuringGcFlag(bool flag) {
+      during_gc_flag_.store(flag, std::memory_order_relaxed);
+  }
+
+  void SetPerceptibleFlag(bool flag) {
+      perceptible_flag_.store(flag, std::memory_order_relaxed);
+  }
+
+  bool GetPerceptibleFlag(){
+      return perceptible_flag_.load(std::memory_order_relaxed);
+  }
+
+  bool GetDuringGcFlag() {
+      return during_gc_flag_.load(std::memory_order_relaxed);
+  }
+
+  void DoRelocateHotness() REQUIRES(!*gc_complete_lock_, !*pending_task_lock_);
+
+  void ClearRelocateHotness(Thread* self) REQUIRES(!*pending_task_lock_);
+
+  void RequestRelocateHotness(uint64_t delta_time) REQUIRES(!*pending_task_lock_);
+
   void JiachengDebug();
+
+  void SetDoneRelocateHotness(bool flag) {
+    done_relocate_hotness_flag_.store(flag, std::memory_order_relaxed);
+  }
+
+  bool GetDoneRelocateHotness() {
+    return done_relocate_hotness_flag_.load(std::memory_order_relaxed);
+  }
+
+  size_t DoMadviseSpaces();
+
+  void DoMadviseSpacesAsync();
+
+  void JiachengDebugCardTable1() REQUIRES(Locks::heap_bitmap_lock_) REQUIRES_SHARED(Locks::mutator_lock_);;
+
+  void JiachengDebugCardTable2() REQUIRES(Locks::heap_bitmap_lock_) REQUIRES_SHARED(Locks::mutator_lock_);
+
+
+  void AddMutatorWs(mirror::Object* obj) {
+    mutator_ws_lock_.ExclusiveLock(Thread::Current());
+    mutator_ws_.insert(obj);
+    mutator_ws_lock_.ExclusiveUnlock(Thread::Current());
+  }
+
+  void AddGcWs(mirror::Object* obj) {
+    gc_ws_lock_.ExclusiveLock(Thread::Current());
+    gc_ws_.insert(obj);
+    gc_ws_lock_.ExclusiveUnlock(Thread::Current());
+  }
+
+  void AddWs(mirror::Object* obj);
+
+
+  void ClearMutatorWs() {
+    mutator_ws_lock_.ExclusiveLock(Thread::Current());
+    mutator_ws_.clear();
+    mutator_ws_lock_.ExclusiveUnlock(Thread::Current());
+  }
+
+  void ClearGcWs() {
+    gc_ws_lock_.ExclusiveLock(Thread::Current());
+    gc_ws_.clear();
+    gc_ws_lock_.ExclusiveUnlock(Thread::Current());
+  }
+
+  uint64_t GetMutatorWsSize() {
+    mutator_ws_lock_.ExclusiveLock(Thread::Current());
+    uint64_t result = mutator_ws_.size();
+    mutator_ws_lock_.ExclusiveUnlock(Thread::Current());
+    return result;
+  }
+
+  uint64_t GetGcWsSize() {
+    gc_ws_lock_.ExclusiveLock(Thread::Current());
+    uint64_t result = gc_ws_.size();
+    gc_ws_lock_.ExclusiveUnlock(Thread::Current());
+    return result;
+  }
+
+  
+
+
   // jiacheng end
 
   // Allocates and initializes storage for an object instance.
@@ -530,6 +631,12 @@ class Heap {
     return card_table_.get();
   }
 
+  // jiacheng start
+  accounting::CardTable* GetCardTable2() const {
+    return card_table2_.get();
+  }
+  // jiacheng end
+
   accounting::ReadBarrierTable* GetReadBarrierTable() const {
     return rb_table_.get();
   }
@@ -1228,6 +1335,10 @@ class Heap {
   // The card table, dirtied by the write barrier.
   std::unique_ptr<accounting::CardTable> card_table_;
 
+  // jiacheng start
+  std::unique_ptr<accounting::CardTable> card_table2_;
+  // jiacheng end
+
   std::unique_ptr<accounting::ReadBarrierTable> rb_table_;
 
   // A mod-union table remembers all of the references from the it's space to other spaces.
@@ -1570,6 +1681,28 @@ class Heap {
   Atomic<GcPauseListener*> gc_pause_listener_;
 
   std::unique_ptr<Verification> verification_;
+  
+  // jiacheng start
+  std::atomic<bool> during_gc_flag_;
+
+  // Foreground (true), background (false)
+  std::atomic<bool> perceptible_flag_;
+
+  RelocateHotnessTask* pending_relocate_hotness_ GUARDED_BY(pending_task_lock_);
+
+  std::atomic<bool> done_relocate_hotness_flag_;
+
+  std::atomic<bool> hot_launch_flag_; // true: during hot launch, false: otherwise
+
+  std::unique_ptr<std::future<size_t>> madvise_spaces_size_;
+
+
+  Mutex mutator_ws_lock_;
+  std::unordered_set<mirror::Object*> mutator_ws_;
+
+  Mutex gc_ws_lock_;
+  std::unordered_set<mirror::Object*> gc_ws_;
+  // jiacheng end
 
   friend class CollectorTransitionTask;
   friend class collector::GarbageCollector;
diff --git a/runtime/gc/space/dlmalloc_space.cc b/runtime/gc/space/dlmalloc_space.cc
index 7955ff92e6..58fdc851e2 100644
--- a/runtime/gc/space/dlmalloc_space.cc
+++ b/runtime/gc/space/dlmalloc_space.cc
@@ -32,6 +32,10 @@
 #include "thread.h"
 #include "thread_list.h"
 
+// jiacheng start
+#include "jiacheng_utils.h"
+// jiacheng end
+
 namespace art {
 namespace gc {
 namespace space {
@@ -373,6 +377,28 @@ void DlMallocSpace::LogFragmentationAllocFailure(std::ostream& os,
      <<  max_contiguous_allocation << " bytes)";
 }
 
+
+// jiacheng start
+uint64_t DlMallocSpace::Madvise() {
+  uint64_t size = 0;
+  WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* arg) {
+    uint64_t* size_ptr = reinterpret_cast<uint64_t*>(arg);
+    if (start != end) {
+        size_t length = reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start);
+        *size_ptr += length;
+        jiacheng::ColdRange(start, length);
+    }
+  };
+  Walk(walk_callback, &size);
+  return size;
+}
+
+bool DlMallocSpace::HandleFault(mirror::Object* obj) {
+  LOG(INFO) << "jiacheng debug DlMallocSpace::HandleFault() obj= " << obj;
+  return false;
+}
+// jiacheng end
+
 }  // namespace space
 
 namespace allocator {
diff --git a/runtime/gc/space/dlmalloc_space.h b/runtime/gc/space/dlmalloc_space.h
index 930f557125..790739f0fe 100644
--- a/runtime/gc/space/dlmalloc_space.h
+++ b/runtime/gc/space/dlmalloc_space.h
@@ -52,6 +52,13 @@ class DlMallocSpace : public MallocSpace {
                                size_t capacity,
                                bool can_move_objects);
 
+
+  // jiacheng start
+  uint64_t Madvise();
+
+  bool HandleFault(mirror::Object* obj);
+  // jiacheng end
+
   // Virtual to allow MemoryToolMallocSpace to intercept.
   mirror::Object* AllocWithGrowth(Thread* self,
                                   size_t num_bytes,
diff --git a/runtime/gc/space/large_object_space.cc b/runtime/gc/space/large_object_space.cc
index 2c18888c5f..3d29f884a4 100644
--- a/runtime/gc/space/large_object_space.cc
+++ b/runtime/gc/space/large_object_space.cc
@@ -35,6 +35,11 @@
 #include "space-inl.h"
 #include "thread-current-inl.h"
 
+// jiacheng start
+#include "jiacheng_utils.h"
+#include "jiacheng_hack.h"
+// jiacheng end
+
 namespace art {
 namespace gc {
 namespace space {
@@ -642,6 +647,66 @@ std::pair<uint8_t*, uint8_t*> FreeListSpace::GetBeginEndAtomic() const {
   return std::make_pair(Begin(), End());
 }
 
+// jiacheng start
+void LargeObjectSpace::CopyForegroundToMarked() {
+  mark_bitmap_->CopyFrom(foreground_live_bitmap_.get());
+}
+
+void LargeObjectSpace::CopyMarkedToForeground() {
+  foreground_live_bitmap_->CopyFrom(mark_bitmap_.get());
+}
+
+void LargeObjectSpace::Debug() {
+  LOG(INFO) << "jiacheng LargeObjectSpace::Debug()"
+            << " Begin()= " << reinterpret_cast<void*>(Begin())
+            << " End()= " << reinterpret_cast<void*>(End());
+}
+
+uint64_t LargeObjectMapSpace::Madvise() {
+  uint64_t size = 0;
+  DlMallocSpace::WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* arg) {
+    uint64_t* size_ptr = reinterpret_cast<uint64_t*>(arg);
+    if (start != end) {
+        size_t length = reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start);
+        length = RoundDown(length, kPageSize);
+        *size_ptr += length;
+        jiacheng::ColdRange(start, length);
+    }
+  };
+  Walk(walk_callback, &size);
+  LOG(INFO) << "jiacheng debug LargeObjectMapSpace::Madvise()"
+            << " size(mb)= " << float(size)/MB;
+  return size;
+}
+
+uint64_t FreeListSpace::Madvise() {
+  uint64_t size = 0;
+  DlMallocSpace::WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* arg) {
+    uint64_t* size_ptr = reinterpret_cast<uint64_t*>(arg);
+    if (start != end) {
+        size_t length = reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start);
+        *size_ptr += length;
+        jiacheng::ColdRange(start, length);
+    }
+  };
+  Walk(walk_callback, &size);
+  LOG(INFO) << "jiacheng debug FreeListSpace::Madvise()"
+            << " size(mb)= " << float(size)/MB;
+  return size;
+}
+
+bool LargeObjectMapSpace::HandleFault(mirror::Object* obj) {
+  LOG(INFO) << "jiacheng debug LargeObjectMapSpace::HandleFault() obj= " << obj;
+  return false;
+}
+
+bool FreeListSpace::HandleFault(mirror::Object* obj) {
+  LOG(INFO) << "jiacheng debug FreeListSpace::HandleFault() obj= " << obj;
+  return false;
+}
+
+// jiacheng end
+
 }  // namespace space
 }  // namespace gc
 }  // namespace art
diff --git a/runtime/gc/space/large_object_space.h b/runtime/gc/space/large_object_space.h
index 4d1cbc0dd0..8acfc07cad 100644
--- a/runtime/gc/space/large_object_space.h
+++ b/runtime/gc/space/large_object_space.h
@@ -42,11 +42,24 @@ enum class LargeObjectSpaceType {
 // Abstraction implemented by all large object spaces.
 class LargeObjectSpace : public DiscontinuousSpace, public AllocSpace {
  public:
+ // jiacheng start
+  virtual uint64_t Madvise() = 0;
+
+  virtual bool HandleFault(mirror::Object* obj) = 0;
+
+  void CopyForegroundToMarked() REQUIRES(Locks::heap_bitmap_lock_);
+
+  void CopyMarkedToForeground() REQUIRES(Locks::heap_bitmap_lock_);
+
+  void Debug();
+ // jiacheng end
+
   SpaceType GetType() const override {
     return kSpaceTypeLargeObjectSpace;
   }
   void SwapBitmaps();
   void CopyLiveToMarked();
+
   virtual void Walk(DlMallocSpace::WalkCallback, void* arg) = 0;
   virtual ~LargeObjectSpace() {}
 
@@ -163,7 +176,10 @@ class LargeObjectMapSpace : public LargeObjectSpace {
   bool Contains(const mirror::Object* obj) const override NO_THREAD_SAFETY_ANALYSIS;
   void ForEachMemMap(std::function<void(const MemMap&)> func) const override REQUIRES(!lock_);
   std::pair<uint8_t*, uint8_t*> GetBeginEndAtomic() const override REQUIRES(!lock_);
-
+  // jiacheng start
+  uint64_t Madvise() override REQUIRES(!lock_);
+  bool HandleFault(mirror::Object* obj) override;
+  // jiacheng end
  protected:
   struct LargeObject {
     MemMap mem_map;
@@ -196,7 +212,10 @@ class FreeListSpace final : public LargeObjectSpace {
   void Dump(std::ostream& os) const override REQUIRES(!lock_);
   void ForEachMemMap(std::function<void(const MemMap&)> func) const override REQUIRES(!lock_);
   std::pair<uint8_t*, uint8_t*> GetBeginEndAtomic() const override REQUIRES(!lock_);
-
+  // jiacheng start
+  uint64_t Madvise() override REQUIRES(!lock_);
+  bool HandleFault(mirror::Object* obj) override;
+  // jiacheng end
  protected:
   FreeListSpace(const std::string& name, MemMap&& mem_map, uint8_t* begin, uint8_t* end);
   size_t GetSlotIndexForAddress(uintptr_t address) const {
diff --git a/runtime/gc/space/malloc_space.cc b/runtime/gc/space/malloc_space.cc
index 474231bb40..2a2171be6d 100644
--- a/runtime/gc/space/malloc_space.cc
+++ b/runtime/gc/space/malloc_space.cc
@@ -73,6 +73,11 @@ MallocSpace::MallocSpace(const std::string& name,
         Begin(), NonGrowthLimitCapacity()));
     CHECK(mark_bitmap_.get() != nullptr) << "could not create allocspace mark bitmap #"
         << bitmap_index;
+    // jiacheng start
+    foreground_live_bitmap_.reset(accounting::ContinuousSpaceBitmap::Create(
+        StringPrintf("allocspace %s foreground-live-bitmap %d", name.c_str(), static_cast<int>(bitmap_index)),
+        Begin(), NonGrowthLimitCapacity()));
+    // jiacheng end
   }
   for (auto& freed : recent_freed_objects_) {
     freed.first = nullptr;
@@ -288,6 +293,23 @@ void MallocSpace::ClampGrowthLimit() {
   limit_ = Begin() + new_capacity;
 }
 
+// jiacheng start
+void MallocSpace::CopyForegroundToMarked() {
+  mark_bitmap_->CopyFrom(foreground_live_bitmap_.get());
+}
+
+void MallocSpace::CopyMarkedToForeground() {
+  foreground_live_bitmap_->CopyFrom(mark_bitmap_.get());
+}
+
+void MallocSpace::Debug() {
+  LOG(INFO) << "jiacheng MallocSpace::Debug()"
+            << " Begin()= " << reinterpret_cast<void*>(Begin())
+            << " End()= " << reinterpret_cast<void*>(End());
+}
+
+// jiacheng end
+
 }  // namespace space
 }  // namespace gc
 }  // namespace art
diff --git a/runtime/gc/space/malloc_space.h b/runtime/gc/space/malloc_space.h
index 50006568ca..94ecd6a0b1 100644
--- a/runtime/gc/space/malloc_space.h
+++ b/runtime/gc/space/malloc_space.h
@@ -143,6 +143,14 @@ class MallocSpace : public ContinuousMemMapAllocSpace {
     can_move_objects_ = false;
   }
 
+  // jiacheng start
+  void CopyForegroundToMarked() REQUIRES(Locks::heap_bitmap_lock_);
+
+  void CopyMarkedToForeground() REQUIRES(Locks::heap_bitmap_lock_);
+
+  void Debug();
+  // jiacheng end
+
  protected:
   MallocSpace(const std::string& name,
               MemMap&& mem_map,
diff --git a/runtime/gc/space/region_space-inl.h b/runtime/gc/space/region_space-inl.h
index 215458b1a0..1e51b8f995 100644
--- a/runtime/gc/space/region_space-inl.h
+++ b/runtime/gc/space/region_space-inl.h
@@ -24,6 +24,11 @@
 #include "region_space.h"
 #include "thread-current-inl.h"
 
+// jiacheng start
+#include "jiacheng_utils.h"
+#include "jiacheng_hack.h"
+// jiacheng end
+
 namespace art {
 namespace gc {
 namespace space {
@@ -151,18 +156,6 @@ inline uint64_t RegionSpace::GetBytesAllocatedInternal() {
           bytes += r->BytesAllocated();
         }
         break;
-      // jiacheng start
-      case RegionType::kRegionTypeColdToSpace:
-        if (r->IsInColdToSpace()) {
-          bytes += r->BytesAllocated();
-        }
-        break;
-      case RegionType::kRegionTypeColdSpace:
-        if (r->IsInToSpace()) {
-          bytes += r->BytesAllocated();
-        }
-        break;
-      // jiacheng end
       default:
         LOG(FATAL) << "Unexpected space type : " << kRegionType;
     }
@@ -198,18 +191,6 @@ inline uint64_t RegionSpace::GetObjectsAllocatedInternal() {
           bytes += r->ObjectsAllocated();
         }
         break;
-      // jiacheng start
-      case RegionType::kRegionTypeColdToSpace:
-        if (r->IsInColdToSpace()) {
-          bytes += r->ObjectsAllocated();
-        }
-        break;
-      case RegionType::kRegionTypeColdSpace:
-        if (r->IsInToSpace()) {
-          bytes += r->ObjectsAllocated();
-        }
-        break;
-      // jiacheng end
       default:
         LOG(FATAL) << "Unexpected space type : " << kRegionType;
     }
diff --git a/runtime/gc/space/region_space.cc b/runtime/gc/space/region_space.cc
index c8d97b77da..1b7c06c840 100644
--- a/runtime/gc/space/region_space.cc
+++ b/runtime/gc/space/region_space.cc
@@ -121,12 +121,13 @@ RegionSpace::RegionSpace(const std::string& name, MemMap&& mem_map, bool use_gen
       max_peak_num_non_free_regions_(0U),
       non_free_region_index_limit_(0U),
       current_region_(&full_region_),
-      evac_region_(nullptr),
       // jiacheng start
-      // cyclic_alloc_region_index_(0U) {
-      cyclic_alloc_region_index_(0U),
-      current_cold_region_(nullptr) {
-      // jiacheng end
+      current_launch_region_(&full_region_),
+      current_hot_region_(&full_region_),
+      current_cold_region_(&full_region_),
+      // jiachen end
+      evac_region_(nullptr),
+      cyclic_alloc_region_index_(0U) {
   CHECK_ALIGNED(mem_map_.Size(), kRegionSize);
   CHECK_ALIGNED(mem_map_.Begin(), kRegionSize);
   DCHECK_GT(num_regions_, 0U);
@@ -137,6 +138,10 @@ RegionSpace::RegionSpace(const std::string& name, MemMap&& mem_map, bool use_gen
   }
   mark_bitmap_.reset(
       accounting::ContinuousSpaceBitmap::Create("region space live bitmap", Begin(), Capacity()));
+  // jiacheng start
+  foreground_live_bitmap_.reset(
+    accounting::ContinuousSpaceBitmap::Create("region space foreground live bitmap", Begin(), Capacity()));
+  // jiacheng end
   if (kIsDebugBuild) {
     CHECK_EQ(regions_[0].Begin(), Begin());
     for (size_t i = 0; i < num_regions_; ++i) {
@@ -296,6 +301,18 @@ inline bool RegionSpace::Region::ShouldBeEvacuated(EvacMode evac_mode) {
       result = false;
     }
   }
+  // jiacheng start
+  else if (evac_mode == kEvacModeBackgroundGen) {
+    bool foreground_region = hotness_ == jiacheng::HOTNESS_LAUNCH || 
+                             hotness_ == jiacheng::HOTNESS_COLD ||
+                             hotness_ == jiacheng::HOTNESS_WORKING_SET;
+    if (foreground_region) {
+      result = false;
+    } else {
+      return true;
+    }
+  }
+  // jiacheng end
   return result;
 }
 
@@ -339,14 +356,6 @@ void RegionSpace::ZeroLiveBytesForLargeObject(mirror::Object* obj) {
 void RegionSpace::SetFromSpace(accounting::ReadBarrierTable* rb_table,
                                EvacMode evac_mode,
                                bool clear_live_bytes) {
-  // jiacheng start
-  // if (jiacheng::IsWhiteApp()) {
-  //   LOG(INFO) << "jiacheng region_space.cc 343 RegionSpace::SetFromSpace()"
-  //             << " evac_mode= " << evac_mode
-  //             << " clear_live_bytes= " << clear_live_bytes;
-  // }
-  // jiacheng end
-  
   // Live bytes are only preserved (i.e. not cleared) during sticky-bit CC collections.
   DCHECK(use_generational_cc_ || clear_live_bytes);
   ++time_;
@@ -369,44 +378,22 @@ void RegionSpace::SetFromSpace(accounting::ReadBarrierTable* rb_table,
     RegionState state = r->State();
     RegionType type = r->Type();
     if (!r->IsFree()) {
-      // jiacheng start
-      // DCHECK(r->IsInToSpace());
-      CHECK(r->IsInToSpace() || r->IsInColdToSpace());
-      // jiacheng end
+      DCHECK(r->IsInToSpace());
       if (LIKELY(num_expected_large_tails == 0U)) {
-        // jiacheng start
-        // DCHECK((state == RegionState::kRegionStateAllocated ||
-        //         state == RegionState::kRegionStateLarge) &&
-        //        type == RegionType::kRegionTypeToSpace);
-        CHECK((state == RegionState::kRegionStateAllocated ||
+        DCHECK((state == RegionState::kRegionStateAllocated ||
                 state == RegionState::kRegionStateLarge) &&
-               type == RegionType::kRegionTypeToSpace || type == RegionType::kRegionTypeColdToSpace);
-        // jiacheng end
+               type == RegionType::kRegionTypeToSpace);
         bool should_evacuate = r->ShouldBeEvacuated(evac_mode);
         bool is_newly_allocated = r->IsNewlyAllocated();
-        // jiacheng start
-        bool should_cold = (type == RegionType::kRegionTypeColdToSpace);
-        // if (should_evacuate) {
-        if (should_cold) {
-          r->SetAsColdSpace();
-        } else if (should_evacuate) {
-        // jiacheng end
-          r->SetAsFromSpace();
-
-          // jiacheng start
-          // if (jiacheng::IsWhiteApp()) {
-          //   LOG(INFO) << "jiacheng region_space.cc 393 RegionSpace::SetFromSpace() SetAsFromSpace()"
-          //             << " r->IsNewlyAllocated()= " << r->IsNewlyAllocated()
-          //             << " evac_mode= " << evac_mode
-          //             << " region_index= Region[" << r->Idx() << ']';
-          // }
-          // jiacheng end
 
+        if (should_evacuate) {
+          r->SetAsFromSpace();
           DCHECK(r->IsInFromSpace());
         } else {
           r->SetAsUnevacFromSpace(clear_live_bytes);
           DCHECK(r->IsInUnevacFromSpace());
         }
+
         if (UNLIKELY(state == RegionState::kRegionStateLarge &&
                      type == RegionType::kRegionTypeToSpace)) {
           prev_large_evacuated = should_evacuate;
@@ -446,10 +433,12 @@ void RegionSpace::SetFromSpace(accounting::ReadBarrierTable* rb_table,
   }
   DCHECK_EQ(num_expected_large_tails, 0U);
   current_region_ = &full_region_;
-  evac_region_ = &full_region_;
   // jiacheng start
+  current_launch_region_ = &full_region_;
+  current_hot_region_ = &full_region_;
   current_cold_region_ = &full_region_;
   // jiacheng end
+  evac_region_ = &full_region_;
 }
 
 static void ZeroAndProtectRegion(uint8_t* begin, uint8_t* end) {
@@ -596,19 +585,11 @@ void RegionSpace::ClearFromSpace(/* out */ uint64_t* cleared_bytes,
         size_t regions_to_clear_bitmap = 1;
         while (i + regions_to_clear_bitmap < num_regions_) {
           Region* const cur = &regions_[i + regions_to_clear_bitmap];
-          // jiacheng start
-          // if (!cur->AllAllocatedBytesAreLive()) {
-          //   DCHECK(!cur->IsLargeTail());
-          //   break;
-          // }
-          // CHECK(cur->IsInUnevacFromSpace());
-
-          if (!cur->AllAllocatedBytesAreLive() || cur->IsInColdSpace() || cur->IsInColdToSpace()) {
-            DCHECK(!cur->IsLargeTail()) << (cur->Type());
+          if (!cur->AllAllocatedBytesAreLive()) {
+            DCHECK(!cur->IsLargeTail());
             break;
           }
-          CHECK(cur->IsInUnevacFromSpace()) << (cur->Type());
-          // jiacheng end
+          CHECK(cur->IsInUnevacFromSpace());
           cur->SetUnevacFromSpaceAsToSpace();
           ++regions_to_clear_bitmap;
         }
@@ -665,33 +646,6 @@ void RegionSpace::ClearFromSpace(/* out */ uint64_t* cleared_bytes,
         }
       }
     }
-    // jiacheng start
-    else if (r->IsInColdSpace()) {
-      // if (r->LiveBytes() == 0) {
-      //   DCHECK(!r->IsLargeTail());
-      //   *cleared_bytes += r->BytesAllocated();
-      //   *cleared_objects += r->ObjectsAllocated();
-      //   r->Clear(/*zero_and_release_pages=*/false);
-      //   size_t free_regions = 1;
-      //   // Also release RAM for large tails.
-      //   while (i + free_regions < num_regions_ && regions_[i + free_regions].IsLargeTail()) {
-      //     regions_[i + free_regions].Clear(/*zero_and_release_pages=*/false);
-      //     ++free_regions;
-      //   }
-      //   num_non_free_regions_ -= free_regions;
-      //   // When clear_bitmap is true, this clearing of bitmap is taken care in
-      //   // clear_region().
-      //   if (!clear_bitmap) {
-      //     GetLiveBitmap()->ClearRange(
-      //         reinterpret_cast<mirror::Object*>(r->Begin()),
-      //         reinterpret_cast<mirror::Object*>(r->Begin() + free_regions * kRegionSize));
-      //   }
-      //   continue;
-      // }
-      r->SetColdSpaceAsColdToSpace();
-      // r->SetColdSpaceAsToSpace();
-    }
-    // jiacheng end
     // Note r != last_checked_region if r->IsInUnevacFromSpace() was true above.
     Region* last_checked_region = &regions_[i];
     if (!last_checked_region->IsFree()) {
@@ -704,9 +658,6 @@ void RegionSpace::ClearFromSpace(/* out */ uint64_t* cleared_bytes,
   evac_region_ = nullptr;
   num_non_free_regions_ += num_evac_regions_;
   num_evac_regions_ = 0;
-  // jiacheng start
-  current_cold_region_ = nullptr;
-  // jiacheng end
 }
 
 void RegionSpace::CheckLiveBytesAgainstRegionBitmap(Region* r) {
@@ -847,10 +798,12 @@ void RegionSpace::Clear() {
   SetNonFreeRegionLimit(0);
   DCHECK_EQ(num_non_free_regions_, 0u);
   current_region_ = &full_region_;
-  evac_region_ = &full_region_;
   // jiacheng start
+  current_launch_region_ = &full_region_;
+  current_hot_region_ = &full_region_;
   current_cold_region_ = &full_region_;
   // jiacheng end
+  evac_region_ = &full_region_;
 }
 
 void RegionSpace::Protect() {
@@ -1049,15 +1002,6 @@ size_t RegionSpace::AllocationSizeNonvirtual(mirror::Object* obj, size_t* usable
 }
 
 void RegionSpace::Region::Clear(bool zero_and_release_pages) {
-  // jiacheng start
-  // if (jiacheng::IsWhiteApp()) {
-  //   LOG(INFO) << "jiacheng region_space.cc 1047 Region::Clear()"
-  //             << " zero_and_release_pages= " << zero_and_release_pages
-  //             << " region_index= Region[" << Idx() << ']'
-  //             << " region_type= " << type_;
-  // }
-  // jiacheng end
-
   top_.store(begin_, std::memory_order_relaxed);
   state_ = RegionState::kRegionStateFree;
   type_ = RegionType::kRegionTypeNone;
@@ -1072,7 +1016,7 @@ void RegionSpace::Region::Clear(bool zero_and_release_pages) {
   thread_ = nullptr;
 
   // jiacheng start
-  remembered_set_.clear();
+  hotness_ = 0;
   // jiacheng end
 }
 
@@ -1107,13 +1051,6 @@ RegionSpace::Region* RegionSpace::AllocateRegion(bool for_evac) {
         // following the one that was just allocated.
         cyclic_alloc_region_index_ = (region_index + 1) % num_regions_;
       }
-      // jiacheng start
-      // if (jiacheng::IsWhiteApp()) {
-      //   LOG(INFO) << "jiacheng region_space.cc 1083 RegionSpace::AllocateRegion() "
-      //             << " for_evac= " << for_evac
-      //             << " region_index= Region[" << r->Idx() << ']';
-      // }
-      // jiacheng end
       return r;
     }
   }
@@ -1147,290 +1084,190 @@ void RegionSpace::Region::UnfreeLargeTail(RegionSpace* region_space, uint32_t al
 
 // jiacheng start
 
-class ColdRefVisitor {
- public:
-  explicit ColdRefVisitor(RegionSpace::Region* region): region_(region) {}
-
-  void operator()(mirror::Object* obj, MemberOffset offset, bool is_static ATTRIBUTE_UNUSED) const 
-    REQUIRES_SHARED(Locks::mutator_lock_)
-    REQUIRES_SHARED(Locks::heap_bitmap_lock_) ALWAYS_INLINE{
-    mirror::Object* ref = obj->GetFieldObject<mirror::Object, kVerifyNone, kWithoutReadBarrier, false>(offset);
-    if (!region_->Contains(ref)) {
-      region_->AddRememberedSet(reinterpret_cast<uint8_t*>(ref));
-    }
-  }
-
-  void operator()(ObjPtr<mirror::Class> klass, ObjPtr<mirror::Reference> obj) const
-      REQUIRES_SHARED(Locks::mutator_lock_) ALWAYS_INLINE {
-    CHECK(klass->IsTypeOfReferenceClass());
-    mirror::Object* ref = obj->GetReferent();
-    if (!region_->Contains(ref)) {
-      region_->AddRememberedSet(reinterpret_cast<uint8_t*>(ref));
-    }
-  }
-
-  void VisitRootIfNonNull(mirror::CompressedReference<mirror::Object>* root) const
-      ALWAYS_INLINE
-      REQUIRES_SHARED(Locks::mutator_lock_) {
-    if (!root->IsNull()) {
-      VisitRoot(root);
-    }
-  }
-
-  void VisitRoot(mirror::CompressedReference<mirror::Object>* root) const
-      ALWAYS_INLINE
-      REQUIRES_SHARED(Locks::mutator_lock_) {
-    mirror::Object* ref = root->AsMirrorPtr();
-    if (!region_->Contains(ref)) {
-      region_->AddRememberedSet(reinterpret_cast<uint8_t*>(ref));
-    }
-  }
-
- private:
-  RegionSpace::Region* region_;
-};
-
-class ColdWriteBackRefVisitor {
- public:
-  explicit ColdWriteBackRefVisitor(RegionSpace::Region* region): region_(region) {}
-
-  void operator()(mirror::Object* obj, MemberOffset offset, bool is_static ATTRIBUTE_UNUSED) const 
-    REQUIRES_SHARED(Locks::mutator_lock_)
-    REQUIRES_SHARED(Locks::heap_bitmap_lock_) ALWAYS_INLINE {
-    mirror::Object* ref = obj->GetFieldObject<mirror::Object, kVerifyNone, kWithoutReadBarrier, false>(offset);
-    mirror::Object* value = reinterpret_cast<mirror::Object*>(region_->GetRememberedSetValue(reinterpret_cast<uint8_t*>(ref)));
-    if (ref != value) {
-      obj->SetFieldObject<false>(offset, value);
-    }
-  }
-
-  void operator()(ObjPtr<mirror::Class> klass, ObjPtr<mirror::Reference> obj) const
-      REQUIRES_SHARED(Locks::mutator_lock_) ALWAYS_INLINE {
-    CHECK(klass->IsTypeOfReferenceClass());
-    mirror::Object* ref = obj->GetReferent();
-    mirror::Object* value = reinterpret_cast<mirror::Object*>(region_->GetRememberedSetValue(reinterpret_cast<uint8_t*>(ref)));
-    if (ref != value) {
-      LOG(INFO) << "jiacheng region_space.cc 1172 ref != value";
-      // obj->SetFieldObject<false>(offset, value);
-    }
-  }
-
-  void VisitRootIfNonNull(mirror::CompressedReference<mirror::Object>* root) const
-      ALWAYS_INLINE
-      REQUIRES_SHARED(Locks::mutator_lock_) {
-    if (!root->IsNull()) {
-      VisitRoot(root);
-    }
-  }
-
-  void VisitRoot(mirror::CompressedReference<mirror::Object>* root) const
-      ALWAYS_INLINE
-      REQUIRES_SHARED(Locks::mutator_lock_) {
-    mirror::Object* ref = root->AsMirrorPtr();
-    mirror::Object* value = reinterpret_cast<mirror::Object*>(region_->GetRememberedSetValue(reinterpret_cast<uint8_t*>(ref)));
-    if (ref != value) {
-      LOG(INFO) << "jiacheng region_space.cc 1191 ref != value";
-      // obj->SetFieldObject<false>(offset, value);
-    }
-  }
-
- private:
-  RegionSpace::Region* region_;
-};
-
-void RegionSpace::Region::InitRememberedSet() {
-  remembered_set_.clear();
-  if (IsFree()) {
-    return;
-  }
-  CHECK(!IsLarge() && !IsLargeTail());
-  ColdRefVisitor ref_visitor(this);
-  auto obj_visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_) {
-    obj->VisitReferences<true, kVerifyNone, kWithoutReadBarrier>(ref_visitor, ref_visitor);
-  };
-  space::RegionSpace* region_space = art::Runtime::Current()->GetHeap()->GetRegionSpace();
-  region_space->WalkNonLargeRegion(obj_visitor, this);
-
+void RegionSpace::Region::Debug() {
+  LOG(INFO) << "jiacheng Region::Debug()"
+            << " idx_= " <<  idx_
+            << " live_bytes_= " <<  live_bytes_
+            << " thread_= " <<  thread_
+            << " objects_allocated_= " <<  objects_allocated_.load()
+            << " alloc_time_= " <<  alloc_time_
+            << " is_newly_allocated_= " <<  is_newly_allocated_
+            << " is_a_tlab_= " <<  is_a_tlab_
+            << " state_= " <<  state_
+            << " type_= " <<  type_
+            << " hotness_= " <<  hotness_
+            ;
 }
 
-
-void RegionSpace::Region::WriteBackRememberedSet() {
-  if (IsFree()) {
-    return;
-  }
-  CHECK(!IsLarge() && !IsLargeTail());
-  // jiacheng start
-  LOG(INFO) << "jiacheng debug region_space.cc 1264 WriteBackRememberedSet()";
-  // jiacheng end
-  ColdWriteBackRefVisitor ref_visitor(this);
-  auto obj_visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_) {
-    obj->VisitReferences<true, kVerifyNone, kWithoutReadBarrier>(ref_visitor, ref_visitor);
-  };
-  space::RegionSpace* region_space = art::Runtime::Current()->GetHeap()->GetRegionSpace();
-  region_space->WalkNonLargeRegion(obj_visitor, this);
-  remembered_set_.clear();
-}
-
-
-void RegionSpace::Region::AddRememberedSet(uint8_t* ref) {
-  remembered_set_[ref] = ref;
-}
-
-uint8_t* RegionSpace::Region::GetRememberedSetValue(uint8_t* ref) {
-  auto it = remembered_set_.find(ref);
-  if (it == remembered_set_.end()) {
-    return nullptr;
-  }
-  return it->second;
-}
-
-std::map<uint8_t*, uint8_t*>* RegionSpace::Region::GetRememberedSet() {
-  return &remembered_set_;
-}
-
-
-void RegionSpace::Region::UnfreeCold(RegionSpace* region_space, uint32_t alloc_time) {
-  DCHECK(IsFree());
-  alloc_time_ = alloc_time;
-  region_space->AdjustNonFreeRegionLimit(idx_);
-  type_ = RegionType::kRegionTypeColdToSpace;
-  if (kProtectClearedRegions) {
-    CheckedCall(mprotect, __FUNCTION__, Begin(), kRegionSize, PROT_READ | PROT_WRITE);
-  }
-  state_ = RegionState::kRegionStateAllocated;
-}
-
-void RegionSpace::JiachengDebug() {
+void RegionSpace::Debug() {
+  uint32_t new_region_num = 0;
+  uint32_t launch_region_num = 0;
+  uint32_t working_set_region_num = 0;
+  uint32_t cold_region_num = 0;
+  uint32_t none_region_num = 0;
   MutexLock mu(Thread::Current(), region_lock_);
   for (size_t i = 0; i < std::min(num_regions_, non_free_region_index_limit_); ++i) {
     Region* r = &regions_[i];
-    std::map<uint8_t*, uint8_t*>* remembered_set = r->GetRememberedSet();
-
-    std::stringstream ss;
-    ss << "jiacheng region_space.cc 60 JiachengDebug() ";
-    ss <<  " remembered_set.size()= " << remembered_set->size() << ' ';
-    // for (auto it : *remembered_set) {
-    //   ss << " key= " << it.first << " value= " << it.second;
-    // }
-    // r->Dump(ss);
-    LOG(INFO) << ss.str();
+    if (r->Type() == RegionType::kRegionTypeNone) {
+      continue;
+    }
+    int32_t hotness = r->GetHotness();
+    if (r->IsNewlyAllocated()) {
+      ++new_region_num;
+    } else if (hotness == jiacheng::HOTNESS_LAUNCH) {
+      ++launch_region_num;
+    } else if (hotness == jiacheng::HOTNESS_WORKING_SET) {
+      ++working_set_region_num;
+    } else if (hotness == jiacheng::HOTNESS_COLD) {
+      ++cold_region_num;
+    } else {
+      ++none_region_num;
+    }
   }
+  LOG(INFO) << "jiacheng RegionSpace::Debug()"
+            << " Begin()= " << reinterpret_cast<void*>(Begin())
+            << " End()= " << reinterpret_cast<void*>(End())
+            << " launch_region_num= " << launch_region_num
+            << " working_set_region_num= " << working_set_region_num
+            << " cold_region_num= " << cold_region_num
+            << " none_region_num= " << none_region_num
+            << " new_region_num= " << new_region_num
+            ;
 }
 
-uint32_t RegionSpace::SwapOutCold() {
-  size_t swap_out_num = 0;
+
+uint64_t RegionSpace::Madvise() {
+  uint64_t swap_out_size = 0;
   uint8_t* begin, * end;
-  size_t swap_out_length;
+  size_t length;
   MutexLock mu(Thread::Current(), region_lock_);
   for (size_t i = 0; i < std::min(num_regions_, non_free_region_index_limit_); ++i) {
     Region* r = &regions_[i];
-    if (r->IsInColdToSpace() || r->IsInColdSpace()) {
-      begin = r->Begin();
-      // end = r->End();
-      end = r->Top();
-      swap_out_length = std::distance(begin, end);
-      jiacheng::SwapOutRange(begin, swap_out_length);
-      // 防止重新换入
-      CheckedCall(mprotect, __FUNCTION__, begin, swap_out_length, PROT_READ);
-      ++swap_out_num;
+    if (r->Type() != RegionType::kRegionTypeNone && !r->IsNewlyAllocated()) {
+      if (r->GetHotness() == jiacheng::HOTNESS_COLD) {
+        begin = r->Begin();
+        // end = r->Top();
+        end = r->End();
+        length = std::distance(begin, end);
+        // Change the permission of the region into READ ONLY
+        // So as to we can know the swap in of the region through handling page fault
+        // if (jiacheng::ColdRange(begin, length) && 
+        //     mprotect(begin, length, PROT_READ) == 0) {
+        
+        if (jiacheng::ColdRange(begin, length)) {
+          swap_out_size += length;
+        }
+      } else if (r->GetHotness() == jiacheng::HOTNESS_LAUNCH) {
+        jiacheng::HotRange(begin, length);
+      }
     }
   }
-  LOG(INFO) << "jiacheng region_space.cc 1336 RegionSpace::SwapOutCold() num_regions= " << swap_out_num;
-  return swap_out_num * kRegionSize;
+  LOG(INFO) << "jiacheng RegionSpace::Madvise()"
+            << " size(mb)= " << float(swap_out_size)/MB;
+  return swap_out_size;
 }
 
-bool RegionSpace::HandleFault(mirror::Object* ref) {
-  Region* r = RefToRegionUnlocked(ref);
-  // if (r->IsInColdSpace() || r->IsInColdToSpace()) {
-  uint8_t* begin = r->Begin();
-  // uint8_t* end = r->Top();
-  uint8_t* end = r->End();
-  size_t length = std::distance(begin, end);
-  if (mprotect(begin, length, PROT_READ | PROT_WRITE) == 0) { // maybe STW
-    // change cold region to normal region
-    r->SetAsToSpace();
-    // r->WriteBackRememberedSet(); 
-    LOG(INFO) << "jiacheng region_space.cc 1324 HandleFault() set PROT_READ | PROT_WRITE"
-              << " ref= " << ref
-              << " begin= " << reinterpret_cast<mirror::Object*>(begin)
-              << " end= " << reinterpret_cast<mirror::Object*>(end)
-              << " length= " << length
-              << " Success!"
-              ;
-    return true;
-  } else {
-    LOG(INFO) << "jiacheng region_space.cc 1324 HandleFault() set PROT_READ | PROT_WRITE"
-              << " ref= " << ref
-              << " begin= " << reinterpret_cast<mirror::Object*>(begin)
-              << " end= " << reinterpret_cast<mirror::Object*>(end)
-              << " length= " << length
-              << " errno= " << errno
-              << " fail!"
-              ;
-    return false;
+bool RegionSpace::HandleFault(mirror::Object* obj) {
+  CHECK(Contains(obj));
+  bool result = false;
+  Region* r = RefToRegionUnlocked(obj);
+  if (r->GetHotness() < 0) {
+    uint8_t* begin = r->Begin();
+    // uint8_t* end = r->Top();
+    uint8_t* end = r->End();
+    size_t length = std::distance(begin, end);
+    if (mprotect(begin, length, PROT_READ | PROT_WRITE) == 0) {
+      r->SetHotness(jiacheng::HOTNESS_NONE);
+      result = true;
+      LOG(INFO) << " jiacheng RegionSpace::HandleFault()" 
+                << " idx_= " << r->Idx()
+                << " length= " << length
+                << " obj= " << obj
+                ;
+    }
   }
-  // }
-  // return false;
+  return result;
 }
 
 
-RegionSpace::Region* RegionSpace::AllocateColdRegion() {
-  for (size_t i = 0; i < num_regions_; ++i) {
-    // When using the cyclic region allocation strategy, try to
-    // allocate a region starting from the last cyclic allocated
-    // region marker. Otherwise, try to allocate a region starting
-    // from the beginning of the region space.
-    size_t region_index = kCyclicRegionAllocation
-        ? ((cyclic_alloc_region_index_ + i) % num_regions_)
-        : i;
-    Region* r = &regions_[region_index];
-    if (r->IsFree()) {
-      r->UnfreeCold(this, time_);
-      ++num_non_free_regions_;
-      if (kCyclicRegionAllocation) {
-        // Move the cyclic allocation region marker to the region
-        // following the one that was just allocated.
-        cyclic_alloc_region_index_ = (region_index + 1) % num_regions_;
-      }
-      // LOG(INFO) << "jiacheng region_space.cc 1322 RegionSpace::AllocateColdRegion()"
-      //           << " region_index= Region[" << r->Idx() << ']';
-      return r;
+mirror::Object* RegionSpace::AllocLaunch(size_t num_bytes,
+                                         /* out */ size_t* bytes_allocated,
+                                         /* out */ size_t* usable_size,
+                                         /* out */ size_t* bytes_tl_bulk_allocated) {
+  DCHECK_ALIGNED(num_bytes, kAlignment);
+  mirror::Object* obj = nullptr;
+  if (LIKELY(num_bytes <= kRegionSize)) {
+    obj = current_launch_region_->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
+    if (LIKELY(obj != nullptr)) {
+      return obj;
     }
+    MutexLock mu(Thread::Current(), region_lock_);
+    obj = current_launch_region_->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
+    if (LIKELY(obj != nullptr)) {
+      return obj;
+    }
+    Region* r = AllocateRegion(/* for_evac */ true);
+    if (LIKELY(r != nullptr)) {
+      obj = r->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
+      CHECK(obj != nullptr);
+      r->SetHotness(jiacheng::HOTNESS_LAUNCH);
+      current_launch_region_ = r;
+      return obj;
+    }
+  } else {
+    // If object is large, just set as normal object
+    // CHECK(false);
+    return nullptr;
   }
+  return obj;
+}
+
+mirror::Object* RegionSpace::AllocLargeLaunch(size_t num_bytes,
+                                              /* out */ size_t* bytes_allocated,
+                                              /* out */ size_t* usable_size,
+                                              /* out */ size_t* bytes_tl_bulk_allocated) {
+  (void)num_bytes;
+  (void)bytes_allocated;
+  (void)usable_size;
+  (void)bytes_tl_bulk_allocated;
+  CHECK(false) << "RegionSpace::AllocLargeLaunch()";
   return nullptr;
 }
 
 
-mirror::Object* RegionSpace::AllocCold(size_t num_bytes,
+mirror::Object* RegionSpace::AllocWorkingSet(size_t num_bytes,
                           /* out */ size_t* bytes_allocated,
                           /* out */ size_t* usable_size,
                           /* out */ size_t* bytes_tl_bulk_allocated) {
   DCHECK_ALIGNED(num_bytes, kAlignment);
   mirror::Object* obj = nullptr;
   if (LIKELY(num_bytes <= kRegionSize)) {
-    obj = current_cold_region_->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
+    obj = current_hot_region_->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
     if (LIKELY(obj != nullptr)) {
       return obj;
     }
     MutexLock mu(Thread::Current(), region_lock_);
-    obj = current_cold_region_->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
+    obj = current_hot_region_->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
     if (LIKELY(obj != nullptr)) {
       return obj;
     }
-    Region* r = AllocateColdRegion();
+    Region* r = AllocateRegion(/* for_evac */ true);
     if (LIKELY(r != nullptr)) {
       obj = r->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
       CHECK(obj != nullptr);
-      current_cold_region_ = r;
+      r->SetHotness(jiacheng::HOTNESS_WORKING_SET);
+      current_hot_region_ = r;
       return obj;
     }
   } else {
-    obj = AllocLargeCold(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
+    // If object is large, just set as normal object
+    // CHECK(false);
+    return nullptr;
   }
   return obj;
 }
 
-mirror::Object* RegionSpace::AllocLargeCold(size_t num_bytes,
+mirror::Object* RegionSpace::AllocLargeWorkingSet(size_t num_bytes,
                                 /* out */ size_t* bytes_allocated,
                                 /* out */ size_t* usable_size,
                                 /* out */ size_t* bytes_tl_bulk_allocated) {
@@ -1438,33 +1275,65 @@ mirror::Object* RegionSpace::AllocLargeCold(size_t num_bytes,
   (void)bytes_allocated;
   (void)usable_size;
   (void)bytes_tl_bulk_allocated;
+  CHECK(false) << "RegionSpace::AllocLargeWorkingSet()";
   return nullptr;
 }
 
-void RegionSpace::InitColdToRegionRememberedSet() {
-  MutexLock mu(Thread::Current(), region_lock_);
-  for (size_t i = 0; i < std::min(num_regions_, non_free_region_index_limit_); ++i) {
-    Region* r = &regions_[i];
-    if (!r->IsInColdToSpace()) {
-      continue;
+
+mirror::Object* RegionSpace::AllocCold(size_t num_bytes,
+                                       /* out */ size_t* bytes_allocated,
+                                       /* out */ size_t* usable_size,
+                                       /* out */ size_t* bytes_tl_bulk_allocated) {
+  DCHECK_ALIGNED(num_bytes, kAlignment);
+  mirror::Object* obj = nullptr;
+  if (LIKELY(num_bytes <= kRegionSize)) {
+    obj = current_cold_region_->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
+    if (LIKELY(obj != nullptr)) {
+      return obj;
     }
-    r->InitRememberedSet();
+    MutexLock mu(Thread::Current(), region_lock_);
+    obj = current_cold_region_->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
+    if (LIKELY(obj != nullptr)) {
+      return obj;
+    }
+    Region* r = AllocateRegion(/* for_evac */ true);
+    if (LIKELY(r != nullptr)) {
+      obj = r->Alloc(num_bytes, bytes_allocated, usable_size, bytes_tl_bulk_allocated);
+      CHECK(obj != nullptr);
+      r->SetHotness(jiacheng::HOTNESS_COLD);
+      current_cold_region_ = r;
+      return obj;
+    }
+  } else {
+    // If object is large, just set as normal object
+    // CHECK(false);
+    return nullptr;
   }
+  return obj;
 }
 
-void RegionSpace::WriteBackRegionRememberedSet() {
+
+void RegionSpace::ResetHotness() {
   MutexLock mu(Thread::Current(), region_lock_);
-  // FIFO because of kCyclicRegionAllocation
   for (size_t i = 0; i < std::min(num_regions_, non_free_region_index_limit_); ++i) {
     Region* r = &regions_[i];
-    if (!r->IsInColdToSpace()) {
-      continue;
+    if (r->Type() != RegionType::kRegionTypeNone) {
+      r->SetHotness(jiacheng::HOTNESS_NONE);
     }
-    r->WriteBackRememberedSet();
-    break;
   }
+
 }
 
+
+void RegionSpace::CopyForegroundToMarked() {
+  mark_bitmap_->CopyFrom(foreground_live_bitmap_.get());
+}
+
+void RegionSpace::CopyMarkedToForeground() {
+  foreground_live_bitmap_->CopyFrom(mark_bitmap_.get());
+}
+
+
 // jiacheng end
 
 }  // namespace space
diff --git a/runtime/gc/space/region_space.h b/runtime/gc/space/region_space.h
index 9f5d99eefa..8f74ea0521 100644
--- a/runtime/gc/space/region_space.h
+++ b/runtime/gc/space/region_space.h
@@ -47,6 +47,9 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
 
   enum EvacMode {
     kEvacModeNewlyAllocated,
+    // jiacheng start
+    kEvacModeBackgroundGen,
+    // jiacheng end
     kEvacModeLivePercentNewlyAllocated,
     kEvacModeForceAll,
   };
@@ -153,11 +156,6 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
     kRegionTypeFromSpace,        // From-space. To be evacuated.
     kRegionTypeUnevacFromSpace,  // Unevacuated from-space. Not to be evacuated.
     kRegionTypeToSpace,          // To-space.
-    // jiacheng start
-    kRegionTypeColdSpace,
-    kRegionTypeColdToSpace,
-    kRegionTypeHotSpace,
-    // jiacheng end
     kRegionTypeNone,             // None.
   };
 
@@ -397,7 +395,7 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
           // jiacheng start
           // type_(RegionType::kRegionTypeToSpace) {}
           type_(RegionType::kRegionTypeToSpace),
-          remembered_set_() {}
+          hotness_(0) {}
           // jiacheng end
 
     void Init(size_t idx, uint8_t* begin, uint8_t* end) {
@@ -416,7 +414,7 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
       DCHECK_LT(begin, end);
       DCHECK_EQ(static_cast<size_t>(end - begin), kRegionSize);
       // jiacheng start
-      remembered_set_.clear();
+      hotness_ = 0;
       // jiacheng end
     }
 
@@ -434,24 +432,6 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
                                         /* out */ size_t* bytes_allocated,
                                         /* out */ size_t* usable_size,
                                         /* out */ size_t* bytes_tl_bulk_allocated);
-    // jiacheng start
-    void InitRememberedSet();
-
-    void WriteBackRememberedSet();
-
-    void AddRememberedSet(uint8_t* ref);
-
-    uint8_t* GetRememberedSetValue(uint8_t* ref);
-
-    std::map<uint8_t*, uint8_t*>* GetRememberedSet();
-
-    template <typename Visitor>
-    void VisitRegionRememberedObjects(const Visitor& visitor) REQUIRES_SHARED(Locks::mutator_lock_) {
-      for (auto& x : remembered_set_) {
-        visitor(reinterpret_cast<mirror::Object*>(x.second));
-      }
-    }
-    // jiacheng end
 
     bool IsFree() const {
       bool is_free = (state_ == RegionState::kRegionStateFree);
@@ -467,11 +447,6 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
     void Unfree(RegionSpace* region_space, uint32_t alloc_time)
         REQUIRES(region_space->region_lock_);
 
-    // jiacheng start
-    void UnfreeCold(RegionSpace* region_space, uint32_t alloc_time)
-        REQUIRES(region_space->region_lock_);
-    // jiacheng end
-
     // Given a free region, declare it non-free (allocated) and large.
     void UnfreeLarge(RegionSpace* region_space, uint32_t alloc_time)
         REQUIRES(region_space->region_lock_);
@@ -538,20 +513,6 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
       return type_ == RegionType::kRegionTypeUnevacFromSpace;
     }
 
-    // jiacheng start
-    bool IsInColdSpace() const {
-      return type_ == RegionType::kRegionTypeColdSpace;
-    }
-
-    bool IsInColdToSpace() const {
-      return type_ == RegionType::kRegionTypeColdToSpace;
-    }
-
-    bool IsInHotSpace() const {
-      return type_ == RegionType::kRegionTypeHotSpace;
-    }
-    // jiacheng end
-
     bool IsInNoSpace() const {
       return type_ == RegionType::kRegionTypeNone;
     }
@@ -590,32 +551,6 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
       type_ = RegionType::kRegionTypeToSpace;
     }
 
-    // jiacheng start
-    void SetAsToSpace() {
-      is_newly_allocated_ = false;
-      type_ = RegionType::kRegionTypeToSpace;
-    }
-
-    void SetAsColdSpace() {
-      is_newly_allocated_ = false;
-      type_ = RegionType::kRegionTypeColdSpace;
-    }
-
-    void SetAsColdToSpace() {
-      type_ = RegionType::kRegionTypeColdToSpace;
-    }
-
-    void SetColdSpaceAsColdToSpace() {
-      DCHECK(!IsFree() && IsInColdSpace());
-      type_ = RegionType::kRegionTypeColdToSpace;
-    }
-
-    void SetColdSpaceAsToSpace() {
-      DCHECK(!IsFree() && IsInColdSpace());
-      type_ = RegionType::kRegionTypeToSpace;
-    }
-    // jiacheng end
-
     // Return whether this region should be evacuated. Used by RegionSpace::SetFromSpace.
     ALWAYS_INLINE bool ShouldBeEvacuated(EvacMode evac_mode);
 
@@ -674,6 +609,18 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
 
     uint64_t GetLongestConsecutiveFreeBytes() const;
 
+    // jiacheng start
+    int32_t GetHotness() {
+      return hotness_;
+    }
+
+    void SetHotness(int32_t hotness) {
+      hotness_ = hotness;
+    }
+
+    void Debug();
+    // jiacheng end
+
    private:
     static bool GetUseGenerationalCC();
 
@@ -698,7 +645,7 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
     RegionType type_;                   // The region type (see RegionType).
 
     // jiacheng start
-    std::map<uint8_t*, uint8_t*> remembered_set_;  // TODO: Change to java object so as to process in GC process easily
+    int32_t hotness_; 
     // jiacheng end
 
     friend class RegionSpace;
@@ -807,77 +754,45 @@ class RegionSpace final : public ContinuousMemMapAllocSpace {
 
   // jiacheng start
 public:
-  bool IsInColdSpace(mirror::Object* ref) {
-    if (HasAddress(ref)) {
-      Region* r = RefToRegionUnlocked(ref);
-      return r->IsInColdSpace();
-    }
-    return false;
-  }
 
-  bool IsInColdToSpace(mirror::Object* ref) {
-    if (HasAddress(ref)) {
-      Region* r = RefToRegionUnlocked(ref);
-      return r->IsInColdToSpace();
-    }
-    return false;
-  }
+  void Debug() REQUIRES(!region_lock_);
+
+  uint64_t Madvise() REQUIRES(!region_lock_);
 
-  void JiachengDebug() REQUIRES(!region_lock_);
+  bool HandleFault(mirror::Object* obj) REQUIRES(!region_lock_);
 
-  uint32_t SwapOutCold() REQUIRES(!region_lock_);
+  mirror::Object* AllocLaunch(size_t num_bytes,
+                              /* out */ size_t* bytes_allocated,
+                              /* out */ size_t* usable_size,
+                              /* out */ size_t* bytes_tl_bulk_allocated) REQUIRES(!region_lock_);
 
-  bool HandleFault(mirror::Object* ref) REQUIRES(!region_lock_);
+  mirror::Object* AllocLargeLaunch(size_t num_bytes,
+                                   /* out */ size_t* bytes_allocated,
+                                   /* out */ size_t* usable_size,
+                                   /* out */ size_t* bytes_tl_bulk_allocated) REQUIRES(!region_lock_);
 
-  Region* AllocateColdRegion() REQUIRES(region_lock_);
+  mirror::Object* AllocWorkingSet(size_t num_bytes,
+                                  /* out */ size_t* bytes_allocated,
+                                  /* out */ size_t* usable_size,
+                                  /* out */ size_t* bytes_tl_bulk_allocated) REQUIRES(!region_lock_);
+
+  mirror::Object* AllocLargeWorkingSet(size_t num_bytes,
+                                       /* out */ size_t* bytes_allocated,
+                                       /* out */ size_t* usable_size,
+                                       /* out */ size_t* bytes_tl_bulk_allocated) REQUIRES(!region_lock_);
 
   mirror::Object* AllocCold(size_t num_bytes,
                             /* out */ size_t* bytes_allocated,
                             /* out */ size_t* usable_size,
                             /* out */ size_t* bytes_tl_bulk_allocated) REQUIRES(!region_lock_);
 
-  mirror::Object* AllocLargeCold(size_t num_bytes,
-                                /* out */ size_t* bytes_allocated,
-                                /* out */ size_t* usable_size,
-                                /* out */ size_t* bytes_tl_bulk_allocated) REQUIRES(!region_lock_);
 
-  void InitColdToRegionRememberedSet() REQUIRES(!region_lock_);
+  void ResetHotness();
 
-  void WriteBackRegionRememberedSet() REQUIRES(!region_lock_);
+  void CopyForegroundToMarked() REQUIRES(Locks::heap_bitmap_lock_);
 
-  template<typename Visitor>
-  void VisitRememberedObjectsAsRoot(Visitor& visitor) REQUIRES(!region_lock_) REQUIRES_SHARED(Locks::mutator_lock_) {
-    Thread* self = Thread::Current();
-    LOG(INFO) << "jiacheng region_space.h 839 VisitRememberedObjectsAsRoot() ";
-    MutexLock mu(self, region_lock_);
-    for (size_t i = 0; i < std::min(num_regions_, non_free_region_index_limit_); ++i) {
-      Region* r = &regions_[i];
-      if (!r->IsInColdSpace()) {
-        continue;
-      }
-      std::map<uint8_t*, uint8_t*>* remembered_set = r->GetRememberedSet();
-      for (auto& it : *remembered_set) {
-        uint8_t** ref = &(it.second);
-        *ref = reinterpret_cast<uint8_t*>(visitor(reinterpret_cast<mirror::Object*>(*ref)));
-      }
-      LOG(INFO) << "jiacheng region_space.h 850 i= " << i;
-    }
-  }
+  void CopyMarkedToForeground() REQUIRES(Locks::heap_bitmap_lock_);
 
-  template<typename Visitor>
-  void VisitRememberedObjects(Visitor& visitor) REQUIRES(!region_lock_) REQUIRES_SHARED(Locks::mutator_lock_) {
-    Thread* self = Thread::Current();
-    LOG(INFO) << "jiacheng region_space.h 858 VisitRememberedObjects() ";
-    MutexLock mu(self, region_lock_);
-    for (size_t i = 0; i < std::min(num_regions_, non_free_region_index_limit_); ++i) {
-      Region* r = &regions_[i];
-      if (!r->IsInColdSpace()) {
-        continue;
-      }
-      r->VisitRegionRememberedObjects(visitor);
-      LOG(INFO) << "jiacheng region_space.h 866 i= " << i;
-    }
-  }
 private:
   // jiacheng end
 
@@ -909,9 +824,15 @@ private:
   size_t non_free_region_index_limit_ GUARDED_BY(region_lock_);
 
   Region* current_region_;         // The region currently used for allocation.
+  // jiacheng start
+  Region* current_launch_region_;  // Objects accessed in hot launch
+  Region* current_hot_region_;    // Objects in the background working set
+  Region* current_cold_region_;  // Objects without GC in the background
+  // jiacheng end
   Region* evac_region_;            // The region currently used for evacuation.
   Region full_region_;             // The dummy/sentinel region that looks full.
 
+
   // Index into the region array pointing to the starting region when
   // trying to allocate a new region. Only used when
   // `kCyclicRegionAllocation` is true.
@@ -921,7 +842,7 @@ private:
   std::unique_ptr<accounting::ContinuousSpaceBitmap> mark_bitmap_;
 
   // jiacheng start
-  Region* current_cold_region_;
+  std::unique_ptr<accounting::ContinuousSpaceBitmap> foreground_live_bitmap_;
   // jiacheng end
 
   DISALLOW_COPY_AND_ASSIGN(RegionSpace);
diff --git a/runtime/gc/space/space.cc b/runtime/gc/space/space.cc
index e7961eb256..9ecd71e99d 100644
--- a/runtime/gc/space/space.cc
+++ b/runtime/gc/space/space.cc
@@ -87,6 +87,12 @@ DiscontinuousSpace::DiscontinuousSpace(const std::string& name,
   mark_bitmap_.reset(accounting::LargeObjectBitmap::Create("large marked objects", nullptr,
                                                            capacity));
   CHECK(mark_bitmap_.get() != nullptr);
+
+  // jiacheng start
+  foreground_live_bitmap_.reset(accounting::LargeObjectBitmap::Create("large foreground objects", nullptr,
+                                                           capacity));
+  CHECK(foreground_live_bitmap_.get() != nullptr);
+  // jiacheng end
 }
 
 collector::ObjectBytePair ContinuousMemMapAllocSpace::Sweep(bool swap_bitmaps) {
@@ -144,6 +150,19 @@ AllocSpace::SweepCallbackContext::SweepCallbackContext(bool swap_bitmaps_in, spa
     : swap_bitmaps(swap_bitmaps_in), space(space_in), self(Thread::Current()) {
 }
 
+
+
+// jiacheng start
+void ContinuousMemMapAllocSpace::DebugBitmap() {
+  LOG(INFO) << "jiacheng ContinuousMemMapAllocSpace::DebugBitmap()"
+            << " GetName()= " << GetName()
+            << " live_bitmap_= " << live_bitmap_.get()
+            << " mark_bitmap_= " << mark_bitmap_.get()
+            << " temp_bitmap_= " << temp_bitmap_.get()
+            ;
+}
+// jiacheng end
+
 }  // namespace space
 }  // namespace gc
 }  // namespace art
diff --git a/runtime/gc/space/space.h b/runtime/gc/space/space.h
index 6a4095c09f..6182d7565f 100644
--- a/runtime/gc/space/space.h
+++ b/runtime/gc/space/space.h
@@ -364,6 +364,10 @@ class DiscontinuousSpace : public Space {
   std::unique_ptr<accounting::LargeObjectBitmap> live_bitmap_;
   std::unique_ptr<accounting::LargeObjectBitmap> mark_bitmap_;
 
+  // jiacheng start
+  std::unique_ptr<accounting::LargeObjectBitmap> foreground_live_bitmap_;
+  // jiacheng end
+
  private:
   DISALLOW_IMPLICIT_CONSTRUCTORS(DiscontinuousSpace);
 };
@@ -450,11 +454,19 @@ class ContinuousMemMapAllocSpace : public MemMapSpace, public AllocSpace {
   collector::ObjectBytePair Sweep(bool swap_bitmaps);
   virtual accounting::ContinuousSpaceBitmap::SweepCallback* GetSweepCallback() = 0;
 
+  // jiacheng start
+  virtual void DebugBitmap();
+  // jiacheng end
+
  protected:
   std::unique_ptr<accounting::ContinuousSpaceBitmap> live_bitmap_;
   std::unique_ptr<accounting::ContinuousSpaceBitmap> mark_bitmap_;
   std::unique_ptr<accounting::ContinuousSpaceBitmap> temp_bitmap_;
 
+  // jiacheng start
+  std::unique_ptr<accounting::ContinuousSpaceBitmap> foreground_live_bitmap_;
+  // jiacheng end
+
   ContinuousMemMapAllocSpace(const std::string& name,
                              MemMap&& mem_map,
                              uint8_t* begin,
diff --git a/runtime/jiacheng_barrier.cc b/runtime/jiacheng_barrier.cc
index 8d544d9ff5..874291950d 100644
--- a/runtime/jiacheng_barrier.cc
+++ b/runtime/jiacheng_barrier.cc
@@ -1,35 +1,48 @@
+// jiacheng start
+#include "jiacheng_global.h"
 #include "jiacheng_barrier.h"
-#include "jiacheng_profiler.h"
 #include "jiacheng_utils.h"
 
-#include "mirror/object.h"
+#include "mirror/object-inl.h"
+#include "runtime.h"
+#include "gc/heap.h"
 
 namespace art {
 namespace jiacheng {
 
 
 void JiachengBarrier(uint64_t obj) {
+    if (!ENABLE_ACCESS_BARRIER) return;
+    // (void)obj;
+    // return;
     if (!obj) {
         return;
     }
-    if (!IsWhiteApp()) {
+    Runtime* runtime = Runtime::Current();
+    if (!runtime->IsStarted()) { 
         return;
     }
-    Profiler* profiler = Profiler::Current();
+    if (!IsWhiteApp()) return;
+
     mirror::Object* object = reinterpret_cast<mirror::Object*>(obj);
+    gc::Heap* heap = runtime->GetHeap();
+    heap->AddWs(object);
+}
 
-    if (!profiler->GetDuringGcFlag()) {
-        uint16_t current_time = profiler->GetCurrentTime();
-        if (profiler->GetPerceptibleFlag()) { // foreground
-            object->SetForegroundAccessRecord(current_time);
-        } else {  // background
-            object->SetBackgroundAccessRecord(current_time);
-        }
-        if (profiler->GetSwitchingFlag() && object->GetSwitchAccessRecord()==0) {
-            object->SetSwitchAccessRecord(current_time);
-        }
-    }
+void AllocationNewBarrier(uint64_t obj) {
+    if (!ENABLE_ALLOCATION_BARRIER) return;
+    (void)obj;
+    // mirror::Object* object = reinterpret_cast<mirror::Object*>(obj);
+    // object->SetTargetFlag();
+
+    // #ifdef JIACHENG_DEBUG
+    // object->SetDebugFlag(jiacheng::GenerateID());
+    // #endif
+
+    JiachengBarrier(obj);
 }
 
 }
-}
\ No newline at end of file
+}
+
+// jiacheng end
\ No newline at end of file
diff --git a/runtime/jiacheng_barrier.h b/runtime/jiacheng_barrier.h
index f9250c6c3b..9f09cb0de0 100644
--- a/runtime/jiacheng_barrier.h
+++ b/runtime/jiacheng_barrier.h
@@ -1,15 +1,20 @@
+// jiacheng start
+
 #ifndef ART_RUNTIME_JIACHENG_BARRIER_H_
 #define ART_RUNTIME_JIACHENG_BARRIER_H_
 
-#include "base/mutex.h"
-
 namespace art {
 namespace jiacheng {
 
 void JiachengBarrier(uint64_t obj);
 
+void AllocationNewBarrier(uint64_t obj);
+
 
 } // namespace jiacheng
 } // namespace art
 
-#endif
\ No newline at end of file
+#endif
+
+
+// jiacheng end
\ No newline at end of file
diff --git a/runtime/jiacheng_bloom_filter.h b/runtime/jiacheng_bloom_filter.h
index eade861eae..589e714a90 100644
--- a/runtime/jiacheng_bloom_filter.h
+++ b/runtime/jiacheng_bloom_filter.h
@@ -1,3 +1,4 @@
+// jiacheng start
 #ifndef ART_RUNTIME_JIACHENG_BLOOM_FILTER_H_
 #define ART_RUNTIME_JIACHENG_BLOOM_FILTER_H_
 
@@ -130,4 +131,6 @@ private:
 } // namespace jiacheng
 } // namespace art
 
-#endif
\ No newline at end of file
+#endif
+
+// jiacheng end
\ No newline at end of file
diff --git a/runtime/jiacheng_global.h b/runtime/jiacheng_global.h
new file mode 100644
index 0000000000..5451e741f7
--- /dev/null
+++ b/runtime/jiacheng_global.h
@@ -0,0 +1,41 @@
+// jiacheng start
+
+#ifndef ART_RUNTIME_JIACHENG_GLOBAL_H_
+#define ART_RUNTIME_JIACHENG_GLOBAL_H_
+
+#include "base/globals.h"
+
+namespace art {
+namespace jiacheng {
+
+#define JIACHENG_DEBUG
+
+
+constexpr bool ENABLE_ACCESS_BARRIER = true;
+constexpr bool ENABLE_ALLOCATION_BARRIER = true;
+
+constexpr bool ENABLE_APGC = false;
+constexpr bool ENABLE_NRO = false;
+constexpr bool ENABLE_FYO = false;
+
+constexpr bool ENABLE_BGC = false;
+
+constexpr uint32_t WINDOW_SIZE_HOT_LAUNCH = 5; 
+constexpr uint32_t WINDOW_SIZE_BACKGROUND_WS = 10;
+
+constexpr int32_t NEAR_TO_ROOT_THRESHOLD = 2;
+
+constexpr int32_t HOTNESS_LAUNCH = 9;
+constexpr int32_t HOTNESS_WORKING_SET = 8;
+constexpr int32_t HOTNESS_COLD = -1;
+constexpr int32_t HOTNESS_NONE = 0;
+
+const constexpr uint8_t MADV_COLD_RUNTIME = 233;
+const constexpr uint8_t MADV_HOT_RUNTIME = 234;
+
+} // namespace jiacheng
+} // namespace art
+
+#endif
+
+// jiacheng end
\ No newline at end of file
diff --git a/runtime/jiacheng_hack.cc b/runtime/jiacheng_hack.cc
index b113f59654..21bd9dd6f2 100644
--- a/runtime/jiacheng_hack.cc
+++ b/runtime/jiacheng_hack.cc
@@ -1,8 +1,13 @@
+// jiacheng start
 #include <string>
+#include <chrono>
+#include <thread>
 
 #include "runtime.h"
 #include "gc/heap.h"
 #include "gc/space/region_space.h"
+#include "gc/space/dlmalloc_space.h"
+#include "gc/space/large_object_space.h"
 #include "gc/collector/garbage_collector.h"
 #include "base/utils.h"
 #include "mirror/object-inl.h"
@@ -10,175 +15,58 @@
 #include <sys/mman.h>
 
 #include "jiacheng_hack.h"
-#include "jiacheng_activity_manager.h"
 #include "jiacheng_utils.h"
-#include "jiacheng_profiler.h"
-#include "jiacheng_swapper.h"
 
 namespace art{
 namespace jiacheng {
 
 typedef void(*WalkCallback)(void *start, void *end, size_t num_bytes, void* callback_arg);
 
-bool HandleFault(int sig, siginfo_t* info, void* context) {
-    (void)context;
+bool HandleFault(int sig ATTRIBUTE_UNUSED, siginfo_t* info, void* context ATTRIBUTE_UNUSED) {
     if (!IsWhiteApp()) {
         return false;
     }
-    LOG(INFO) << " jiacheng fault_handler.cc HandleFault()" 
-            << " sig= " << sig
-            << " info->si_addr= " << reinterpret_cast<mirror::Object*>(info->si_addr)
-            << " info->si_signo= " << info->si_signo
-            << " info->si_errno= " << info->si_errno
-            << " info->si_code= " << info->si_code
-            ;
     mirror::Object *ref = reinterpret_cast<mirror::Object *>(info->si_addr);
-
-    gc::space::RegionSpace* region_space = Runtime::Current()->GetHeap()->GetRegionSpace();
-    if (region_space->HasAddress(ref)) {
-        bool result = region_space->HandleFault(ref);
-        return result;
-    } else {
-        return false;
+    bool result = false;
+    
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    gc::space::RegionSpace* region_space = heap->GetRegionSpace();
+    gc::space::DlMallocSpace* non_moving_space = reinterpret_cast<gc::space::DlMallocSpace*>(heap->GetNonMovingSpace());
+    gc::space::LargeObjectSpace* large_object_space = heap->GetLargeObjectsSpace();
+
+    if (region_space->Contains(ref)) {
+        result = region_space->HandleFault(ref);
+    } else if (non_moving_space->Contains(ref)) {
+        result = non_moving_space->HandleFault(ref);
+    } else if (large_object_space->Contains(ref)) {
+        result = large_object_space->HandleFault(ref);
     }
+    return result;
 }
 
-// 在App启动的main函数中调用该函数
 void OnAppStart() {
     if (!IsWhiteApp()) {
         return;
     }
-    LOG(INFO) << "jiacheng jiacheng_hack.cc OnAppStart()"
-              << " package_name= " << GetCurrentPackageName();
-    Profiler* profiler = Profiler::Current();
-    profiler->SetStartTime(art::NanoTime());
-    (void)profiler;
-    
-    Swapper* swapper = Swapper::Current();
-    (void)swapper;
-}
-
-// AMS通过在系统启动的时候注册的service调用该函数
-void UpdateActivityState(const char* package_name, const char* activity_name, int state) { 
-    (void)package_name;
-    std::string name(activity_name);
-    ActivityManager::Current()->UpdateActivityState(name, state);
-}
-
-
-void UpdataAppState(ProcessState old_process_state, ProcessState new_process_state) {
-    if (!IsWhiteApp()) {
-        return;
-    }
-    Profiler* profiler = Profiler::Current();
-    uint64_t start_time = profiler->GetStartTime();
-    if (start_time == 0 || art::NanoTime() - start_time < 1000000000) {
-        return;
-    }
-
-    std::string package_name = GetCurrentPackageName();
-    LOG(INFO) << "jiacheng jiacheng_hack.cc 111 UpdataAppState() "
-              << " package_name= " << package_name 
-              << " old_process_state= " << old_process_state
-              << " new_process_state= " << new_process_state
-              ;
-
-    if (new_process_state == kProcessStateJankImperceptible) {
-        if (profiler->GetPerceptibleFlag()) {
-            profiler->SetBackgroundTime(profiler->GetCurrentTime());
-            profiler->ClearPerceptibleFlag();
-        }
-    } else {
-        if (!profiler->GetPerceptibleFlag()) {
-            profiler->SetSwitchingTime(profiler->GetCurrentTime());
-            profiler->SetSwitchingFlag();
-            profiler->SetPerceptibleFlag();
+    LOG(INFO) << "jiacheng OnAppStart()";
+
+    auto func = [](){
+        constexpr uint64_t defer_time = 3;
+        gc::Heap* heap = Runtime::Current()->GetHeap();
+        while (true) {
+            std::this_thread::sleep_for(std::chrono::seconds(defer_time));
+            LOG(INFO) << "jiacheng"
+                    << " MutatorWS= " << heap->GetMutatorWsSize()
+                    << " GcWS= " << heap->GetGcWsSize();
+            heap->ClearMutatorWs();
+            heap->ClearGcWs();
         }
-    }
-
-}
-
-// 每次GC开始的时候，调用该方法
-void BeforeGarbageCollectorRun(const gc::collector::GarbageCollector* collector) {
-    if (!IsWhiteApp()) {
-        return;
-    }
-    LOG(INFO) << "jiacheng jiacheng_hack.cc 89 BeforeGarbageCollectorRun()" 
-              << " NanoTime= " << NanoTime()
-              << " GarbageCollector.GetName()= " << collector->GetName()
-              << " GetGcType()= " << collector->GetGcType();
-
-    Profiler* profiler = Profiler::Current();
-    profiler->SetDuringGcFlag();
-}
-
-// 每次GC结束的时候，调用该方法
-void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector) {
-    if (!IsWhiteApp()) {
-        return;
-    }
-    const gc::collector::Iteration* iteration = collector->GetCurrentIteration();
-    
-    LOG(INFO) << "jiacheng jiacheng_hack.cc 106 AfterGarbageCollectorRun()" 
-              << " NanoTime= " << NanoTime()
-              << " GcCause= " << iteration->GetGcCause()
-              << " GetGcType= " << collector->GetGcType();
-
-    Profiler* profiler = Profiler::Current();
-    profiler->IncreaseGcNumber();
-    profiler->ClearDuringGcFlag();
-    
-    profiler->JiachengDebug();
-
-    // profiler->ClearAccessWS();
-    profiler->ClearGcWS();
-
-
-    Runtime::Current()->GetHeap()->GetRegionSpace()->InitColdToRegionRememberedSet();
-    // jiacheng debug start
-    // Runtime::Current()->GetHeap()->GetRegionSpace()->JiachengDebug();
-    // jiacheng debug end
+    };
+    std::thread t(func);
+    t.detach();
 }
 
-// GC访问内存的时候，调用该方法
-// 1. Copy过程的from_ref和to_ref
-// 2. Scan过程
-void GCAccessTrigger(mirror::Object* obj) {
-    (void)obj;
-    // if (!obj) {
-    //     return;
-    // }
-    // if (!IsWhiteApp()) {
-    //     return;
-    // }
-    // Profiler* profiler = Profiler::Current();
-    // profiler->RecordGcWS(obj);
-}
-
-bool ObjectIsSwappableType(mirror::Object* obj) {
-    if (obj->IsArrayInstance()) {
-        return !obj->IsObjectArray();
-    } else {
-        return !obj->IsClass() && !obj->IsClassLoader() && !obj->IsDexCache() && !obj->IsString() && !obj->IsReferenceInstance();
-    }
-    // return (
-    //     (obj->IsArrayInstance() && !obj->IsObjectArray())
-    //     || (!obj->IsArrayInstance() && !obj->IsClass() && !obj->IsClassLoader() && !obj->IsDexCache() && !obj->IsString() && !obj->IsReferenceInstance())
-    // );
-}
-
-void JiachengDebug() {
-    // ActivityManager::Current()->JiachengDebug();
-    LOG(INFO) << "jiacheng jiacheng_hack.cc 177 Debug() "
-              << "CodeGeneratorARM64::MarkGCCard()";
-    // Runtime* runtime = Runtime::Current();
-    // gc::Heap* heap = runtime->GetHeap();
-
-
-    // heap->JiachengDebug();
-}
-
-
-
 } // namespace jiacheng
 } // namespace art
+
+// jiacheng end
\ No newline at end of file
diff --git a/runtime/jiacheng_hack.h b/runtime/jiacheng_hack.h
index c797fe36b2..fb9a9189c2 100644
--- a/runtime/jiacheng_hack.h
+++ b/runtime/jiacheng_hack.h
@@ -1,6 +1,9 @@
+// jiacheng start
+
 #ifndef ART_RUNTIME_JIACHENG_HACK_H_
 #define ART_RUNTIME_JIACHENG_HACK_H_
 
+#include "jiacheng_global.h"
 #include "process_state.h"
 #include "signal.h"
 
@@ -22,20 +25,8 @@ bool HandleFault(int sig, siginfo_t* info, void* context);
 
 void OnAppStart();
 
-void UpdateActivityState(const char* package_name, const char* activity_name, int state);
-
-void UpdataAppState(ProcessState old_process_state, ProcessState new_process_state);
-
-void BeforeGarbageCollectorRun(const gc::collector::GarbageCollector* collector);
-
-void AfterGarbageCollectorRun(const gc::collector::GarbageCollector* collector);
-
-void GCAccessTrigger(mirror::Object* obj);
-
-bool ObjectIsSwappableType(mirror::Object * obj) NO_THREAD_SAFETY_ANALYSIS;
-
-void JiachengDebug();
-
 } // namespace jiacheng
 } // namespace art
-#endif
\ No newline at end of file
+#endif
+
+// jiacheng end
\ No newline at end of file
diff --git a/runtime/jiacheng_utils.cc b/runtime/jiacheng_utils.cc
index 12c1b669a8..b30637c5bd 100644
--- a/runtime/jiacheng_utils.cc
+++ b/runtime/jiacheng_utils.cc
@@ -1,70 +1,64 @@
+// jiacheng start
 #include <chrono>
 #include <atomic>
 #include <set>
 #include <thread>
 #include <random>
 #include <fstream>
+#include <sstream>
 
 #include <unistd.h>
 #include <sys/mman.h>
 #include <sys/syscall.h>
+#include <cstdlib>
+
+#include <errno.h>
 
 #include "base/time_utils.h"
 #include "runtime.h"
+#include "gc/heap-inl.h"
 
 #include "jiacheng_utils.h"
-#include "jiacheng_profiler.h"
+
+extern char *__progname;
 
 namespace art {
 namespace jiacheng {
 
-void CurrentThreadSleepNanoSecond(const unsigned long n) {
-    std::this_thread::sleep_for(std::chrono::nanoseconds(n));
-}
 
-void CurrentThreadSleepSecond(const unsigned long n) {
-    std::this_thread::sleep_for(std::chrono::seconds(n));
+uint64_t GenerateID() {
+    static std::atomic<uint64_t> id(1);
+    return id.fetch_add(1, std::memory_order_relaxed);
 }
 
-// 防止某个操作过于频繁
-bool CheckHot(uint64_t nano) {
-    static std::atomic<uint64_t> last_time(0);
-    uint64_t get_last_time = last_time.load();
-    uint64_t this_time = art::NanoTime();
-    if (this_time - get_last_time < nano) {
-        return true;
-    } else {
-        last_time.store(this_time);
-        return false;
-    }
-}
 
-uint32_t GenerateRandomKey() {
-    static std::random_device rd; // obtain a random number from hardware
-    static std::mt19937 gen(rd()); // seed the generator
-    static std::uniform_int_distribution<> distr(0, 1000000000); // define the range
-    return distr(gen);
-}
-
-// 需要测试的APP: Twitter, Facebook, Youtube, Tiktok, Amazon Shopping,
-//             Google Map, Chrome, Firefox, Angry Bird, Candy Crush Saga
 bool IsWhiteApp() {
     static std::atomic<int> white(0);
-    static std::set<std::string> white_app_set{
-        "com.twitter.android", 
-        "com.facebook.katana", 
-        "com.google.android.youtube", 
-        "com.zhiliaoapp.musically",
+    static std::unordered_set<std::string> white_app_set{
+        "com.jiacheng.activitylifecycletest",
+
+        "com.twitter.android",
+        "com.facebook.katana",
+        "com.instagram.android",
+        "org.telegram.messenger",
+        "jp.naver.line.android",
+        
+        "com.google.android.youtube",
+        "com.ss.android.ugc.aweme",
+        "com.spotify.music",
+        "tv.twitch.android.app",
+        "com.wemesh.android",
+        "sg.bigo.live",
+
         "com.amazon.mShop.android.shopping",
         "com.google.android.apps.maps",
         "com.android.chrome",
         "org.mozilla.firefox",
+        "com.linkedin.android",
+
         "com.rovio.angrybirds",
         "com.king.candycrushsaga",
 
-        "com.taobao.taobao", 
-        "com.jiacheng.activitylifecycletest",
-
         "edu.washington.cs.nl35.memorywaster", 
         "edu.washington.cs.nl35.memorywaster1",
         "edu.washington.cs.nl35.memorywaster2",
@@ -95,21 +89,23 @@ bool IsWhiteApp() {
         "edu.washington.cs.nl35.memorywaster27",
         "edu.washington.cs.nl35.memorywaster28",
         "edu.washington.cs.nl35.memorywaster29",
-        "edu.washington.cs.nl35.memorywaster30"
+        "edu.washington.cs.nl35.memorywaster30",
+
+        "edu.cityu.memorywaster01"
     };
-    Runtime* runtime = Runtime::Current();
-    if (runtime == nullptr || runtime->IsZygote()) { 
-        return false;
+    
+    // std::string process_name = GetCurrentProcessName();
+    // return white_app_set.find(process_name) != white_app_set.end();
+
+    if (white.load(std::memory_order_relaxed) == 1) {
+        return true;
     }
-    if (white.load() == 0) {
-        std::string package_name = GetCurrentPackageName();
-        if (white_app_set.find(package_name) != white_app_set.end()) {
-            white.store(1);
-        } else if ("" != package_name && "zygote" != package_name && "zygote64" != package_name) {
-            white.store(-1);
-        }
+    std::string process_name = GetCurrentProcessName();
+    if(white_app_set.find(process_name) != white_app_set.end()) {
+        white.store(1, std::memory_order_relaxed);
+        return true;
     }
-    return white.load() == 1;
+    return false;
 }
 
 void PrintKernel(const std::string& info) {
@@ -117,24 +113,33 @@ void PrintKernel(const std::string& info) {
     syscall(435, c_info, info.size() + 1); // SYS_jiacheng_printk = 435
 }
 
-std::string GetCurrentPackageName() {
-    std::ifstream cmdlineFile("/proc/self/cmdline");
-    std::string cmdline;
-    getline(cmdlineFile, cmdline);
-    cmdlineFile.close();
-    return cmdline.substr(0, cmdline.find((char)0));
+std::string GetCurrentProcessName() {
+    // because android fromework would reset argv[0] to <pre-initialized>
+    // so we have to modify source code in framework directory conrrespondingly
+    return std::string(__progname);
 }
 
-bool SwapOutRange(void* start, size_t size) {
-    Profiler* profiler = Profiler::Current();
-    if (profiler->GetDuringGcFlag()) {
+bool ColdRange(void* start, size_t size) {
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    if (heap->GetDuringGcFlag()) {
         return false;
     }
-    madvise(start, size, 233);
+    madvise(start, size, MADV_COLD_RUNTIME);
+    std::this_thread::sleep_for(std::chrono::nanoseconds(100));
     return true;
 }
 
-
+bool HotRange(void* start, size_t size) {
+    gc::Heap* heap = Runtime::Current()->GetHeap();
+    if (heap->GetDuringGcFlag()) {
+        return false;
+    }
+    madvise(start, size, MADV_HOT_RUNTIME);
+    std::this_thread::sleep_for(std::chrono::nanoseconds(100));
+    return true;
+}
 
 } // namespace jiacheng
 } // namespace art
+
+// jiacheng end
diff --git a/runtime/jiacheng_utils.h b/runtime/jiacheng_utils.h
index 0021e0f519..3537aad351 100644
--- a/runtime/jiacheng_utils.h
+++ b/runtime/jiacheng_utils.h
@@ -1,29 +1,29 @@
+// jiacheng start
 #ifndef ART_RUNTIME_JIACHENG_UTILS_H_
 #define ART_RUNTIME_JIACHENG_UTILS_H_
 
+#include "jiacheng_global.h"
 #include <string>
 
 namespace art {
 namespace jiacheng {
 
-void CurrentThreadSleepNanoSecond(const unsigned long n);
+uint64_t GenerateID();
 
-void CurrentThreadSleepSecond(const unsigned long n);
-
-bool CheckHot();
-
-uint32_t GenerateRandomKey();
-
-std::string GetCurrentPackageName();
+std::string GetCurrentProcessName();
 
 bool IsWhiteApp();
 
 void PrintKernel(const std::string& info);
 
-bool SwapOutRange(void* start, size_t size);
+bool ColdRange(void* start, size_t size);
+
+bool HotRange(void* start, size_t size);
 
 } // namespace jiacheng
 } // namespace art
 
 
-#endif
\ No newline at end of file
+#endif
+
+// jiacheng end
\ No newline at end of file
diff --git a/runtime/mirror/array.h b/runtime/mirror/array.h
index 00d101ab7f..6076875890 100644
--- a/runtime/mirror/array.h
+++ b/runtime/mirror/array.h
@@ -34,7 +34,11 @@ class MANAGED Array : public Object {
  public:
   // jiacheng start
   // static constexpr size_t kFirstElementOffset = 12u;
+  #ifdef JIACHENG_DEBUG
+  static constexpr size_t kFirstElementOffset = 12u + 8u + 8u;
+  #else
   static constexpr size_t kFirstElementOffset = 12u + 8u;
+  #endif
   // jiacheng end
 
 
diff --git a/runtime/mirror/object-inl.h b/runtime/mirror/object-inl.h
index b908c43a6a..3199efd28d 100644
--- a/runtime/mirror/object-inl.h
+++ b/runtime/mirror/object-inl.h
@@ -954,6 +954,44 @@ inline void Object::VerifyTransaction() {
   }
 }
 
+// jiacheng start
+inline void Object::SetForegroundAccessRecord(uint16_t current_time) {
+  if (Runtime::Current()->IsSystemServer()) return;
+  if (foreground_access_record_ != current_time) {
+    foreground_access_record_ = current_time;
+  }
+}
+
+inline uint16_t Object::GetForegroundAccessRecord() {
+  if (Runtime::Current()->IsSystemServer()) return 0;
+  return foreground_access_record_;
+}
+
+inline void Object::SetBackgroundAccessRecord(uint16_t current_time) {
+  if (Runtime::Current()->IsSystemServer()) return;
+  if (background_access_record_ != current_time) {
+    background_access_record_ = current_time;
+  }
+}
+
+inline uint16_t Object::GetBackgroundAccessRecord() {
+  if (Runtime::Current()->IsSystemServer()) return 0;
+  return background_access_record_;
+}
+
+inline void Object::SetHotLaunchAccessRecord(uint16_t current_time) {
+  if (Runtime::Current()->IsSystemServer()) return;
+  if (hot_launch_access_record_ != current_time) {
+    hot_launch_access_record_ = current_time;
+  }
+}
+
+inline uint16_t Object::GetHotLaunchAccessRecord() {
+  if (Runtime::Current()->IsSystemServer()) return 0;
+  return hot_launch_access_record_;
+}
+// jiacheng end
+
 }  // namespace mirror
 }  // namespace art
 
diff --git a/runtime/mirror/object.cc b/runtime/mirror/object.cc
index 227aa7f3d2..f549ac0f90 100644
--- a/runtime/mirror/object.cc
+++ b/runtime/mirror/object.cc
@@ -38,6 +38,10 @@
 #include "throwable.h"
 #include "well_known_classes.h"
 
+// jiacheng start
+#include "jiacheng_global.h"
+// jiacheng end
+
 namespace art {
 namespace mirror {
 
@@ -300,48 +304,27 @@ std::string Object::PrettyTypeOf() {
   return result;
 }
 
-// jiacheng start
-void Object::SetForegroundAccessRecord(uint16_t current_time) {
-  // Runtime* runtime = Runtime::Current();
-  // if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return;
-  if (Runtime::Current()->IsSystemServer()) return;
-  foreground_access_record_ = current_time;
-}
-
 
-uint16_t Object::GetForegroundAccessRecord() {
-  // Runtime* runtime = Runtime::Current();
-  // if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return 0;
-  if (Runtime::Current()->IsSystemServer()) return 0;
-  return foreground_access_record_;
-}
-
-void Object::SetBackgroundAccessRecord(uint16_t current_time) {
-  // Runtime* runtime = Runtime::Current();
-  // if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return;
-  if (Runtime::Current()->IsSystemServer()) return;
-  background_access_record_ = current_time;
-}
-
-uint16_t Object::GetBackgroundAccessRecord() {
-  // Runtime* runtime = Runtime::Current();
-  // if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return 0;
-  if (Runtime::Current()->IsSystemServer()) return 0;
-  return background_access_record_;
+// jiacheng start
+#ifdef JIACHENG_DEBUG
+void Object::SetDebugFlag(uint64_t debug_flag) {
+  debug_flag_.store(debug_flag, std::memory_order_relaxed);
 }
 
-void Object::SetSwitchAccessRecord(uint16_t current_time) {
-  // Runtime* runtime = Runtime::Current();
-  // if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return;
-  if (Runtime::Current()->IsSystemServer()) return;
-  switch_access_record_ = current_time;
+uint64_t Object::GetDebugFlag() {
+  return debug_flag_.load(std::memory_order_relaxed);
 }
-
-uint16_t Object::GetSwitchAccessRecord() {
-  // Runtime* runtime = Runtime::Current();
-  // if ((!runtime->GetStartupCompleted()) || runtime->IsSystemServer()) return 0;
-  if (Runtime::Current()->IsSystemServer()) return 0;
-  return switch_access_record_;
+#endif
+
+void Object::Debug() {
+  LOG(INFO) << "jiacheng object.cc Object::Debug()"
+            << " object= " << static_cast<void*>(this)
+            << " foreground_access_record_= " << foreground_access_record_
+            << " background_access_record_= " << background_access_record_
+            << " hot_launch_access_record_= " << hot_launch_access_record_
+            << " padding_= " << padding_
+            << " debug_flag_= " << debug_flag_.load(std::memory_order_relaxed)
+            ;
 }
 
 
diff --git a/runtime/mirror/object.h b/runtime/mirror/object.h
index 32f9208c20..c3f4d0a19d 100644
--- a/runtime/mirror/object.h
+++ b/runtime/mirror/object.h
@@ -31,6 +31,7 @@
 
 // jiacheng start
 #include "jiacheng_barrier.h"
+#include "jiacheng_global.h"
 // jiacheng end
 
 namespace art {
@@ -98,17 +99,101 @@ class MANAGED LOCKABLE Object {
   }
 
   // jiacheng start
-  void SetForegroundAccessRecord(uint16_t current_time);
+  static constexpr MemberOffset ForegroundAccessRecordOffset() {
+    return OFFSET_OF_OBJECT_MEMBER(Object, foreground_access_record_);
+  }
+
+  static constexpr MemberOffset BackgroundAccessRecordOffset() {
+    return OFFSET_OF_OBJECT_MEMBER(Object, background_access_record_);
+  }
+
+  static constexpr MemberOffset HotLaunchAccessRecordOffset() {
+    return OFFSET_OF_OBJECT_MEMBER(Object, hot_launch_access_record_);
+  }
+
+  static constexpr MemberOffset PaddingOffset() {
+    return OFFSET_OF_OBJECT_MEMBER(Object, padding_);
+  }
+
+  ALWAYS_INLINE void SetForegroundAccessRecord(uint16_t current_time);
+
+  ALWAYS_INLINE uint16_t GetForegroundAccessRecord();
+
+  ALWAYS_INLINE void SetBackgroundAccessRecord(uint16_t current_time);
+
+  ALWAYS_INLINE uint16_t GetBackgroundAccessRecord();
+
+  ALWAYS_INLINE void SetHotLaunchAccessRecord(uint16_t current_time);
+
+  ALWAYS_INLINE uint16_t GetHotLaunchAccessRecord();
+
+  ALWAYS_INLINE void SetTargetFlag() {
+    if (!GetTargetFlag()) {
+      padding_ = padding_ | 0x1;
+    }
+  }
+
+  ALWAYS_INLINE void ClearTargetFlag() {
+    padding_ = padding_ & 0xfffe;
+  }
+
+  ALWAYS_INLINE bool GetTargetFlag() {
+    return  padding_ & 0x1;
+  }
+
+  ALWAYS_INLINE void SetForegroundAllocationFlag() {
+      padding_ = padding_ | 0x2;
+  }
 
-  uint16_t GetForegroundAccessRecord();
+  ALWAYS_INLINE void ClearForegroundAllocationFlag() {
+    padding_ = padding_ & 0xfffD;
+  }
 
-  void SetBackgroundAccessRecord(uint16_t current_time);
+  ALWAYS_INLINE bool GetForegroundAllocationFlag() {
+    return  padding_ & 0x2;
+  }
 
-  uint16_t GetBackgroundAccessRecord();
+  ALWAYS_INLINE void SetBackgroundAllocationFlag() {
+      padding_ = padding_ | 0x4;
+  }
 
-  void SetSwitchAccessRecord(uint16_t current_time);
+  ALWAYS_INLINE void ClearBackgroundAllocationFlag() {
+    padding_ = padding_ & 0xfffB;
+  }
+
+  ALWAYS_INLINE bool GetBackgroundAllocationFlag() {
+    return  padding_ & 0x4;
+  }
+
+
+  ALWAYS_INLINE void SetPadding(uint16_t padding) {
+    padding_ = padding;
+  }
+
+  ALWAYS_INLINE uint16_t GetPadding() {
+    return padding_;
+  }
+
+  #ifdef JIACHENG_DEBUG
+  void SetDebugFlag(uint64_t debug_flag);
+
+  uint64_t GetDebugFlag();
+  #endif
+
+
+  void CopyHeaderFrom(Object* from) {
+    SetForegroundAccessRecord(from->GetForegroundAccessRecord());
+    SetBackgroundAccessRecord(from->GetBackgroundAccessRecord());
+    SetHotLaunchAccessRecord(from->GetHotLaunchAccessRecord());
+    SetPadding(from->GetPadding());
+    #ifdef JIACHENG_DEBUG
+    SetDebugFlag(from->GetDebugFlag());
+    #endif
+  }
+
+
+  void Debug();
 
-  uint16_t GetSwitchAccessRecord();
   // jiacheng end
 
   template<VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags,
@@ -801,8 +886,12 @@ class MANAGED LOCKABLE Object {
   // jiacheng start
   uint16_t foreground_access_record_;
   uint16_t background_access_record_;
-  uint16_t switch_access_record_;
-  uint16_t padding_;
+  uint16_t hot_launch_access_record_;
+  uint16_t padding_;   // used for debug
+
+#ifdef JIACHENG_DEBUG
+  std::atomic<uint64_t> debug_flag_;
+#endif
   // jiacheng end
 
 #ifdef USE_BROOKS_READ_BARRIER
diff --git a/runtime/thread-inl.h b/runtime/thread-inl.h
index 00f882e3e0..7cc1100528 100644
--- a/runtime/thread-inl.h
+++ b/runtime/thread-inl.h
@@ -30,6 +30,10 @@
 #include "thread-current-inl.h"
 #include "thread_pool.h"
 
+// jiacheng start
+#include "jiacheng_barrier.h"
+// jiacheng end
+
 namespace art {
 
 // Quickly access the current thread from a JNIEnv.
@@ -307,6 +311,9 @@ inline mirror::Object* Thread::AllocTlab(size_t bytes) {
   ++tlsPtr_.thread_local_objects;
   mirror::Object* ret = reinterpret_cast<mirror::Object*>(tlsPtr_.thread_local_pos);
   tlsPtr_.thread_local_pos += bytes;
+  // jiacheng start
+  jiacheng::AllocationNewBarrier(reinterpret_cast<uint64_t>(ret));
+  // jiacheng end
   return ret;
 }
 
diff --git a/runtime/thread.cc b/runtime/thread.cc
index 70ed7c8038..eaee9dfb69 100644
--- a/runtime/thread.cc
+++ b/runtime/thread.cc
@@ -143,6 +143,9 @@ static const char* kThreadNameDuringStartup = "<native thread without managed pe
 
 void Thread::InitCardTable() {
   tlsPtr_.card_table = Runtime::Current()->GetHeap()->GetCardTable()->GetBiasedBegin();
+  // jiacheng start
+  tlsPtr_.card_table2 = Runtime::Current()->GetHeap()->GetCardTable2()->GetBiasedBegin();
+  // jiacheng end
 }
 
 static void UnimplementedEntryPoint() {
@@ -4287,4 +4290,5 @@ bool Thread::IsSystemDaemon() const {
       WellKnownClasses::java_lang_Thread_systemDaemon)->GetBoolean(GetPeer());
 }
 
+
 }  // namespace art
diff --git a/runtime/thread.h b/runtime/thread.h
index dd483c188d..ace496e1a9 100644
--- a/runtime/thread.h
+++ b/runtime/thread.h
@@ -759,6 +759,13 @@ class Thread {
     return ThreadOffsetFromTlsPtr<pointer_size>(OFFSETOF_MEMBER(tls_ptr_sized_values, card_table));
   }
 
+  // jiacheng start
+  template<PointerSize pointer_size>
+  static constexpr ThreadOffset<pointer_size> CardTable2Offset() {
+    return ThreadOffsetFromTlsPtr<pointer_size>(OFFSETOF_MEMBER(tls_ptr_sized_values, card_table2));
+  }
+  // jiacheng end
+
   template<PointerSize pointer_size>
   static constexpr ThreadOffset<pointer_size> ThreadSuspendTriggerOffset() {
     return ThreadOffsetFromTlsPtr<pointer_size>(
@@ -1601,6 +1608,9 @@ class Thread {
       flip_function(nullptr), method_verifier(nullptr), thread_local_mark_stack(nullptr),
       async_exception(nullptr) {
       std::fill(held_mutexes, held_mutexes + kLockLevelCount, nullptr);
+      // jiacheng start
+      card_table2 = nullptr;
+      // jiacheng end
     }
 
     // The biased card table, see CardTable for details.
@@ -1757,6 +1767,10 @@ class Thread {
 
     // The pending async-exception or null.
     mirror::Throwable* async_exception;
+
+    // jiacheng start
+    uint8_t* card_table2;
+    // jiacheng end
   } tlsPtr_;
 
   // Small thread-local cache to be used from the interpreter.
diff --git a/runtime/write_barrier-inl.h b/runtime/write_barrier-inl.h
index af8c1be828..baee02815e 100644
--- a/runtime/write_barrier-inl.h
+++ b/runtime/write_barrier-inl.h
@@ -24,6 +24,10 @@
 #include "obj_ptr-inl.h"
 #include "runtime.h"
 
+// jiacheng start
+#include "jiacheng_utils.h"
+// jiacheng end
+
 namespace art {
 
 template <WriteBarrier::NullCheck kNullCheck>
@@ -35,22 +39,37 @@ inline void WriteBarrier::ForFieldWrite(ObjPtr<mirror::Object> dst,
   }
   DCHECK(new_value != nullptr);
   GetCardTable()->MarkCard(dst.Ptr());
+  // jiacheng start
+  GetCardTable2()->MarkCard(dst.Ptr());
+  // jiacheng end
 }
 
 inline void WriteBarrier::ForArrayWrite(ObjPtr<mirror::Object> dst,
                                         int start_offset ATTRIBUTE_UNUSED,
                                         size_t length ATTRIBUTE_UNUSED) {
   GetCardTable()->MarkCard(dst.Ptr());
+  // jiacheng start
+  GetCardTable2()->MarkCard(dst.Ptr());
+  // jiacheng end
 }
 
 inline void WriteBarrier::ForEveryFieldWrite(ObjPtr<mirror::Object> obj) {
   GetCardTable()->MarkCard(obj.Ptr());
+  // jiacheng start
+  GetCardTable2()->MarkCard(obj.Ptr());
+  // jiacheng end
 }
 
 inline gc::accounting::CardTable* WriteBarrier::GetCardTable() {
   return Runtime::Current()->GetHeap()->GetCardTable();
 }
 
+// jiacheng start
+inline gc::accounting::CardTable* WriteBarrier::GetCardTable2() {
+  return Runtime::Current()->GetHeap()->GetCardTable2();
+}
+// jiacheng end
+
 }  // namespace art
 
 #endif  // ART_RUNTIME_WRITE_BARRIER_INL_H_
diff --git a/runtime/write_barrier.h b/runtime/write_barrier.h
index 112154e14a..71b85f66e6 100644
--- a/runtime/write_barrier.h
+++ b/runtime/write_barrier.h
@@ -55,6 +55,10 @@ class WriteBarrier {
 
  private:
   ALWAYS_INLINE static gc::accounting::CardTable* GetCardTable();
+
+  // jiacheng start
+  ALWAYS_INLINE static gc::accounting::CardTable* GetCardTable2();
+  // jiacheng end
 };
 
 }  // namespace art
-- 
2.34.1


From 940457a3539d23ed109f238c08df80c6cacc4797 Mon Sep 17 00:00:00 2001
From: jiachengh <jiacheng.huang@outlook.com>
Date: Wed, 14 Feb 2024 10:56:15 +0800
Subject: [PATCH 6/7] Remove profiling

Change-Id: Ia85b8f2df7e32ae8f37b92305f7e5b74fd4769fa
---
 runtime/jiacheng_activity_manager.cc  | 136 --------
 runtime/jiacheng_activity_manager.h   |  56 ----
 runtime/jiacheng_common.h             |  24 --
 runtime/jiacheng_debug.cc             | 466 --------------------------
 runtime/jiacheng_debug.h              |  65 ----
 runtime/jiacheng_profiler.cc          | 245 --------------
 runtime/jiacheng_profiler.h           | 119 -------
 runtime/jiacheng_swapper.cc           | 189 -----------
 runtime/jiacheng_swapper.h            |  63 ----
 tools/cpp-define-generator/thread.def |   4 +
 10 files changed, 4 insertions(+), 1363 deletions(-)
 delete mode 100644 runtime/jiacheng_activity_manager.cc
 delete mode 100644 runtime/jiacheng_activity_manager.h
 delete mode 100644 runtime/jiacheng_common.h
 delete mode 100644 runtime/jiacheng_debug.cc
 delete mode 100644 runtime/jiacheng_debug.h
 delete mode 100644 runtime/jiacheng_profiler.cc
 delete mode 100644 runtime/jiacheng_profiler.h
 delete mode 100644 runtime/jiacheng_swapper.cc
 delete mode 100644 runtime/jiacheng_swapper.h

diff --git a/runtime/jiacheng_activity_manager.cc b/runtime/jiacheng_activity_manager.cc
deleted file mode 100644
index f546100e83..0000000000
--- a/runtime/jiacheng_activity_manager.cc
+++ /dev/null
@@ -1,136 +0,0 @@
-#include "thread-current-inl.h"
-#include "base/mutex.h"
-
-#include "jiacheng_activity_manager.h"
-
-namespace art {
-namespace jiacheng {
-
-Mutex ActivityManager::singleton_lock_("Activity Manager Singleton Lock", kLoggingLock);
-ActivityManager* ActivityManager::activity_manager_(nullptr); 
-
-ActivityManager::ActivityManager():
-    activity_manager_lock_("Activity Manager Lock", kLoggingLock),
-    // current_working_set_(new std::set<mirror::Object*>()),
-    current_working_set_(nullptr),
-    current_activity_name_(""),
-    activity_ws_map_() {
-    
-    // default working set
-    // activity_ws_map_[""] = current_working_set_;
-}
-
-ActivityManager::~ActivityManager() {
-}
-
-ActivityManager* ActivityManager::Create() {
-    ActivityManager* activity_manager = new ActivityManager();
-    return activity_manager;
-}
-
-ActivityManager* ActivityManager::Current() {
-    if (activity_manager_ == nullptr) {
-        Thread* self = Thread::Current();
-        singleton_lock_.ExclusiveLock(self);
-        if (activity_manager_ == nullptr) {
-            activity_manager_ = Create();
-        }
-        singleton_lock_.ExclusiveUnlock(self);
-    }
-    return activity_manager_;
-}
-
-void ActivityManager::JiachengDebug() const {
-    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "current_working_set_=" << size_t(current_working_set_);
-    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "current_activity_name_=" << current_activity_name_;
-    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 40 " << "activity_ws_map_= " << activity_ws_map_.size();
-}
-
-bool ActivityManager::ShouldSwapOut(mirror::Object *obj) {
-    bool res = false;
-    // Thread* self = Thread::Current();
-    // activity_manager_lock_.ExclusiveLock(self);
-    if (current_working_set_ != nullptr && current_working_set_->find(obj) == current_working_set_->end()) {
-        res = true;
-    }
-    // activity_manager_lock_.ExclusiveUnlock(self);
-    return res;
-
-    // (void)obj;
-    // return true;
-}
-
-
-void ActivityManager::RecordWS(mirror::Object* obj) {
-    Thread *self = Thread::Current();
-
-    activity_manager_lock_.ExclusiveLock(self);
-    if (current_working_set_) {
-        current_working_set_->insert(obj);
-    }
-    activity_manager_lock_.ExclusiveUnlock(self);
-}
-
- 
-void ActivityManager::UpdateActivityState(const std::string& activity_name, int state) {
-    if (state != 1) { // RESUMED
-        return;
-    }
-    LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 83 UpdateActivityState()"
-              << " activity_name= " << activity_name
-              << " state= " << state
-              << std::flush;
-    // Debug Start 计算每个工作集之间的交集
-    for (const auto& it : activity_ws_map_) {
-        LOG(INFO) << "jiacheng jiacheng_activity_manager.cc 68 activity_set_size= "
-                  << it.first << ' '
-                  << (it.second)->size();
-    }
-    Thread *self = Thread::Current();
-    // std::vector<mirror::Object*> intersection;
-
-    // activity_manager_lock_.ExclusiveLock(self);
-    // for (const auto& it : activity_ws_map_) {
-    //     const std::set<mirror::Object*>* s1 = it.second;
-    //     for (const auto& it2 : activity_ws_map_) {
-    //         const std::set<mirror::Object*>* s2 = it2.second;
-    //         std::set_intersection(
-    //             s1->begin(), s1->end(), 
-    //             s2->begin(), s2->end(), 
-    //             std::back_inserter(intersection)
-    //         );
-    //         LOG(INFO) << "intersection.size()# " <<it.first << " and " << it2.first << "= " << intersection.size();
-    //         intersection.clear();
-    //     }
-    // }
-    // activity_manager_lock_.ExclusiveUnlock(self);
-    // Debug End
-
-
-    // 更新当前的Activity Name
-    activity_manager_lock_.ExclusiveLock(self);
-    
-    current_activity_name_ = activity_name;
-
-    std::map<std::string, std::set<mirror::Object*>*>::iterator it = activity_ws_map_.find(current_activity_name_);
-    if (it == activity_ws_map_.end()) {
-        current_working_set_ = new std::set<mirror::Object*>();
-        activity_ws_map_[current_activity_name_] = current_working_set_;
-    } else {
-        current_working_set_ = it->second;
-    }
-    activity_manager_lock_.ExclusiveUnlock(self);
-}
-
-
-void ActivityManager::ForgetWorkingSet() {
-    Thread* self = Thread::Current();
-    activity_manager_lock_.ExclusiveLock(self);
-    if (current_working_set_) {
-        current_working_set_->clear();
-    }
-    activity_manager_lock_.ExclusiveUnlock(self);
-}
-
-} // namespace jiacheng
-} // namespace art
\ No newline at end of file
diff --git a/runtime/jiacheng_activity_manager.h b/runtime/jiacheng_activity_manager.h
deleted file mode 100644
index e16197cc85..0000000000
--- a/runtime/jiacheng_activity_manager.h
+++ /dev/null
@@ -1,56 +0,0 @@
-#ifndef ART_RUNTIME_JIACHENG_ACTIVITY_MANAGER_H_
-#define ART_RUNTIME_JIACHENG_ACTIVITY_MANAGER_H_
-
-#include <set>
-#include <map>
-
-#include "base/mutex.h"
-
-namespace art {
-
-namespace mirror {
-    class Object;
-}
-
-namespace jiacheng {
-
-class ActivityManager {
-public:
-    ActivityManager();
-    ~ActivityManager();
-
-    static Mutex singleton_lock_;
-    static ActivityManager* activity_manager_; 
-
-    static ActivityManager* Create();
-    static ActivityManager* Current();
-
-    void JiachengDebug() const;
-
-    bool ShouldSwapOut(mirror::Object *obj);
-
-    void RecordWS(mirror::Object* obj);
-
-    void UpdateActivityState(const std::string& activity_name, int state);
-
-    /* 每次GC完成之后重新估计当前Activity的工作集 */
-    void ForgetWorkingSet();
-
-private:
-    // 用于保护current_working_set, activity_set, current_activity_name
-    Mutex activity_manager_lock_; 
-
-    // 当前Activity使用工作集的缓存指针，从而不需要每次都从map中查找
-    std::set<mirror::Object*>* current_working_set_;
-
-    // 保存当前的用户看到的Activity名
-    std::string current_activity_name_;
-
-    // 保存了ActivityName : WorkingSet 的映射
-    std::map<std::string, std::set<mirror::Object*> *> activity_ws_map_; 
-};
-
-}
-}
-
-#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_common.h b/runtime/jiacheng_common.h
deleted file mode 100644
index 03a8025344..0000000000
--- a/runtime/jiacheng_common.h
+++ /dev/null
@@ -1,24 +0,0 @@
-#ifndef ART_RUNTIME_JIACHENG_COMMON_H_
-#define ART_RUNTIME_JIACHENG_COMMON_H_
-
-#include "base/mutex.h"
-
-namespace art {
-namespace jiacheng {
-
-constexpr uint32_t CLOCK_TICK = 5; // second
-constexpr uint32_t SWITCHING_WINDOW_SIZE = 1; // Ticks
-constexpr uint32_t SWAPOUT_WINDOW_SIZE = 6; // Ticks
-
-constexpr uint32_t FOREGROUND_WS_WINDOW_SIZE = 1; // Ticks
-constexpr uint32_t BACKGROUND_WS_WINDOW_SIZE = 2; // Ticks
-
-constexpr bool RESERVE_FOREGROUND_WS_FLAG = true;
-constexpr bool RESERVE_SWITCHING_WS_FLAG = true;
-
-constexpr bool ACTIVE_SWAPOUT = true;
-
-} // namespace jiacheng
-} // namespace art
-
-#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_debug.cc b/runtime/jiacheng_debug.cc
deleted file mode 100644
index f308572787..0000000000
--- a/runtime/jiacheng_debug.cc
+++ /dev/null
@@ -1,466 +0,0 @@
-#include <chrono>
-#include <atomic>
-#include <thread>
-#include <random>
-#include <sstream>
-#include <fstream>
-
-#include <unistd.h>
-#include <sys/syscall.h>
-
-#include "gc/accounting/card_table.h"
-#include "gc/heap.h"
-#include "gc/space/space-inl.h"
-#include "gc/heap-visit-objects-inl.h"
-#include "gc/space/zygote_space.h"
-#include "gc/space/bump_pointer_space-inl.h"
-#include "gc/space/bump_pointer_space-walk-inl.h"
-#include "gc/space/dlmalloc_space-inl.h"
-#include "gc/space/image_space.h"
-#include "gc/space/large_object_space.h"
-#include "gc/space/malloc_space.h"
-#include "gc/space/region_space-inl.h"
-#include "gc/space/rosalloc_space-inl.h"
-#include "mirror/class-inl.h"
-#include "obj_ptr-inl.h"
-#include "scoped_thread_state_change-inl.h"
-#include "thread_list.h"
-#include "gc/accounting/mod_union_table-inl.h"
-#include "gc/accounting/remembered_set.h"
-#include "base/mutex.h"
-#include "read_barrier_config.h"
-
-#include "jiacheng_debug.h"
-#include "jiacheng_utils.h"
-
-namespace art {
-namespace jiacheng {
-
-static Mutex working_set_lock("Profiler Singleton Lock", kLoggingLock);
-static std::set<mirror::Object*> working_set;
-static std::set<size_t> page_working_set;
-static size_t all_object_size;
-
-void RecordWorkingSet(mirror::Object* obj) {
-    Thread* self = Thread::Current();
-    working_set_lock.ExclusiveLock(self);
-    if (working_set.find(obj) == working_set.end()) {
-        size_t object_size = 0;
-        {
-            ReaderMutexLock mu(self, *Locks::mutator_lock_); 
-            object_size = obj->SizeOf();
-        }
-        all_object_size += object_size;
-        size_t begin_addr = reinterpret_cast<size_t>(obj);
-        size_t end_addr = begin_addr + object_size;
-        while (begin_addr < end_addr) {
-            page_working_set.insert(begin_addr >> 12);
-            begin_addr += 1 << 12;
-        }
-        working_set.insert(obj);
-    }
-    
-    working_set_lock.ExclusiveUnlock(self);
-}
-
-void ClearAndPrintWorkingSet() {
-    gc::Heap* heap = Runtime::Current()->GetHeap();
-    size_t total_memory = heap->GetTotalMemory();
-    size_t total_active_page = 0;
-    size_t total_active_object = 0;
-    Thread* self = Thread::Current();
-
-    working_set_lock.ExclusiveLock(self);
-    total_active_page = page_working_set.size() << 12;
-    total_active_object = all_object_size;
-    working_set.clear();
-    page_working_set.clear();
-    all_object_size = 0;
-    working_set_lock.ExclusiveUnlock(self);
-
-    LOG(INFO) << "jiacheng jiacheng_debug.cc 78 ClearAndPrintWorkingSet()"
-              << " active_object= " << total_active_object
-              << " active_page= " << total_active_page
-              << " total_memory= " << total_memory
-              << std::flush;
-}
-
-
-typedef void(*WalkCallback)(void *start, void *end, size_t num_bytes, void* callback_arg);
-
-// 对所有Space中的对象进行Swap
-void SwapOutAll() {
-    gc::Heap* heap = Runtime::Current()->GetHeap();
-    Thread* self = Thread::Current();
-    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
-    {
-        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
-        continues_spaces = &(heap->GetContinuousSpaces());
-    }
-    for (auto space : *continues_spaces) {
-        CurrentThreadSleepSecond(1);
-        SwapOutSpace(space);
-    }
-    const std::vector<gc::space::DiscontinuousSpace*>& discontinues_spaces = heap->GetDiscontinuousSpaces();
-    for (auto space : discontinues_spaces) {
-        CurrentThreadSleepSecond(1);
-        SwapOutSpace(space);
-    }    
-}
-
-
-void SwapOutSpace(gc::space::Space* space) {
-    Thread* self = Thread::Current();
-    gc::space::SpaceType space_type = space->GetType();
-    
-    WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* ) {
-        // if (start != end && ActivityManager::Current()->ShouldSwapOut(reinterpret_cast<mirror::Object*>(start))) {
-        if (start != end) {
-            LOG(INFO) << "jiacheng_hack.cc 143 ShouldSwapOut() obj= " << size_t(start) << " size= " << size_t(end) - size_t(start);
-            madvise(start, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start), 233);
-        }
-    };    
-    auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_){
-        // if (obj && ActivityManager::Current()->ShouldSwapOut(obj)) {
-        if (obj) {
-            LOG(INFO) << "jiacheng_hack.cc 150 ShouldSwapOut() obj= " << size_t(obj) << " size= " << obj->SizeOf();
-            madvise(static_cast<void *>(obj), obj->SizeOf(), 233);
-        }
-    };
-    switch (space_type) {
-        case gc::space::kSpaceTypeImageSpace: {
-            // gc::space::ImageSpace* this_space = space->AsImageSpace();
-            break;
-        }
-        case gc::space::kSpaceTypeMallocSpace: {
-            gc::space::MallocSpace* this_space = space->AsMallocSpace();
-            this_space->Walk(walk_callback, nullptr);
-            break;
-        }
-        case gc::space::kSpaceTypeZygoteSpace: {
-            // gc::space::ZygoteSpace* this_space = space->AsZygoteSpace();
-            break;
-        }
-        case gc::space::kSpaceTypeBumpPointerSpace: {
-            gc::space::BumpPointerSpace* this_space = space->AsBumpPointerSpace();
-            { 
-                WriterMutexLock mu(self, *Locks::mutator_lock_);  
-                this_space -> Walk(visitor);
-            }
-            break;
-        }
-        case gc::space::kSpaceTypeLargeObjectSpace: {
-            gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
-            this_space->Walk(walk_callback, nullptr);
-            break;
-        }
-        case gc::space::kSpaceTypeRegionSpace: {
-            gc::space::RegionSpace* this_space = space->AsRegionSpace();   
-            {
-                WriterMutexLock mu(self, *Locks::mutator_lock_);  
-                this_space -> Walk(visitor);
-            }
-            break;
-        }
-        default:
-            LOG(INFO) << "jiacheng " << "jiacheng_hack.cc 100. Can not find space.";
-    }
-}
-
-
-/* ------------------- debug --------------------- */
-
-// 查看Object在哪个Space里面
-std::string GetSpaceFromObject(mirror::Object* obj) {
-    gc::Heap* heap = Runtime::Current()->GetHeap();
-    if (!heap) {
-        return "no_heap";
-    }
-    gc::space::RegionSpace* region_space = heap->GetRegionSpace();
-    gc::space::LargeObjectSpace* large_object_space = heap->GetLargeObjectsSpace();
-    gc::space::MallocSpace* non_moving_space = heap->GetNonMovingSpace();
-    gc::space::ZygoteSpace* zygote_space = heap->GetZygoteSpace();
-    const std::vector<gc::space::ImageSpace*>& boot_image_spaces = heap->GetBootImageSpaces();
-    
-    if (region_space && region_space->Contains(obj)) {
-        return "region_space";
-    } else if (non_moving_space && non_moving_space->Contains(obj)) {
-        return "non_moving_space";
-    } else if (large_object_space && large_object_space->Contains(obj)) {
-        return "large_object_space";
-    } else if (zygote_space && zygote_space->Contains(obj)) {
-        return "zygote_space";
-    } 
-    for (gc::space::ImageSpace* space : boot_image_spaces) {
-        if (space->Contains(obj)) {
-            return "boot_image_spaces";
-        }
-    }
-
-    Thread* self = Thread::Current();
-    {
-        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
-        const std::vector<gc::space::ContinuousSpace*>& continues_spaces = heap->GetContinuousSpaces();
-        for (size_t i = 0; i < continues_spaces.size(); ++i) {
-            gc::space::ContinuousSpace* space = continues_spaces[i];
-            if (space->Contains(obj)) {
-                return "continues_spaces-" + std::to_string(i) + "-" + space->GetName();
-            }
-        }
-    }
-
-    return "other_space";
-}
-
-class ObjectInfo {
-public:
-    ObjectInfo(size_t object_address, size_t object_size, std::string&& space)
-        : object_address_(object_address), object_size_(object_size), space_(space) {}
-
-    std::string ToString() const {
-        std::ostringstream string_stream;
-        string_stream << "address= " << object_address_
-                      << " size= " << object_size_
-                      << " space= " << space_;
-        return string_stream.str();
-    }
-
-private:
-    size_t object_address_;
-    size_t object_size_;
-    std::string space_;
-};
-
-void PrintRegionSpaceInformation(uint32_t info_key) {
-    Thread* self = Thread::Current();
-    gc::Heap* heap = Runtime::Current()->GetHeap();
-    gc::space::RegionSpace* region_space = heap->GetRegionSpace();
-    std::vector<ObjectInfo> object_infomations;
-    auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_) {
-        if (obj != nullptr) {
-            size_t object_address, object_size;
-            object_address = reinterpret_cast<size_t>(obj);
-            object_size = obj->SizeOf();
-            std::string space = "region_space";
-            object_infomations.emplace_back(ObjectInfo(object_address, object_size, std::move(space)));
-        }
-    }; 
-    {
-        WriterMutexLock mu(self, *Locks::mutator_lock_);  
-        region_space -> Walk(visitor);
-    }
-    for (const auto& info : object_infomations) {
-        LOG(INFO) << "jiacheng jiacheng_utils.cc 269 "
-                  << " key= " << info_key 
-                  << " info= " << info.ToString();
-    }
-}
-
-void PrintLargeObjectSpaceInformation(uint32_t info_key) {
-    gc::Heap* heap = Runtime::Current()->GetHeap();
-    gc::space::LargeObjectSpace* large_object_space = heap->GetLargeObjectsSpace();
-    // std::vector<ObjectInfo> object_infomations;
-    WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* info_key) {
-        if (start != end) {
-            size_t object_address, object_size;
-            object_address = reinterpret_cast<size_t>(start);
-            object_size = size_t(end) - size_t(start);
-            std::string space = "large_object_space";
-            ObjectInfo info(object_address, object_size, std::move(space));
-            // object_infomations.emplace_back(ObjectInfo(object_address, object_size, std::move(space)));
-            LOG(INFO) << "jiacheng jiacheng_utils.cc 269 "
-                        << " key= " << *((uint32_t *)(info_key))
-                        << " info= " << info.ToString();
-        }
-    }; 
-    large_object_space->Walk(walk_callback, &info_key);
-    // for (const auto& info : object_infomations) {
-
-    // }
-}
-
-void PrintNonMovingSpaceInformation(uint32_t info_key) {
-    gc::Heap* heap = Runtime::Current()->GetHeap();
-    gc::space::MallocSpace* non_moving_space = heap->GetNonMovingSpace();
-    // std::vector<ObjectInfo> object_infomations;
-    WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* info_key) {
-        if (start != end) {
-            size_t object_address, object_size;
-            object_address = reinterpret_cast<size_t>(start);
-            object_size = size_t(end) - size_t(start);
-            std::string space = "non_moving_space";
-            ObjectInfo info(object_address, object_size, std::move(space));
-            // object_infomations.emplace_back(ObjectInfo(object_address, object_size, std::move(space)));
-            LOG(INFO) << "jiacheng jiacheng_utils.cc 269 "
-                        << " key= " << *((uint32_t *)(info_key))
-                        << " info= " << info.ToString();
-        }
-    }; 
-    non_moving_space->Walk(walk_callback, &info_key);
-    // for (const auto& info : object_infomations) {
-    //     LOG(INFO) << "jiacheng jiacheng_utils.cc 269 "
-    //               << " key= " << info_key 
-    //               << " info= " << info.ToString();
-    // }
-}
-
-void PrintHeapObjectInformation() {
-    // std::vector<ObjectInfo> object_infomations;
-
-    // gc::Heap* heap = Runtime::Current()->GetHeap();
-    // Thread* self = Thread::Current();
-    // {
-    //     auto visitor = [&](mirror::Object* obj) REQUIRES_SHARED(Locks::mutator_lock_) {
-    //         if (obj != nullptr) {
-    //             size_t object_address, object_size;
-    //             object_address = reinterpret_cast<size_t>(obj);
-    //             object_size = obj->SizeOf();
-    //             std::string space = GetSpaceFromObject(obj);
-    //             object_infomations.emplace_back(ObjectInfo(object_address, object_size, std::move(space)));
-    //         }
-    //     };        
-    //     ScopedObjectAccess soa(self);
-    //     heap->VisitObjects(visitor);
-    // }
-    // uint32_t key = GenerateRandomKey();
-    // for (const auto& info : object_infomations) {
-    //     LOG(INFO) << "jiacheng jiacheng_utils.cc 269 "
-    //               << " key= " << key 
-    //               << " info= " << info.ToString();
-    // }
-    uint32_t key = GenerateRandomKey();
-    PrintLargeObjectSpaceInformation(key);
-    PrintRegionSpaceInformation(key);
-    PrintNonMovingSpaceInformation(key);
-
-}
-
-void VisitMemMap(const MemMap* mem_map) {
-    LOG(INFO) << "jiacheng VisitMemMap ";
-    LOG(INFO) << (*mem_map);
-    uint8_t* begin = mem_map->Begin();
-    uint8_t* end = mem_map->End();
-    void* base_begin = mem_map->BaseBegin();
-    void* base_end = mem_map->BaseEnd();
-    LOG(INFO) << "begin= " << reinterpret_cast<size_t>(begin) << ' '
-              << "end= " << reinterpret_cast<size_t>(end) << ' '
-              << "base_begin= " << reinterpret_cast<size_t>(base_begin) << ' '
-              << "base_end= " << reinterpret_cast<size_t>(base_end);
-    // print every byte
-    // for(uint8_t* p = begin; p != end; ++p) {
-    //     LOG(INFO) << static_cast<int>(*p);
-    // }
-
-}
-
-template<size_t kAlignment>
-void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* ) {
-}
-
-void VisitHeapBitmap(const gc::accounting::HeapBitmap* ) {
-}
-
-void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set) {
-    LOG(INFO) << "jiacheng VisitRememberedSet ";
-    auto table = const_cast<gc::accounting::RememberedSet*>(remembered_set);
-    {
-        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
-        table->Dump(LOG_STREAM(INFO));
-    }
-
-}
-
-void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table) {
-    LOG(INFO) << "jiacheng VisitModUnionTableToZygoteAllocspace ";
-    auto table = const_cast<gc::accounting::ModUnionTableToZygoteAllocspace*>(static_cast<const gc::accounting::ModUnionTableToZygoteAllocspace*>(mod_union_table));
-    {
-        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
-        table->Dump(LOG_STREAM(INFO));
-    }
-}
-
-void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table) {
-    LOG(INFO) << "jiacheng VisitModUnionTableCardCache ";
-    auto table = const_cast<gc::accounting::ModUnionTableCardCache*>(static_cast<const gc::accounting::ModUnionTableCardCache*>(mod_union_table));
-    {
-        ReaderMutexLock mu(Thread::Current(), *Locks::mutator_lock_);
-        table->Dump(LOG_STREAM(INFO));
-    }
-}
-
-void VisitCardTable(const gc::accounting::CardTable* card_table) {
-    (void)card_table;
-    LOG(INFO) << "jiacheng VisitCardTable ";
-    // MemMap* mem_map = &(card_table->mem_map_);
-    // uint8_t* const biased_begin = card_table->biased_begin_;
-    // const size_t offset = card_table->offset_;
-
-    // VisitMemMap(mem_map);
-    // LOG(INFO) << "biased_begin= " << reinterpret_cast<size_t>(biased_begin);
-    // LOG(INFO) << "offset= " << offset;
-}
-
-void DebugPrintModUnionAndRememberSet() {
-    if (Runtime::Current()->IsZygote()) {
-        return;
-    }
-    if (!Runtime::Current()->InJankPerceptibleProcessState()) {
-      LOG(INFO) << "jiacheng " << "InJankPerceptibleProcessState" ;
-      return;
-    }
-    // if (jiacheng::CheckHot()) {
-    //   LOG(INFO) << "jiacheng " << "CheckHot";
-    //   return;
-    // }  
-
-    gc::Heap* heap = Runtime::Current()->GetHeap();
-
-    Thread* self = Thread::Current();
-    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
-    {
-        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
-        continues_spaces = &(heap->GetContinuousSpaces());
-    }
-    for (auto space : *continues_spaces) {
-        LOG(INFO) << space->GetName();
-        gc::space::SpaceType space_type = space->GetType();
-        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
-        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
-        if (mod_union_table) {
-            LOG(INFO) << "jiacheng mod_union_table";
-            if (space_type == gc::space::kSpaceTypeZygoteSpace) {
-                VisitModUnionTableCardCache(mod_union_table);
-            } else if (space_type == gc::space::kSpaceTypeImageSpace) {
-                VisitModUnionTableToZygoteAllocspace(mod_union_table);
-            }
-        } 
-        if (remembered_set) {
-            LOG(INFO) << "jiacheng remembered_set";
-            VisitRememberedSet(remembered_set);
-        }
-        if (mod_union_table == nullptr && remembered_set == nullptr) {
-            LOG(INFO) << "nullptr";
-        }
-    }
-    const std::vector<gc::space::DiscontinuousSpace*>* discontinues_spaces = &(heap->GetDiscontinuousSpaces());
-    for (auto space : *discontinues_spaces) {
-        LOG(INFO) << space->GetName();
-        gc::accounting::ModUnionTable* mod_union_table = heap->FindModUnionTableFromSpace(space);
-        gc::accounting::RememberedSet* remembered_set = heap->FindRememberedSetFromSpace(space);
-        if (mod_union_table) {
-            LOG(INFO) << "jiacheng mod_union_table";
-        } 
-        if (remembered_set) {
-            LOG(INFO) << "jiacheng remembered_set";
-        }
-        if (mod_union_table == nullptr && remembered_set == nullptr) {
-            LOG(INFO) << "nullptr";
-        }
-    }
-}
-
-
-
-
-}
-}
\ No newline at end of file
diff --git a/runtime/jiacheng_debug.h b/runtime/jiacheng_debug.h
deleted file mode 100644
index 9a240f8472..0000000000
--- a/runtime/jiacheng_debug.h
+++ /dev/null
@@ -1,65 +0,0 @@
-#ifndef ART_RUNTIME_JIACHENG_DEBUG_H_
-#define ART_RUNTIME_JIACHENG_DEBUG_H_
-
-namespace art {
-
-namespace gc {
-namespace space {
-    class Space;
-} // namespace space
-namespace accounting {
-    template <size_t kAlignment> class SpaceBitmap;
-    class HeapBitmap;
-    class RememberedSet;
-    class ModUnionTable;
-    class CardTable;
-} // namespace accounting
-} // namespace gc
-
-namespace mirror {
-    class Object;
-} // namespace mirror
-
-class MemMap;
-
-namespace jiacheng {
-
-void RecordWorkingSet(mirror::Object* obj);
-
-void ClearAndPrintWorkingSet();
-
-void SwapOutAll();
-
-void SwapOutSpace(gc::space::Space* space);
-
-
-/* ------------------- debug --------------------- */
-
-
-std::string GetSpaceFromObject(mirror::Object* obj);
-
-void PrintHeapObjectInformation();
-
-void VisitMemMap(const MemMap* mem_map);
-
-template<size_t kAlignment>
-void VisitSpaceBitmap(const gc::accounting::SpaceBitmap<kAlignment>* );
-
-void VisitHeapBitmap(const gc::accounting::HeapBitmap* );
-
-void VisitRememberedSet(const gc::accounting::RememberedSet* remembered_set);
-
-void VisitModUnionTableToZygoteAllocspace(const gc::accounting::ModUnionTable* mod_union_table);
-
-void VisitModUnionTableCardCache(const gc::accounting::ModUnionTable* mod_union_table);
-
-void VisitCardTable(const gc::accounting::CardTable* card_table);
-
-void DebugPrintModUnionAndRememberSet();
-
-
-} // namespace jiacheng
-} // namespace art
-
-
-#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_profiler.cc b/runtime/jiacheng_profiler.cc
deleted file mode 100644
index 921c52e14c..0000000000
--- a/runtime/jiacheng_profiler.cc
+++ /dev/null
@@ -1,245 +0,0 @@
-#include "jiacheng_profiler.h"
-#include "jiacheng_utils.h"
-#include "jiacheng_debug.h"
-#include "jiacheng_hack.h"
-#include "jiacheng_common.h"
-
-#include "thread-inl.h"
-#include "mirror/object.h"
-
-namespace art {
-namespace jiacheng {
-
-
-Mutex Profiler::singleton_lock_("Profiler Singleton Lock", kLoggingLock);
-Profiler* Profiler::instance_(nullptr); 
-
-Profiler::Profiler():
-    access_bloom_filter_(1000000, 1e-4),
-    read_working_set_(),
-    read_working_set_lock_("read_working_set_lock", kJiachengWorkingSetLock),
-    access_working_set_size_(0),
-    gc_bloom_filter_(1000000, 1e-4),
-    gc_working_set_(),
-    gc_working_set_lock_("gc_working_set_lock", kJiachengWorkingSetLock),
-    gc_working_set_size_(0),
-    cold_set_(),
-    cold_set_lock_("cold_set_lock", kJiachengColdSpaceLock),
-    during_gc_flag_(false),
-    perceptible_flag_(true),
-    gc_number_(0),
-    start_time_(0),
-    current_time_(1000),
-    background_time_(0) {
-}
-
-Profiler::~Profiler() = default;
-
-Profiler* Profiler::Create() {
-    Profiler* it = new Profiler();
-    return it;
-}
-
-Profiler* Profiler::Current() {
-    if (instance_ == nullptr) {
-        Thread* self = Thread::Current();
-        singleton_lock_.ExclusiveLock(self);
-        if (instance_ == nullptr) {
-            instance_ = Create();
-        }
-        singleton_lock_.ExclusiveUnlock(self);
-    }
-    return instance_;
-}
-
-void Profiler::JiachengDebug() {
-    LOG(INFO) << "jiacheng jiacheng_profiler.cc 39" 
-              << " access_working_set_size= " << access_working_set_size_.load()
-              << " gc_working_set_size_= " << gc_working_set_size_.load()
-              << " during_gc_flag_= " << during_gc_flag_.load()
-              << " perceptible_flag_= " << perceptible_flag_.load()
-              << " gc_number_= " << gc_number_.load()
-              << std::flush
-              ;
-}
-
-void Profiler::RecordAccessWS(mirror::Object* obj) {
-    // Thread* self = Thread::Current();
-    // read_working_set_lock_.ExclusiveLock(self);
-    // read_working_set_.insert(obj);
-    // read_working_set_lock_.ExclusiveUnlock(self);
-
-    if (!access_bloom_filter_.Add(reinterpret_cast<uint64_t>(obj))) {
-        access_working_set_size_.fetch_add(1);
-    }
-}
-
-void Profiler::ClearAccessWS() {
-    // Thread* self = Thread::Current();
-    // read_working_set_lock_.ExclusiveLock(self);
-    // read_working_set_.clear();
-    // read_working_set_lock_.ExclusiveUnlock(self);
-
-    access_bloom_filter_.Clear();
-    access_working_set_size_.store(0);
-}
-
-bool Profiler::TestInAccessWS(mirror::Object* obj) {
-    // Thread* self = Thread::Current();
-    // read_working_set_lock_.ExclusiveLock(self);
-    // bool result = (read_working_set_.find(obj) != read_working_set_.end());
-    // read_working_set_lock_.ExclusiveUnlock(self);
-
-    // return access_bloom_filter_.Check(reinterpret_cast<uint64_t>(obj)) || obj->GetAccess();
-    return access_bloom_filter_.Check(reinterpret_cast<uint64_t>(obj));
-}
-
-
-void Profiler::RecordGcWS(mirror::Object* obj) {
-    // Thread* self = Thread::Current();
-    // gc_working_set_lock_.ExclusiveLock(self);
-    // gc_working_set_.insert(obj);
-    // gc_working_set_lock_.ExclusiveUnlock(self);
-    if (!gc_bloom_filter_.Add(reinterpret_cast<uint64_t>(obj))) {
-        gc_working_set_size_.fetch_add(1);
-    }
-}
-
-void Profiler::ClearGcWS() {
-    // Thread* self = Thread::Current();
-    // gc_working_set_lock_.ExclusiveLock(self);
-    // gc_working_set_.clear();
-    // gc_working_set_lock_.ExclusiveUnlock(self);
-    gc_bloom_filter_.Clear();
-    gc_working_set_size_.store(0);
-}
-
-bool Profiler::TestInGcWS(mirror::Object* obj) {
-    // Thread* self = Thread::Current();
-    // gc_working_set_lock_.ExclusiveLock(self);
-    // bool result = (gc_working_set_.find(obj) != gc_working_set_.end());
-    // gc_working_set_lock_.ExclusiveUnlock(self);
-    return gc_bloom_filter_.Check(reinterpret_cast<uint64_t>(obj));
-}
-
-void Profiler::SetDuringGcFlag() {
-    during_gc_flag_.store(true);
-}
-
-void Profiler::ClearDuringGcFlag() {
-    during_gc_flag_.store(false);
-}
-
-// bool Profiler::GetDuringGcFlag() {
-//     return during_gc_flag_.load();
-// }
-
-void Profiler::SetPerceptibleFlag() {
-    perceptible_flag_.store(true);
-}
-
-void Profiler::ClearPerceptibleFlag() {
-    perceptible_flag_.store(false);
-}
-
-bool Profiler::GetPerceptibleFlag() {
-    return perceptible_flag_.load();
-}
-
-void Profiler::SetSwitchingFlag() {
-    switching_flag_.store(true);
-}
-
-void Profiler::ClearSwitchingFlag() {
-    switching_flag_.store(false);
-}
-
-bool Profiler::GetSwitchingFlag() {
-    return switching_flag_.load();
-}
-
-bool Profiler::ShouldSwapOut(mirror::Object* obj) {
-    if (!obj) {
-        return false;
-    }
-    if(!IsWhiteApp()) {
-        return false;
-    }
-    if (GetPerceptibleFlag()) {
-        return false;
-    }
-    if (!ObjectIsSwappableType(obj)) {
-        return false;
-    }
-    // if (current_time_-background_time_ <= 0) {
-    //     return false;
-    // }
-    uint16_t foreground_access_record = obj->GetForegroundAccessRecord();
-    uint16_t background_access_record = obj->GetBackgroundAccessRecord();
-    uint16_t switching_access_record = obj->GetSwitchAccessRecord();
-
-    // LOG(INFO) << "jiacheng debug jiacheng_profiler.cc 161 ShouldSwapOut() "
-    //           << " foreground_access_record= " << foreground_access_record
-    //           << " background_access_record= " << background_access_record
-    //           << " switching_access_record= " << switching_access_record
-    //           << " background_time_= " << background_time_
-    //           << " switching_time_= " << switching_time_
-    //           << " GetCurrentTime()= " << GetCurrentTime();
-    
-    uint16_t foreground_distance = background_time_ - foreground_access_record;
-    uint16_t background_distance = current_time_ - background_access_record;
-    bool foreground_ws = RESERVE_FOREGROUND_WS_FLAG && (foreground_distance < FOREGROUND_WS_WINDOW_SIZE);
-    bool background_ws = (background_distance < BACKGROUND_WS_WINDOW_SIZE);
-    bool switching_ws = RESERVE_SWITCHING_WS_FLAG && (switching_access_record != 0);
-    if (foreground_ws || background_ws || switching_ws) {
-        return false;
-    } 
-    return true;
-}
-
-void Profiler::IncreaseGcNumber() {
-    gc_number_.fetch_add(1);
-}
-
-uint32_t Profiler::GetGcNumber() {
-    return gc_number_.load();
-}
-
-void Profiler::SetStartTime(uint64_t start_time) {
-    start_time_.store(start_time);
-}
-
-uint64_t Profiler::GetStartTime() {
-    return start_time_.load();
-}
-
-void Profiler::SetCurrentTime(uint16_t current_time) {
-    current_time_.store(current_time);
-}
-
-void Profiler::IncreaseCurrentTime() {
-    current_time_.fetch_add(1);
-}
-
-uint16_t Profiler::GetCurrentTime() {
-    return current_time_.load();
-}
-
-void Profiler::SetBackgroundTime(uint16_t background_time) {
-    background_time_.store(background_time);
-}
-
-uint16_t Profiler::GetBackgroundTime() {
-    return background_time_.load();
-}
-
-void Profiler::SetSwitchingTime(uint16_t switching_time) {
-    switching_time_.store(switching_time);
-}
-
-uint16_t Profiler::GetSwitchingTime() {
-    return switching_time_.load();
-}
- 
-} // namespace jiacheng
-} // namespace art
\ No newline at end of file
diff --git a/runtime/jiacheng_profiler.h b/runtime/jiacheng_profiler.h
deleted file mode 100644
index 70c2d370fc..0000000000
--- a/runtime/jiacheng_profiler.h
+++ /dev/null
@@ -1,119 +0,0 @@
-#ifndef ART_RUNTIME_JIACHENG_PROFILER_H_
-#define ART_RUNTIME_JIACHENG_PROFILER_H_
-
-#include <set>
-#include <map>
-#include <atomic>
-
-#include "base/mutex.h"
-
-#include "jiacheng_bloom_filter.h"
-
-namespace art {
-
-namespace mirror {
-    class Object;
-}
-
-namespace jiacheng {
-
-class Profiler {
-public:
-    static Mutex singleton_lock_;
-    static Profiler* instance_; 
-
-    static Profiler* Create();
-
-    static Profiler* Current();
-
-    Profiler();
-    ~Profiler();
-
-    void JiachengDebug();
-
-    // Mutator的工作集估计
-    void RecordAccessWS(mirror::Object* obj);
-    void ClearAccessWS();
-    bool TestInAccessWS(mirror::Object* obj);
-
-    // GC的工作集估计
-    void RecordGcWS(mirror::Object* obj);
-    void ClearGcWS();
-    bool TestInGcWS(mirror::Object* obj);
-
-    void SetDuringGcFlag();
-    void ClearDuringGcFlag();
-
-    bool GetDuringGcFlag() {
-        return during_gc_flag_.load();
-    }
-
-    void SetPerceptibleFlag();
-    void ClearPerceptibleFlag();
-    bool GetPerceptibleFlag();
-
-    void SetSwitchingFlag();
-    void ClearSwitchingFlag();
-    bool GetSwitchingFlag();
-
-    bool ShouldSwapOut(mirror::Object* obj);
-
-    void IncreaseGcNumber();
-    uint32_t GetGcNumber();
-
-    void SetStartTime(uint64_t start_time);
-    uint64_t GetStartTime();
-
-    void SetCurrentTime(uint16_t current_time);
-    void IncreaseCurrentTime();
-    uint16_t GetCurrentTime();
-
-    void SetBackgroundTime(uint16_t background_time);
-    uint16_t GetBackgroundTime();
-
-    void SetSwitchingTime(uint16_t switching_time);
-    uint16_t GetSwitchingTime();
-
-private:
-    // Mutator的Working Set
-    BloomFilter access_bloom_filter_;
-    std::set<mirror::Object*> read_working_set_;
-    Mutex read_working_set_lock_;
-    std::atomic<uint32_t> access_working_set_size_;
-
-    // GC的Working Set
-    BloomFilter gc_bloom_filter_;
-    std::set<mirror::Object*> gc_working_set_;
-    Mutex gc_working_set_lock_;
-    std::atomic<uint32_t> gc_working_set_size_;
-
-    // 需要换出去的对象集合Cold Set
-    std::set<mirror::Object*> cold_set_;
-    Mutex cold_set_lock_;
-
-    // 每次GC开始的时候设置为true, GC结束的时候设置为false
-    std::atomic<bool> during_gc_flag_;
-
-    // APP当前在前台还是后台
-    std::atomic<bool> perceptible_flag_;
-
-    // set in UpdateProcessState(), clear in main thread
-    std::atomic<bool> switching_flag_; 
-
-    // 历史GC发生的总次数
-    std::atomic<uint32_t> gc_number_;
-
-    std::atomic<uint64_t> start_time_;
-
-    std::atomic<uint16_t> current_time_;
-
-    std::atomic<uint16_t> background_time_;
-
-    // Update in UpdateProcessState() function
-    std::atomic<uint16_t> switching_time_; 
-};
-
-}
-}
-
-#endif
\ No newline at end of file
diff --git a/runtime/jiacheng_swapper.cc b/runtime/jiacheng_swapper.cc
deleted file mode 100644
index 71ab931919..0000000000
--- a/runtime/jiacheng_swapper.cc
+++ /dev/null
@@ -1,189 +0,0 @@
-#include "jiacheng_swapper.h"
-
-#include "jiacheng_profiler.h"
-#include "jiacheng_utils.h"
-#include "jiacheng_debug.h"
-#include "jiacheng_common.h"
-
-#include "thread-inl.h"
-#include "runtime.h"
-#include "gc/heap.h"
-#include "gc/space/space-inl.h"
-#include "gc/space/region_space.h"
-#include "gc/space/image_space.h"
-#include "gc/space/malloc_space.h"
-#include "gc/space/zygote_space.h"
-#include "gc/space/bump_pointer_space.h"
-#include "gc/space/large_object_space.h"
-
-namespace art {
-namespace jiacheng {
-
-typedef void(*WalkCallback)(void *start, void *end, size_t num_bytes, void* callback_arg);
-
-Mutex Swapper::singleton_lock_("Swapper Singleton Lock", kLoggingLock);;
-Swapper* Swapper::instance_(nullptr); 
-
-Swapper* Swapper::Create() {
-    Swapper* it = new Swapper();
-    it->Start();
-    return it;
-}
-
-Swapper* Swapper::Current() {
-    if (instance_ == nullptr) {
-        Thread* self = Thread::Current();
-        singleton_lock_.ExclusiveLock(self);
-        if (instance_ == nullptr) {
-            instance_ = Create();
-        }
-        singleton_lock_.ExclusiveUnlock(self);
-    }
-    return instance_;
-}
-
-Swapper::Swapper():swap_thread_(nullptr) {}
-
-Swapper::~Swapper() = default;
-
-
-void Swapper::Run() {
-    uint32_t swapout_time = 0;
-    Profiler* profiler = Profiler::Current();
-    bool gc_flag, perceptible_flag;
-
-    while (true) {
-        ++swapout_time;
-        CurrentThreadSleepSecond(CLOCK_TICK);
-        profiler->IncreaseCurrentTime();
-
-        // handle switching flag
-        uint16_t current_time = profiler->GetCurrentTime();
-        uint16_t switching_time = profiler->GetSwitchingTime();
-        if (profiler->GetSwitchingFlag()) {
-            if (current_time - switching_time >= SWITCHING_WINDOW_SIZE) {
-                profiler->ClearSwitchingFlag();
-            }
-        }
-
-        gc_flag = profiler->GetDuringGcFlag();
-        perceptible_flag = profiler->GetPerceptibleFlag();
-
-        if (ACTIVE_SWAPOUT && !gc_flag && !perceptible_flag && swapout_time>=SWAPOUT_WINDOW_SIZE) {
-            swapout_time = 0;
-            SwapOutHeap();
-        }
-    }
-}
-
-void Swapper::Start() {
-    swap_thread_ = new std::thread(&Swapper::Run, this);
-    swap_thread_->detach();
-}
-
-void Swapper::SwapOutHeap() {
-    gc::Heap* heap = Runtime::Current()->GetHeap();
-    Thread* self = Thread::Current();
-    const std::vector<gc::space::ContinuousSpace*>* continues_spaces;
-    {
-        ReaderMutexLock mu(self, *Locks::mutator_lock_); 
-        continues_spaces = &(heap->GetContinuousSpaces());
-    }
-    for (gc::space::ContinuousSpace* space : *continues_spaces) {
-        switch (space->GetType()) {
-            case gc::space::kSpaceTypeImageSpace: {
-                gc::space::ImageSpace* this_space = space->AsImageSpace();
-                SwapOutImageSpace(this_space);
-                break;
-            }
-            case gc::space::kSpaceTypeMallocSpace: {
-                gc::space::MallocSpace* this_space = space->AsMallocSpace();
-                SwapOutMallocSpace(this_space);
-                break;
-            }
-            case gc::space::kSpaceTypeZygoteSpace: {
-                gc::space::ZygoteSpace* this_space = space->AsZygoteSpace();
-                SwapOutZygoteSpace(this_space);
-                break;
-            }
-            case gc::space::kSpaceTypeBumpPointerSpace: {
-                gc::space::BumpPointerSpace* this_space = space->AsBumpPointerSpace();
-                SwapOutBumpPointerSpace(this_space);
-                break;
-            }
-            case gc::space::kSpaceTypeLargeObjectSpace: {
-                gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
-                SwapOutLargeObjectSpace(this_space);
-                break;
-            }
-            case gc::space::kSpaceTypeRegionSpace: {
-                gc::space::RegionSpace* this_space = space->AsRegionSpace();   
-                SwapOutRegionSpace(this_space);
-                break;
-            }
-            default: {
-                UNIMPLEMENTED(FATAL) << "Invalid ContinuousSpace !" << *space;
-            }
-        }
-    }
-    const std::vector<gc::space::DiscontinuousSpace*>& discontinues_spaces = heap->GetDiscontinuousSpaces();
-    for (gc::space::DiscontinuousSpace* space : discontinues_spaces) {
-        if(space->IsLargeObjectSpace()) {
-            gc::space::LargeObjectSpace* this_space = space->AsLargeObjectSpace();
-            SwapOutLargeObjectSpace(this_space);
-        } else {
-            UNIMPLEMENTED(FATAL) << "Invalid DiscontinuousSpace !" << *space;
-        }
-    }     
-}
-
-void Swapper::SwapOutImageSpace(gc::space::ImageSpace* space) {
-    // LOG(INFO) << "jiacheng jiacheng_swapper.cc 144 SwapOutImageSpace()";
-    (void)space;
-}
-
-void Swapper::SwapOutMallocSpace(gc::space::MallocSpace* space) {
-    (void)space;
-    CHECK(space == Runtime::Current()->GetHeap()->GetNonMovingSpace());
-    LOG(INFO) << "jiacheng jiacheng_swapper.cc 144 SwapOutMallocSpace()";
-    WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* ) {
-        if (start != end) {
-            jiacheng::SwapOutRange(start, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start));
-        }
-    };
-    space->Walk(walk_callback, nullptr);
-}
-
-void Swapper::SwapOutZygoteSpace(gc::space::ZygoteSpace* space) {
-    (void)space;
-    // LOG(INFO) << "jiacheng jiacheng_swapper.cc 144 SwapOutZygoteSpace()";
-    // jiacheng::SwapOutRange(space->Begin(), space->Size());
-}
-
-void Swapper::SwapOutBumpPointerSpace(gc::space::BumpPointerSpace* space) {
-    (void)space;
-    UNIMPLEMENTED(FATAL);
-}
-
-void Swapper::SwapOutLargeObjectSpace(gc::space::LargeObjectSpace* space) {
-    LOG(INFO) << "jiacheng jiacheng_swapper.cc 144 SwapOutLargeObjectSpace()";
-    WalkCallback walk_callback = [](void* start, void* end, size_t /*num_bytes*/, void* ) {
-        if (start != end) {
-            jiacheng::SwapOutRange(start, reinterpret_cast<size_t>(end) - reinterpret_cast<size_t>(start));
-        }
-    };
-    space->Walk(walk_callback, nullptr);
-}
-
-void Swapper::SwapOutRegionSpace(gc::space::RegionSpace* space) {
-    LOG(INFO) << "jiacheng jiacheng_swapper.cc 144 SwapOutRegionSpace()";
-    space->SwapOutCold();
-}
-
-
-void Swapper::JiachengDebug() {
-
-}
-
-} // namespace jiacheng
-} // namespace art
diff --git a/runtime/jiacheng_swapper.h b/runtime/jiacheng_swapper.h
deleted file mode 100644
index c860558282..0000000000
--- a/runtime/jiacheng_swapper.h
+++ /dev/null
@@ -1,63 +0,0 @@
-#ifndef ART_RUNTIME_JIACHENG_SWAPPER_H_
-#define ART_RUNTIME_JIACHENG_SWAPPER_H_
-
-#include <atomic>
-#include <thread>
-
-#include "base/mutex.h"
-
-namespace art {
-namespace gc {
-namespace space {
-    class ImageSpace;
-    class MallocSpace;
-    class ZygoteSpace;
-    class BumpPointerSpace;
-    class LargeObjectSpace;
-    class RegionSpace;
-}
-}
-
-namespace jiacheng {
-
-class Swapper {
-public:
-    static Mutex singleton_lock_;
-    static Swapper* instance_; 
-
-    static Swapper* Create();
-    static Swapper* Current();
-
-    Swapper();
-    ~Swapper();
-
-    void Start();
-
-    void SwapOutHeap();
-
-    void SwapOutImageSpace(gc::space::ImageSpace* space);
-
-    void SwapOutMallocSpace(gc::space::MallocSpace* space);
-
-    void SwapOutZygoteSpace(gc::space::ZygoteSpace* space);
-
-    void SwapOutBumpPointerSpace(gc::space::BumpPointerSpace* space);
-
-    void SwapOutLargeObjectSpace(gc::space::LargeObjectSpace* space);
-
-    void SwapOutRegionSpace(gc::space::RegionSpace* space);
-
-    void JiachengDebug();
-
-private:
-    [[noreturn]] void Run();
-
-    std::thread* swap_thread_;
-};
-
-
-
-} // namespace jiacheng
-} // namespace art
-
-#endif
\ No newline at end of file
diff --git a/tools/cpp-define-generator/thread.def b/tools/cpp-define-generator/thread.def
index 8c91dc8a87..72154dc6e1 100644
--- a/tools/cpp-define-generator/thread.def
+++ b/tools/cpp-define-generator/thread.def
@@ -20,6 +20,10 @@
 
 ASM_DEFINE(THREAD_CARD_TABLE_OFFSET,
            art::Thread::CardTableOffset<art::kRuntimePointerSize>().Int32Value())
+// jiacheng start
+ASM_DEFINE(THREAD_CARD_TABLE2_OFFSET,
+           art::Thread::CardTable2Offset<art::kRuntimePointerSize>().Int32Value())
+// jiacheng end
 ASM_DEFINE(THREAD_CHECKPOINT_REQUEST,
            art::kCheckpointRequest)
 ASM_DEFINE(THREAD_CURRENT_IBASE_OFFSET,
-- 
2.34.1


From 16036a23be2bec42a3f7cfb9313a9b4dff816990 Mon Sep 17 00:00:00 2001
From: jiachengh <jiacheng.huang@outlook.com>
Date: Mon, 18 Mar 2024 14:20:17 +0800
Subject: [PATCH 7/7] add the debug micro and adjust the heap size when the app
 is in teh background

Change-Id: I1e58e6412c7d972fe3599ce743d0db78dfcdb54e
---
 compiler/optimizing/code_generator_arm64.cc  |  18 ++-
 compiler/optimizing/code_generator_arm64.h   |   4 +
 runtime/arch/arm64/quick_entrypoints_arm64.S |   5 +-
 runtime/asm_support.h                        |   4 +
 runtime/class_linker_test.cc                 |   9 +-
 runtime/gc/collector/concurrent_copying.cc   |   7 +
 runtime/gc/heap.cc                           |  33 ++++-
 runtime/gc/heap.h                            |   4 +
 runtime/jiacheng_barrier.cc                  |  15 +-
 runtime/jiacheng_bloom_filter.h              | 136 -------------------
 runtime/jiacheng_debug.h                     |  14 ++
 runtime/jiacheng_global.h                    |  12 +-
 runtime/mirror/array-inl.h                   |   6 +
 runtime/mirror/array.h                       |  10 +-
 runtime/mirror/object-inl.h                  |   8 ++
 runtime/mirror/object-refvisitor-inl.h       |   2 +
 runtime/mirror/object.cc                     |   2 +-
 runtime/mirror/object.h                      |  16 ++-
 runtime/thread-inl.h                         |   2 +
 19 files changed, 141 insertions(+), 166 deletions(-)
 delete mode 100644 runtime/jiacheng_bloom_filter.h
 create mode 100644 runtime/jiacheng_debug.h

diff --git a/compiler/optimizing/code_generator_arm64.cc b/compiler/optimizing/code_generator_arm64.cc
index a2710bc2ca..9168876bd3 100644
--- a/compiler/optimizing/code_generator_arm64.cc
+++ b/compiler/optimizing/code_generator_arm64.cc
@@ -1911,9 +1911,11 @@ void InstructionCodeGeneratorARM64::HandleFieldGet(HInstruction* instruction,
   MemOperand field = HeapOperand(InputRegisterAt(instruction, 0), field_info.GetFieldOffset());
 
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   if (load_type == DataType::Type::kReference) {
     codegen_->GenerateJiachengBarrierInline(RegisterFrom(base_loc, DataType::Type::kReference));
   }
+  #endif
   // jiacheng end
 
   if (kEmitCompilerReadBarrier && kUseBakerReadBarrier &&
@@ -1981,9 +1983,11 @@ void InstructionCodeGeneratorARM64::HandleFieldSet(HInstruction* instruction,
   DataType::Type field_type = field_info.GetFieldType();
 
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   if (instruction->GetType() == DataType::Type::kReference) {
     codegen_->GenerateJiachengBarrierInline(obj);
   }
+  #endif
   // jiacheng end
   
   {
@@ -2403,9 +2407,11 @@ void InstructionCodeGeneratorARM64::VisitArrayGet(HArrayGet* instruction) {
   UseScratchRegisterScope temps(masm);
 
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   if (type == DataType::Type::kReference) {
     codegen_->GenerateJiachengBarrierInline(obj.W());
   }
+  #endif
   // jiacheng end
 
   // The non-Baker read barrier instrumentation of object ArrayGet instructions
@@ -2539,10 +2545,12 @@ void InstructionCodeGeneratorARM64::VisitArrayLength(HArrayLength* instruction)
   vixl::aarch64::Register out = OutputRegister(instruction);
   
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   if (instruction->GetType() == DataType::Type::kReference) {
     Register obj = InputRegisterAt(instruction, 0);
     codegen_->GenerateJiachengBarrierInline(obj);
   }
+  #endif
   // jiacheng end
 
   {
@@ -2593,9 +2601,11 @@ void InstructionCodeGeneratorARM64::VisitArraySet(HArraySet* instruction) {
   MacroAssembler* masm = GetVIXLAssembler();
 
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   if (instruction->GetType() == DataType::Type::kReference) {
     codegen_->GenerateJiachengBarrierInline(array);
   }
+  #endif
   // jiacheng end
 
   if (!needs_write_barrier) {
@@ -5777,7 +5787,9 @@ void InstructionCodeGeneratorARM64::GenerateReferenceLoadOneRegister(
   Register out_reg = RegisterFrom(out, type);
 
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   codegen_->GenerateJiachengBarrierInline(out_reg);
+  #endif
   // jiacheng end
   
   if (read_barrier_option == kWithReadBarrier) {
@@ -5823,7 +5835,9 @@ void InstructionCodeGeneratorARM64::GenerateReferenceLoadTwoRegisters(
   Register obj_reg = RegisterFrom(obj, type);
 
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   codegen_->GenerateJiachengBarrierInline(obj_reg);
+  #endif
   // jiacheng end
 
   if (read_barrier_option == kWithReadBarrier) {
@@ -5863,7 +5877,9 @@ void CodeGeneratorARM64::GenerateGcRootFieldLoad(
   Register root_reg = RegisterFrom(root, DataType::Type::kReference);
 
   // jiacheng start
-  // GenerateJiachengBarrierInline(obj.X());
+  #ifdef JIACHENG_DEBUG
+  // GenerateJiachengBarrierInline(obj.X()); // Do not add this
+  #endif
   // jiacheng end
 
   if (read_barrier_option == kWithReadBarrier) {
diff --git a/compiler/optimizing/code_generator_arm64.h b/compiler/optimizing/code_generator_arm64.h
index 5d47655cb4..a7f1f39769 100644
--- a/compiler/optimizing/code_generator_arm64.h
+++ b/compiler/optimizing/code_generator_arm64.h
@@ -35,6 +35,10 @@
 #include "aarch64/macro-assembler-aarch64.h"
 #pragma GCC diagnostic pop
 
+// jiacheng start
+#include "jiacheng_global.h"
+// jiacheng end
+
 namespace art {
 
 namespace linker {
diff --git a/runtime/arch/arm64/quick_entrypoints_arm64.S b/runtime/arch/arm64/quick_entrypoints_arm64.S
index a335bcfd61..77e5363835 100644
--- a/runtime/arch/arm64/quick_entrypoints_arm64.S
+++ b/runtime/arch/arm64/quick_entrypoints_arm64.S
@@ -19,7 +19,6 @@
 
 #include "arch/quick_alloc_entrypoints.S"
 
-
 .macro INCREASE_FRAME frame_adjustment
     sub sp, sp, #(\frame_adjustment)
     .cfi_adjust_cfa_offset (\frame_adjustment)
@@ -1793,10 +1792,12 @@ ART_QUICK_ALLOC_OBJECT_ROSALLOC art_quick_alloc_object_initialized_rosalloc, art
     // a new observably-initialized class state.
 .endif
     // jiacheng start
+#ifdef JIACHENG_DEBUG
     SETUP_SAVE_EVERYTHING_FRAME
     bl allocationBarrierTrampoline
     RESTORE_SAVE_EVERYTHING_FRAME
     REFRESH_MARKING_REGISTER
+#endif
     // jiacheng end
     ret
 .endm
@@ -1868,10 +1869,12 @@ GENERATE_ALLOC_OBJECT_RESOLVED_TLAB art_quick_alloc_object_initialized_tlab, art
 // The compiler generates 'dmb ishst' for all new-array insts.
 
     // jiacheng start
+#ifdef JIACHENG_DEBUG
     SETUP_SAVE_EVERYTHING_FRAME
     bl allocationBarrierTrampoline
     RESTORE_SAVE_EVERYTHING_FRAME
     REFRESH_MARKING_REGISTER
+#endif
     // jiacheng end
     ret
 .endm
diff --git a/runtime/asm_support.h b/runtime/asm_support.h
index eac985685d..beb16d7bd0 100644
--- a/runtime/asm_support.h
+++ b/runtime/asm_support.h
@@ -23,4 +23,8 @@
 // Automatically generated header based on the asm_defines.def file.
 #include "asm_defines.h"
 
+// jiacheng start
+#include "jiacheng_debug.h"
+// jiacheng end
+
 #endif  // ART_RUNTIME_ASM_SUPPORT_H_
diff --git a/runtime/class_linker_test.cc b/runtime/class_linker_test.cc
index f5fe0b70a6..fee9f798ec 100644
--- a/runtime/class_linker_test.cc
+++ b/runtime/class_linker_test.cc
@@ -150,8 +150,11 @@ class ClassLinkerTest : public CommonRuntimeTest {
     EXPECT_EQ(11U, JavaLangObject->NumVirtualMethods());
     if (!kUseBrooksReadBarrier) {
       // jiacheng start
-      // EXPECT_EQ(2U, JavaLangObject->NumInstanceFields());
+      #ifdef JIACHENG_DEBUG
       EXPECT_EQ(4U, JavaLangObject->NumInstanceFields());
+      #else
+      EXPECT_EQ(2U, JavaLangObject->NumInstanceFields());
+      #endif
       // jiacheng end
     } else {
       EXPECT_EQ(4U, JavaLangObject->NumInstanceFields());
@@ -161,6 +164,7 @@ class ClassLinkerTest : public CommonRuntimeTest {
     EXPECT_STREQ(JavaLangObject->GetInstanceField(1)->GetName(),
                  "shadow$_monitor_");
     // jiacheng start
+    #ifdef JIACHENG_DEBUG
     EXPECT_STREQ(JavaLangObject->GetInstanceField(2)->GetName(),
                  "shadow$_z_padding_");
     EXPECT_STREQ(JavaLangObject->GetInstanceField(3)->GetName(),
@@ -171,6 +175,7 @@ class ClassLinkerTest : public CommonRuntimeTest {
                  "shadow$_z_zflags2_");
     EXPECT_STREQ(JavaLangObject->GetInstanceField(6)->GetName(),
                  "shadow$_z_zflags3_");
+    #endif
     // jiacheng end
     if (kUseBrooksReadBarrier) {
       EXPECT_STREQ(JavaLangObject->GetInstanceField(2)->GetName(),
@@ -582,11 +587,13 @@ struct ObjectOffsets : public CheckOffsets<mirror::Object> {
     addOffset(OFFSETOF_MEMBER(mirror::Object, klass_), "shadow$_klass_");
     addOffset(OFFSETOF_MEMBER(mirror::Object, monitor_), "shadow$_monitor_");
     // jiacheng start
+    #ifdef JIACHENG_DEBUG
     addOffset(OFFSETOF_MEMBER(mirror::Object, z_padding_), "shadow$_z_padding_");
     addOffset(OFFSETOF_MEMBER(mirror::Object, z_zflags0_), "shadow$_z_zflags0_");
     addOffset(OFFSETOF_MEMBER(mirror::Object, z_zflags1_), "shadow$_z_zflags1_");
     addOffset(OFFSETOF_MEMBER(mirror::Object, z_zflags2_), "shadow$_z_zflags2_");
     addOffset(OFFSETOF_MEMBER(mirror::Object, z_zflags3_), "shadow$_z_zflags3_");
+    #endif
     // jiacheng end
 #ifdef USE_BROOKS_READ_BARRIER
     addOffset(OFFSETOF_MEMBER(mirror::Object, x_rb_ptr_), "shadow$_x_rb_ptr_");
diff --git a/runtime/gc/collector/concurrent_copying.cc b/runtime/gc/collector/concurrent_copying.cc
index 08ad6906d0..9fda43e448 100644
--- a/runtime/gc/collector/concurrent_copying.cc
+++ b/runtime/gc/collector/concurrent_copying.cc
@@ -3882,6 +3882,11 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
   // static_assert(kObjectHeaderSize == sizeof(mirror::HeapReference<mirror::Class>) +
   //                   sizeof(LockWord),
   //               "Object header size does not match");
+  #ifndef  JIACHENG_DEBUG
+  static_assert(kObjectHeaderSize == sizeof(mirror::HeapReference<mirror::Class>) +
+                    sizeof(LockWord),
+                "Object header size does not match");
+  #endif
   // jiacheng end
   // Memcpy can tear for words since it may do byte copy. It is only safe to do this since the
   // object in the from space is immutable other than the lock word. b/31423258
@@ -3889,7 +3894,9 @@ mirror::Object* ConcurrentCopying::Copy(Thread* const self,
          reinterpret_cast<const uint8_t*>(from_ref) + kObjectHeaderSize,
          obj_size - kObjectHeaderSize);
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   to_ref->CopyHeaderFrom(from_ref);
+  #endif
   copy_num_.fetch_add(1, std::memory_order_relaxed);
   if (self != thread_running_gc_) {
     copy_from_barrier_num_.fetch_add(1, std::memory_order_relaxed);
diff --git a/runtime/gc/heap.cc b/runtime/gc/heap.cc
index bdabae97c3..eedd229cab 100644
--- a/runtime/gc/heap.cc
+++ b/runtime/gc/heap.cc
@@ -1000,13 +1000,16 @@ void Heap::ThreadFlipEnd(Thread* self) {
 void Heap::UpdateProcessState(ProcessState old_process_state, ProcessState new_process_state) {
   // jiacheng start
   const bool is_white_app = jiacheng::IsWhiteApp();
+  bool real_state_change = false;
   if (is_white_app) {
     if (new_process_state == kProcessStateJankImperceptible &&
         GetPerceptibleFlag()) {
+      real_state_change = true;
       ForeToBack();
     } else if (new_process_state == kProcessStateJankPerceptible && 
                !GetPerceptibleFlag()) {
       BackToFore();
+      real_state_change = true;
     }
   }
   // jiacheng end
@@ -1021,9 +1024,14 @@ void Heap::UpdateProcessState(ProcessState old_process_state, ProcessState new_p
           : background_collector_type_);
       usleep(kCollectorTransitionStressWait);
     }
+    // jiacheng start
+    LOG(INFO) << "jiacheng Heap::UpdateProcessState() jank_perceptible= " << jank_perceptible;
+    // jiacheng end
     if (jank_perceptible) {
       // Transition back to foreground right away to prevent jank.
-      RequestCollectorTransition(foreground_collector_type_, 0);
+      // jiacheng start
+      // RequestCollectorTransition(foreground_collector_type_, 0);
+      // jiacheng end
     } else {
       // Don't delay for debug builds since we may want to stress test the GC.
       // If background_collector_type_ is kCollectorTypeHomogeneousSpaceCompact then we have
@@ -1036,8 +1044,11 @@ void Heap::UpdateProcessState(ProcessState old_process_state, ProcessState new_p
       //                            kStressCollectorTransition
       //                                ? 0
       //                                : kCollectorTransitionWait);
-      if (jiacheng::ENABLE_APGC && is_white_app) {
-        RequestRelocateHotness(jiacheng::WINDOW_SIZE_BACKGROUND_WS * 1e9);
+      // It could be: (1) start in background state; (2) switch to the background during launch; 
+      if (is_white_app) {
+        if (jiacheng::ENABLE_APGC && !GetHotLaunchFlag() && real_state_change) {
+          RequestRelocateHotness(jiacheng::WINDOW_SIZE_BACKGROUND_WS * 1e9);
+        }
       } else {
         RequestCollectorTransition(background_collector_type_,
                                    kStressCollectorTransition ? 0 : kCollectorTransitionWait);
@@ -3713,9 +3724,21 @@ void Heap::GrowForUtilization(collector::GarbageCollector* collector_ran,
   // Use the multiplier to grow more for foreground.
   const double multiplier = HeapGrowthMultiplier();  // Use the multiplier to grow more for
   // foreground.
+  // jiacheng start
+  // const size_t adjusted_min_free = static_cast<size_t>(min_free_ * multiplier);
+  // const size_t adjusted_max_free = static_cast<size_t>(max_free_ * multiplier);
+  // if (gc_type != collector::kGcTypeSticky) {
+
+  // Because background GC is lightweight now, we can perform it more frequently to collect garbage in a timely manner
   const size_t adjusted_min_free = static_cast<size_t>(min_free_ * multiplier);
-  const size_t adjusted_max_free = static_cast<size_t>(max_free_ * multiplier);
-  if (gc_type != collector::kGcTypeSticky) {
+  size_t adjusted_max_free = static_cast<size_t>(max_free_ * multiplier);
+  bool goto_sticky = !CareAboutPauseTimes() && jiacheng::IsWhiteApp();
+  if (goto_sticky) {
+    // adjusted_max_free = adjusted_max_free / 20;
+    adjusted_max_free = adjusted_max_free / 10;
+  }
+  if (gc_type != collector::kGcTypeSticky && !goto_sticky) {
+  // jiacheng end
     // Grow the heap for non sticky GC.
     uint64_t delta = bytes_allocated * (1.0 / GetTargetHeapUtilization() - 1.0);
     DCHECK_LE(delta, std::numeric_limits<size_t>::max()) << "bytes_allocated=" << bytes_allocated
diff --git a/runtime/gc/heap.h b/runtime/gc/heap.h
index db6a646444..80b7ad089b 100644
--- a/runtime/gc/heap.h
+++ b/runtime/gc/heap.h
@@ -48,6 +48,10 @@
 #include "runtime_globals.h"
 #include "verify_object.h"
 
+// jiacheng start
+#include "jiacheng_global.h"
+// jiacheng end
+
 namespace art {
 
 class ConditionVariable;
diff --git a/runtime/jiacheng_barrier.cc b/runtime/jiacheng_barrier.cc
index 874291950d..b3045fc96f 100644
--- a/runtime/jiacheng_barrier.cc
+++ b/runtime/jiacheng_barrier.cc
@@ -13,8 +13,6 @@ namespace jiacheng {
 
 void JiachengBarrier(uint64_t obj) {
     if (!ENABLE_ACCESS_BARRIER) return;
-    // (void)obj;
-    // return;
     if (!obj) {
         return;
     }
@@ -31,13 +29,12 @@ void JiachengBarrier(uint64_t obj) {
 
 void AllocationNewBarrier(uint64_t obj) {
     if (!ENABLE_ALLOCATION_BARRIER) return;
-    (void)obj;
-    // mirror::Object* object = reinterpret_cast<mirror::Object*>(obj);
-    // object->SetTargetFlag();
-
-    // #ifdef JIACHENG_DEBUG
-    // object->SetDebugFlag(jiacheng::GenerateID());
-    // #endif
+    
+    #ifdef JIACHENG_DEBUG
+    mirror::Object* object = reinterpret_cast<mirror::Object*>(obj);
+    object->SetTargetFlag();
+    object->SetDebugFlag(jiacheng::GenerateID());
+    #endif
 
     JiachengBarrier(obj);
 }
diff --git a/runtime/jiacheng_bloom_filter.h b/runtime/jiacheng_bloom_filter.h
deleted file mode 100644
index 589e714a90..0000000000
--- a/runtime/jiacheng_bloom_filter.h
+++ /dev/null
@@ -1,136 +0,0 @@
-// jiacheng start
-#ifndef ART_RUNTIME_JIACHENG_BLOOM_FILTER_H_
-#define ART_RUNTIME_JIACHENG_BLOOM_FILTER_H_
-
-/*
-* Code inspired by:
-* https://github.com/jvirkki/libbloom/blob/master/bloom.c
-*/
-
-#include <cinttypes>
-#include <cmath>
-#include <cstddef>
-#include <cstdlib>
-#include <cassert>
-
-namespace art{
-namespace jiacheng {
-
-class BloomFilter {
-public:
-    /*
-    * BloomFilter: initialize a bloom filter.
-    *
-    * Parameters:
-    *   entries: The expected number of elements that will be added
-    *   fp_rate: The desired upper bound on the false positive rate
-    */
-    BloomFilter(uint64_t entries, double fp_rate):hash_() {
-        assert(fp_rate < 1 && fp_rate > 0);
-
-        double num, denom, bpe, dentries;
-        num = std::log(fp_rate);
-        denom = 0.480453013918201; // ln(2)^2
-        bpe = -(num / denom);
-
-        dentries = (double)entries;
-        bits_ = (uint_fast32_t)(dentries * bpe);
-
-        if (bits_ % 8) {
-            byte_size_ = (bits_ / 8) + 1;
-        } else {
-            byte_size_ = bits_ / 8;
-        }
-        hash_num_ = (uint_fast16_t)std::ceil(0.693147180559945 * bpe); // ln(2)
-        bf_ = (uint8_t*)calloc(byte_size_, sizeof(uint8_t));
-        assert(bf_ != NULL);
-    }
-
-    ~BloomFilter() {
-        free(bf_);
-    }
-
-    /*
-    * Add: add an item to a bloom filter.
-    *
-    * Parameters:
-    *   element: the data that should be added
-    *
-    * Returns:
-    *    false - element was not present and was added
-    *    true - element (or a collision) had already been added previously
-    */
-    bool Add(uint64_t element) {
-        uint64_t hits = 0;
-
-        uint32_t a = hash_(element);
-        uint32_t b = hash_(a);
-        uint32_t x;
-
-        for (uint32_t i = 0; i < hash_num_; i++) {
-            x = (a + i * b) % bits_;
-    #define THREAD_SAFE true
-    #ifdef THREAD_SAFE
-            if (__sync_fetch_and_or(bf_ + (x >> 3), (uint8_t)(1 << (x & 7)))) {
-                hits++;
-            }
-    #else
-            if (*(bf_ + (x >> 3)) & (1 << (x & 7))) {
-                hits++;
-            }
-            *(bf_ + (x >> 3)) |= (1 << (x & 7));
-    #endif
-        }
-
-        if (hits == hash_num_) {
-            return true;
-        }
-        return false;
-    }
-
-    /*
-    * Check: check if an item is in the bloom filter.
-    *
-    * Parameters:
-    *   element: the data that should be checked
-    *
-    * Returns:
-    *    false - element is not present
-    *    true - element is present (or a collision)
-    */
-    bool Check(uint64_t element) {
-        uint64_t hits = 0;
-        uint32_t x;
-
-        uint32_t a = hash_(element);
-        uint32_t b = hash_(a);
-        for (uint32_t i = 0; i < hash_num_; i++) {
-            x = (a + i * b) % bits_;
-            if (*(bf_ + (x >> 3)) & (1 << (x & 7))) {
-                hits++;
-            } else {
-                return false;
-            }
-        }
-        return hits == hash_num_;
-    }
-
-    void Clear() {
-        std::memset(bf_, 0, byte_size_);
-    }
-
-
-private:
-    std::hash<uint64_t> hash_;
-    uint32_t byte_size_;
-    uint_fast32_t bits_;        // Number of bits in the bloom filter buffer
-    uint_fast16_t hash_num_;    // Number of hashes used per element added
-    uint8_t *bf_;               // Location of the underlying bit field
-};
-
-} // namespace jiacheng
-} // namespace art
-
-#endif
-
-// jiacheng end
\ No newline at end of file
diff --git a/runtime/jiacheng_debug.h b/runtime/jiacheng_debug.h
new file mode 100644
index 0000000000..ff1f53c482
--- /dev/null
+++ b/runtime/jiacheng_debug.h
@@ -0,0 +1,14 @@
+// jiacheng start
+
+#ifndef ART_RUNTIME_JIACHENG_DEBUG_H_
+#define ART_RUNTIME_JIACHENG_DEBUG_H_
+
+#define JIACHENG_DEBUG
+// #undef JIACHENG_DEBUG
+
+
+// Other variables are immigrated to "runtime/jiacheng_global.h"
+
+#endif
+
+// jiacheng end
\ No newline at end of file
diff --git a/runtime/jiacheng_global.h b/runtime/jiacheng_global.h
index 5451e741f7..7aa0543d97 100644
--- a/runtime/jiacheng_global.h
+++ b/runtime/jiacheng_global.h
@@ -4,21 +4,19 @@
 #define ART_RUNTIME_JIACHENG_GLOBAL_H_
 
 #include "base/globals.h"
+#include "jiacheng_debug.h"
 
 namespace art {
 namespace jiacheng {
 
-#define JIACHENG_DEBUG
-
-
 constexpr bool ENABLE_ACCESS_BARRIER = true;
 constexpr bool ENABLE_ALLOCATION_BARRIER = true;
 
-constexpr bool ENABLE_APGC = false;
-constexpr bool ENABLE_NRO = false;
-constexpr bool ENABLE_FYO = false;
+constexpr bool ENABLE_APGC = true;
+constexpr bool ENABLE_NRO = true;
+constexpr bool ENABLE_FYO = true;
 
-constexpr bool ENABLE_BGC = false;
+constexpr bool ENABLE_BGC = true;
 
 constexpr uint32_t WINDOW_SIZE_HOT_LAUNCH = 5; 
 constexpr uint32_t WINDOW_SIZE_BACKGROUND_WS = 10;
diff --git a/runtime/mirror/array-inl.h b/runtime/mirror/array-inl.h
index b392e41f9a..4d08d44110 100644
--- a/runtime/mirror/array-inl.h
+++ b/runtime/mirror/array-inl.h
@@ -100,7 +100,9 @@ inline void PrimitiveArray<T>::SetWithoutChecks(int32_t i, T value) {
   DCHECK(CheckIsValidIndex<kVerifyFlags>(i));
   GetData()[i] = value;
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+  #endif
   // jiacheng end
 }
 // Backward copy where elements are of aligned appropriately for T. Count is in T sized units.
@@ -188,7 +190,9 @@ inline void PrimitiveArray<T>::Memmove(int32_t dst_pos,
     }
   }
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+  #endif
   // jiacheng end
 }
 
@@ -230,7 +234,9 @@ inline void PrimitiveArray<T>::Memcpy(int32_t dst_pos,
     ArrayForwardCopy<uint64_t>(d, s, count);
   }
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+  #endif
   // jiacheng end
 }
 
diff --git a/runtime/mirror/array.h b/runtime/mirror/array.h
index 6076875890..deffac272b 100644
--- a/runtime/mirror/array.h
+++ b/runtime/mirror/array.h
@@ -37,7 +37,7 @@ class MANAGED Array : public Object {
   #ifdef JIACHENG_DEBUG
   static constexpr size_t kFirstElementOffset = 12u + 8u + 8u;
   #else
-  static constexpr size_t kFirstElementOffset = 12u + 8u;
+  static constexpr size_t kFirstElementOffset = 12u;
   #endif
   // jiacheng end
 
@@ -103,7 +103,9 @@ class MANAGED Array : public Object {
   void* GetRawData(size_t component_size, int32_t index)
       REQUIRES_SHARED(Locks::mutator_lock_) {
     // jiacheng start
+    #ifdef JIACHENG_DEBUG
     jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+    #endif
     // jiacheng end
     intptr_t data = reinterpret_cast<intptr_t>(this) + DataOffset(component_size).Int32Value() +
         + (index * component_size);
@@ -112,7 +114,9 @@ class MANAGED Array : public Object {
   template <size_t kComponentSize>
   void* GetRawData(int32_t index) REQUIRES_SHARED(Locks::mutator_lock_) {
     // jiacheng start
+    #ifdef JIACHENG_DEBUG
     jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+    #endif
     // jiacheng end
     intptr_t data = reinterpret_cast<intptr_t>(this) + DataOffset<kComponentSize>().Int32Value() +
         + (index * kComponentSize);
@@ -121,7 +125,9 @@ class MANAGED Array : public Object {
 
   const void* GetRawData(size_t component_size, int32_t index) const {
     // jiacheng start
+    #ifdef JIACHENG_DEBUG
     jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+    #endif
     // jiacheng end
     intptr_t data = reinterpret_cast<intptr_t>(this) + DataOffset(component_size).Int32Value() +
         + (index * component_size);
@@ -130,7 +136,9 @@ class MANAGED Array : public Object {
   template <size_t kComponentSize>
   const void* GetRawData(int32_t index) const {
     // jiacheng start
+    #ifdef JIACHENG_DEBUG
     jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+    #endif
     // jiacheng end
     intptr_t data = reinterpret_cast<intptr_t>(this) + DataOffset<kComponentSize>().Int32Value() +
         + (index * kComponentSize);
diff --git a/runtime/mirror/object-inl.h b/runtime/mirror/object-inl.h
index 3199efd28d..100004a34e 100644
--- a/runtime/mirror/object-inl.h
+++ b/runtime/mirror/object-inl.h
@@ -603,7 +603,9 @@ template<class T,
          bool kIsVolatile>
 inline T* Object::GetFieldObject(MemberOffset field_offset) {
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+  #endif
   // jiacheng end
   Verify<kVerifyFlags>();
   uint8_t* raw_addr = reinterpret_cast<uint8_t*>(this) + field_offset.Int32Value();
@@ -629,7 +631,9 @@ inline void Object::SetFieldObjectWithoutWriteBarrier(MemberOffset field_offset,
                                                       ObjPtr<Object> new_value) {
   VerifyTransaction<kTransactionActive, kCheckTransaction>();
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+  #endif
   // jiacheng end
   if (kTransactionActive) {
     ObjPtr<Object> obj;
@@ -955,6 +959,8 @@ inline void Object::VerifyTransaction() {
 }
 
 // jiacheng start
+#ifdef JIACHENG_DEBUG
+
 inline void Object::SetForegroundAccessRecord(uint16_t current_time) {
   if (Runtime::Current()->IsSystemServer()) return;
   if (foreground_access_record_ != current_time) {
@@ -990,6 +996,8 @@ inline uint16_t Object::GetHotLaunchAccessRecord() {
   if (Runtime::Current()->IsSystemServer()) return 0;
   return hot_launch_access_record_;
 }
+#endif
+
 // jiacheng end
 
 }  // namespace mirror
diff --git a/runtime/mirror/object-refvisitor-inl.h b/runtime/mirror/object-refvisitor-inl.h
index 3729f729b1..841ab1996b 100644
--- a/runtime/mirror/object-refvisitor-inl.h
+++ b/runtime/mirror/object-refvisitor-inl.h
@@ -34,7 +34,9 @@ template <bool kVisitNativeRoots,
 inline void Object::VisitReferences(const Visitor& visitor,
                                     const JavaLangRefVisitor& ref_visitor) {
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+  #endif
   // jiacheng end
   visitor(this, ClassOffset(), /* is_static= */ false);
   ObjPtr<Class> klass = GetClass<kVerifyFlags, kReadBarrierOption>();
diff --git a/runtime/mirror/object.cc b/runtime/mirror/object.cc
index f549ac0f90..5c72a52412 100644
--- a/runtime/mirror/object.cc
+++ b/runtime/mirror/object.cc
@@ -314,7 +314,6 @@ void Object::SetDebugFlag(uint64_t debug_flag) {
 uint64_t Object::GetDebugFlag() {
   return debug_flag_.load(std::memory_order_relaxed);
 }
-#endif
 
 void Object::Debug() {
   LOG(INFO) << "jiacheng object.cc Object::Debug()"
@@ -326,6 +325,7 @@ void Object::Debug() {
             << " debug_flag_= " << debug_flag_.load(std::memory_order_relaxed)
             ;
 }
+#endif
 
 
 // jiacheng end
diff --git a/runtime/mirror/object.h b/runtime/mirror/object.h
index c3f4d0a19d..f7827159d9 100644
--- a/runtime/mirror/object.h
+++ b/runtime/mirror/object.h
@@ -76,8 +76,11 @@ static constexpr bool kCheckFieldAssignments = false;
 
 // Size of Object.
 // jiacheng start
-// static constexpr uint32_t kObjectHeaderSize = kUseBrooksReadBarrier ? 16 : 8;
+#ifdef JIACHENG_DEBUG
 static constexpr uint32_t kObjectHeaderSize = kUseBrooksReadBarrier ? 24 : 16;
+#else
+static constexpr uint32_t kObjectHeaderSize = kUseBrooksReadBarrier ? 16 : 8;
+#endif
 // jiacheng end
 
 // C++ mirror of java.lang.Object
@@ -99,6 +102,7 @@ class MANAGED LOCKABLE Object {
   }
 
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   static constexpr MemberOffset ForegroundAccessRecordOffset() {
     return OFFSET_OF_OBJECT_MEMBER(Object, foreground_access_record_);
   }
@@ -174,11 +178,9 @@ class MANAGED LOCKABLE Object {
     return padding_;
   }
 
-  #ifdef JIACHENG_DEBUG
   void SetDebugFlag(uint64_t debug_flag);
 
   uint64_t GetDebugFlag();
-  #endif
 
 
   void CopyHeaderFrom(Object* from) {
@@ -193,6 +195,7 @@ class MANAGED LOCKABLE Object {
 
 
   void Debug();
+  #endif
 
   // jiacheng end
 
@@ -456,7 +459,9 @@ class MANAGED LOCKABLE Object {
   ALWAYS_INLINE void SetFieldPrimitive(MemberOffset field_offset, kType new_value)
       REQUIRES_SHARED(Locks::mutator_lock_) {
     // jiacheng start
+    #ifdef JIACHENG_DEBUG
     jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+    #endif
     // jiacheng end
     uint8_t* raw_addr = reinterpret_cast<uint8_t*>(this) + field_offset.Int32Value();
     kType* addr = reinterpret_cast<kType*>(raw_addr);
@@ -471,7 +476,9 @@ class MANAGED LOCKABLE Object {
   ALWAYS_INLINE kType GetFieldPrimitive(MemberOffset field_offset)
       REQUIRES_SHARED(Locks::mutator_lock_) {
     // jiacheng start
+    #ifdef JIACHENG_DEBUG
     jiacheng::JiachengBarrier(reinterpret_cast<uint64_t>(this));
+    #endif
     // jiacheng end
     const uint8_t* raw_addr = reinterpret_cast<const uint8_t*>(this) + field_offset.Int32Value();
     const kType* addr = reinterpret_cast<const kType*>(raw_addr);
@@ -884,12 +891,13 @@ class MANAGED LOCKABLE Object {
   uint32_t monitor_;
 
   // jiacheng start
+#ifdef JIACHENG_DEBUG
   uint16_t foreground_access_record_;
   uint16_t background_access_record_;
   uint16_t hot_launch_access_record_;
   uint16_t padding_;   // used for debug
 
-#ifdef JIACHENG_DEBUG
+
   std::atomic<uint64_t> debug_flag_;
 #endif
   // jiacheng end
diff --git a/runtime/thread-inl.h b/runtime/thread-inl.h
index 7cc1100528..9250d2d6f3 100644
--- a/runtime/thread-inl.h
+++ b/runtime/thread-inl.h
@@ -312,7 +312,9 @@ inline mirror::Object* Thread::AllocTlab(size_t bytes) {
   mirror::Object* ret = reinterpret_cast<mirror::Object*>(tlsPtr_.thread_local_pos);
   tlsPtr_.thread_local_pos += bytes;
   // jiacheng start
+  #ifdef JIACHENG_DEBUG
   jiacheng::AllocationNewBarrier(reinterpret_cast<uint64_t>(ret));
+  #endif
   // jiacheng end
   return ret;
 }
-- 
2.34.1

